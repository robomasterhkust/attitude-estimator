
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
 80001c0:	b672      	cpsid	i
 80001c2:	4834      	ldr	r0, [pc, #208]	; (8000294 <endfiniloop+0x6>)
 80001c4:	f380 8809 	msr	PSP, r0
 80001c8:	f240 0000 	movw	r0, #0
 80001cc:	f2cc 0000 	movt	r0, #49152	; 0xc000
 80001d0:	f64e 7134 	movw	r1, #61236	; 0xef34
 80001d4:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001d8:	6008      	str	r0, [r1, #0]
 80001da:	f3bf 8f4f 	dsb	sy
 80001de:	f3bf 8f6f 	isb	sy
 80001e2:	f240 0000 	movw	r0, #0
 80001e6:	f2c0 00f0 	movt	r0, #240	; 0xf0
 80001ea:	f64e 5188 	movw	r1, #60808	; 0xed88
 80001ee:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001f2:	6008      	str	r0, [r1, #0]
 80001f4:	f3bf 8f4f 	dsb	sy
 80001f8:	f3bf 8f6f 	isb	sy
 80001fc:	f04f 0000 	mov.w	r0, #0
 8000200:	eee1 0a10 	vmsr	fpscr, r0
 8000204:	f64e 713c 	movw	r1, #61244	; 0xef3c
 8000208:	f2ce 0100 	movt	r1, #57344	; 0xe000
 800020c:	6008      	str	r0, [r1, #0]
 800020e:	2006      	movs	r0, #6
 8000210:	f380 8814 	msr	CONTROL, r0
 8000214:	f3bf 8f6f 	isb	sy
 8000218:	f003 fae2 	bl	80037e0 <__core_init>
 800021c:	f000 fec8 	bl	8000fb0 <__early_init>
 8000220:	481d      	ldr	r0, [pc, #116]	; (8000298 <endfiniloop+0xa>)
 8000222:	491e      	ldr	r1, [pc, #120]	; (800029c <endfiniloop+0xe>)
 8000224:	4a1e      	ldr	r2, [pc, #120]	; (80002a0 <endfiniloop+0x12>)

08000226 <msloop>:
 8000226:	4291      	cmp	r1, r2
 8000228:	bf3c      	itt	cc
 800022a:	f841 0b04 	strcc.w	r0, [r1], #4
 800022e:	e7fa      	bcc.n	8000226 <msloop>
 8000230:	491c      	ldr	r1, [pc, #112]	; (80002a4 <endfiniloop+0x16>)
 8000232:	4a18      	ldr	r2, [pc, #96]	; (8000294 <endfiniloop+0x6>)

08000234 <psloop>:
 8000234:	4291      	cmp	r1, r2
 8000236:	bf3c      	itt	cc
 8000238:	f841 0b04 	strcc.w	r0, [r1], #4
 800023c:	e7fa      	bcc.n	8000234 <psloop>
 800023e:	491a      	ldr	r1, [pc, #104]	; (80002a8 <endfiniloop+0x1a>)
 8000240:	4a1a      	ldr	r2, [pc, #104]	; (80002ac <endfiniloop+0x1e>)
 8000242:	4b1b      	ldr	r3, [pc, #108]	; (80002b0 <endfiniloop+0x22>)

08000244 <dloop>:
 8000244:	429a      	cmp	r2, r3
 8000246:	bf3e      	ittt	cc
 8000248:	f851 0b04 	ldrcc.w	r0, [r1], #4
 800024c:	f842 0b04 	strcc.w	r0, [r2], #4
 8000250:	e7f8      	bcc.n	8000244 <dloop>
 8000252:	2000      	movs	r0, #0
 8000254:	4917      	ldr	r1, [pc, #92]	; (80002b4 <endfiniloop+0x26>)
 8000256:	4a18      	ldr	r2, [pc, #96]	; (80002b8 <endfiniloop+0x2a>)

08000258 <bloop>:
 8000258:	4291      	cmp	r1, r2
 800025a:	bf3c      	itt	cc
 800025c:	f841 0b04 	strcc.w	r0, [r1], #4
 8000260:	e7fa      	bcc.n	8000258 <bloop>
 8000262:	f003 fa85 	bl	8003770 <__init_ram_areas>
 8000266:	f003 fab3 	bl	80037d0 <__late_init>
 800026a:	4c14      	ldr	r4, [pc, #80]	; (80002bc <endfiniloop+0x2e>)
 800026c:	4d14      	ldr	r5, [pc, #80]	; (80002c0 <endfiniloop+0x32>)

0800026e <initloop>:
 800026e:	42ac      	cmp	r4, r5
 8000270:	da03      	bge.n	800027a <endinitloop>
 8000272:	f854 1b04 	ldr.w	r1, [r4], #4
 8000276:	4788      	blx	r1
 8000278:	e7f9      	b.n	800026e <initloop>

0800027a <endinitloop>:
 800027a:	f003 fab9 	bl	80037f0 <main>
 800027e:	4c11      	ldr	r4, [pc, #68]	; (80002c4 <endfiniloop+0x36>)
 8000280:	4d11      	ldr	r5, [pc, #68]	; (80002c8 <endfiniloop+0x3a>)

08000282 <finiloop>:
 8000282:	42ac      	cmp	r4, r5
 8000284:	da03      	bge.n	800028e <endfiniloop>
 8000286:	f854 1b04 	ldr.w	r1, [r4], #4
 800028a:	4788      	blx	r1
 800028c:	e7f9      	b.n	8000282 <finiloop>

0800028e <endfiniloop>:
 800028e:	f003 ba97 	b.w	80037c0 <__default_exit>
 8000292:	0000      	.short	0x0000
 8000294:	20000800 	.word	0x20000800
 8000298:	55555555 	.word	0x55555555
 800029c:	20000000 	.word	0x20000000
 80002a0:	20000400 	.word	0x20000400
 80002a4:	20000400 	.word	0x20000400
 80002a8:	08006fb0 	.word	0x08006fb0
 80002ac:	20000800 	.word	0x20000800
 80002b0:	20000800 	.word	0x20000800
 80002b4:	20000800 	.word	0x20000800
 80002b8:	200032e0 	.word	0x200032e0
 80002bc:	080001c0 	.word	0x080001c0
 80002c0:	080001c0 	.word	0x080001c0
 80002c4:	080001c0 	.word	0x080001c0
 80002c8:	080001c0 	.word	0x080001c0
 80002cc:	00000000 	.word	0x00000000

080002d0 <_port_switch>:
 80002d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002d4:	ed2d 8a10 	vpush	{s16-s31}
 80002d8:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002dc:	68c3      	ldr	r3, [r0, #12]
 80002de:	469d      	mov	sp, r3
 80002e0:	ecbd 8a10 	vpop	{s16-s31}
 80002e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002e8 <_port_thread_start>:
 80002e8:	f003 f90a 	bl	8003500 <_dbg_check_unlock>
 80002ec:	f002 fe80 	bl	8002ff0 <_stats_stop_measure_crit_thd>
 80002f0:	2300      	movs	r3, #0
 80002f2:	f383 8811 	msr	BASEPRI, r3
 80002f6:	4628      	mov	r0, r5
 80002f8:	47a0      	blx	r4
 80002fa:	2000      	movs	r0, #0
 80002fc:	f003 f920 	bl	8003540 <chThdExit>

08000300 <_port_switch_from_isr>:
 8000300:	f002 fe8e 	bl	8003020 <_stats_start_measure_crit_thd>
 8000304:	f003 f90c 	bl	8003520 <_dbg_check_lock>
 8000308:	f002 fe92 	bl	8003030 <chSchDoReschedule>
 800030c:	f003 f8f8 	bl	8003500 <_dbg_check_unlock>
 8000310:	f002 fe6e 	bl	8002ff0 <_stats_stop_measure_crit_thd>

08000314 <_port_exit_from_isr>:
 8000314:	df00      	svc	0
 8000316:	e7fe      	b.n	8000316 <_port_exit_from_isr+0x2>
	...

08000320 <memcpy>:
 8000320:	4684      	mov	ip, r0
 8000322:	ea41 0300 	orr.w	r3, r1, r0
 8000326:	f013 0303 	ands.w	r3, r3, #3
 800032a:	d16d      	bne.n	8000408 <memcpy+0xe8>
 800032c:	3a40      	subs	r2, #64	; 0x40
 800032e:	d341      	bcc.n	80003b4 <memcpy+0x94>
 8000330:	f851 3b04 	ldr.w	r3, [r1], #4
 8000334:	f840 3b04 	str.w	r3, [r0], #4
 8000338:	f851 3b04 	ldr.w	r3, [r1], #4
 800033c:	f840 3b04 	str.w	r3, [r0], #4
 8000340:	f851 3b04 	ldr.w	r3, [r1], #4
 8000344:	f840 3b04 	str.w	r3, [r0], #4
 8000348:	f851 3b04 	ldr.w	r3, [r1], #4
 800034c:	f840 3b04 	str.w	r3, [r0], #4
 8000350:	f851 3b04 	ldr.w	r3, [r1], #4
 8000354:	f840 3b04 	str.w	r3, [r0], #4
 8000358:	f851 3b04 	ldr.w	r3, [r1], #4
 800035c:	f840 3b04 	str.w	r3, [r0], #4
 8000360:	f851 3b04 	ldr.w	r3, [r1], #4
 8000364:	f840 3b04 	str.w	r3, [r0], #4
 8000368:	f851 3b04 	ldr.w	r3, [r1], #4
 800036c:	f840 3b04 	str.w	r3, [r0], #4
 8000370:	f851 3b04 	ldr.w	r3, [r1], #4
 8000374:	f840 3b04 	str.w	r3, [r0], #4
 8000378:	f851 3b04 	ldr.w	r3, [r1], #4
 800037c:	f840 3b04 	str.w	r3, [r0], #4
 8000380:	f851 3b04 	ldr.w	r3, [r1], #4
 8000384:	f840 3b04 	str.w	r3, [r0], #4
 8000388:	f851 3b04 	ldr.w	r3, [r1], #4
 800038c:	f840 3b04 	str.w	r3, [r0], #4
 8000390:	f851 3b04 	ldr.w	r3, [r1], #4
 8000394:	f840 3b04 	str.w	r3, [r0], #4
 8000398:	f851 3b04 	ldr.w	r3, [r1], #4
 800039c:	f840 3b04 	str.w	r3, [r0], #4
 80003a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a4:	f840 3b04 	str.w	r3, [r0], #4
 80003a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003ac:	f840 3b04 	str.w	r3, [r0], #4
 80003b0:	3a40      	subs	r2, #64	; 0x40
 80003b2:	d2bd      	bcs.n	8000330 <memcpy+0x10>
 80003b4:	3230      	adds	r2, #48	; 0x30
 80003b6:	d311      	bcc.n	80003dc <memcpy+0xbc>
 80003b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003bc:	f840 3b04 	str.w	r3, [r0], #4
 80003c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c4:	f840 3b04 	str.w	r3, [r0], #4
 80003c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003cc:	f840 3b04 	str.w	r3, [r0], #4
 80003d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003d4:	f840 3b04 	str.w	r3, [r0], #4
 80003d8:	3a10      	subs	r2, #16
 80003da:	d2ed      	bcs.n	80003b8 <memcpy+0x98>
 80003dc:	320c      	adds	r2, #12
 80003de:	d305      	bcc.n	80003ec <memcpy+0xcc>
 80003e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003e4:	f840 3b04 	str.w	r3, [r0], #4
 80003e8:	3a04      	subs	r2, #4
 80003ea:	d2f9      	bcs.n	80003e0 <memcpy+0xc0>
 80003ec:	3204      	adds	r2, #4
 80003ee:	d008      	beq.n	8000402 <memcpy+0xe2>
 80003f0:	07d2      	lsls	r2, r2, #31
 80003f2:	bf1c      	itt	ne
 80003f4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003f8:	f800 3b01 	strbne.w	r3, [r0], #1
 80003fc:	d301      	bcc.n	8000402 <memcpy+0xe2>
 80003fe:	880b      	ldrh	r3, [r1, #0]
 8000400:	8003      	strh	r3, [r0, #0]
 8000402:	4660      	mov	r0, ip
 8000404:	4770      	bx	lr
 8000406:	bf00      	nop
 8000408:	2a08      	cmp	r2, #8
 800040a:	d313      	bcc.n	8000434 <memcpy+0x114>
 800040c:	078b      	lsls	r3, r1, #30
 800040e:	d08d      	beq.n	800032c <memcpy+0xc>
 8000410:	f010 0303 	ands.w	r3, r0, #3
 8000414:	d08a      	beq.n	800032c <memcpy+0xc>
 8000416:	f1c3 0304 	rsb	r3, r3, #4
 800041a:	1ad2      	subs	r2, r2, r3
 800041c:	07db      	lsls	r3, r3, #31
 800041e:	bf1c      	itt	ne
 8000420:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000424:	f800 3b01 	strbne.w	r3, [r0], #1
 8000428:	d380      	bcc.n	800032c <memcpy+0xc>
 800042a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800042e:	f820 3b02 	strh.w	r3, [r0], #2
 8000432:	e77b      	b.n	800032c <memcpy+0xc>
 8000434:	3a04      	subs	r2, #4
 8000436:	d3d9      	bcc.n	80003ec <memcpy+0xcc>
 8000438:	3a01      	subs	r2, #1
 800043a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800043e:	f800 3b01 	strb.w	r3, [r0], #1
 8000442:	d2f9      	bcs.n	8000438 <memcpy+0x118>
 8000444:	780b      	ldrb	r3, [r1, #0]
 8000446:	7003      	strb	r3, [r0, #0]
 8000448:	784b      	ldrb	r3, [r1, #1]
 800044a:	7043      	strb	r3, [r0, #1]
 800044c:	788b      	ldrb	r3, [r1, #2]
 800044e:	7083      	strb	r3, [r0, #2]
 8000450:	4660      	mov	r0, ip
 8000452:	4770      	bx	lr
	...
 8000460:	eba2 0003 	sub.w	r0, r2, r3
 8000464:	4770      	bx	lr
 8000466:	bf00      	nop

08000468 <strcmp>:
 8000468:	7802      	ldrb	r2, [r0, #0]
 800046a:	780b      	ldrb	r3, [r1, #0]
 800046c:	2a01      	cmp	r2, #1
 800046e:	bf28      	it	cs
 8000470:	429a      	cmpcs	r2, r3
 8000472:	d1f5      	bne.n	8000460 <memcpy+0x140>
 8000474:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8000478:	ea40 0401 	orr.w	r4, r0, r1
 800047c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8000480:	f06f 0c00 	mvn.w	ip, #0
 8000484:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8000488:	b312      	cbz	r2, 80004d0 <strcmp+0x68>
 800048a:	ea80 0401 	eor.w	r4, r0, r1
 800048e:	f014 0f07 	tst.w	r4, #7
 8000492:	d16a      	bne.n	800056a <strcmp+0x102>
 8000494:	f000 0407 	and.w	r4, r0, #7
 8000498:	f020 0007 	bic.w	r0, r0, #7
 800049c:	f004 0503 	and.w	r5, r4, #3
 80004a0:	f021 0107 	bic.w	r1, r1, #7
 80004a4:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 80004a8:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 80004ac:	f014 0f04 	tst.w	r4, #4
 80004b0:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 80004b4:	fa0c f405 	lsl.w	r4, ip, r5
 80004b8:	ea62 0204 	orn	r2, r2, r4
 80004bc:	ea66 0604 	orn	r6, r6, r4
 80004c0:	d00a      	beq.n	80004d8 <strcmp+0x70>
 80004c2:	ea63 0304 	orn	r3, r3, r4
 80004c6:	4662      	mov	r2, ip
 80004c8:	ea67 0704 	orn	r7, r7, r4
 80004cc:	4666      	mov	r6, ip
 80004ce:	e003      	b.n	80004d8 <strcmp+0x70>
 80004d0:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 80004d4:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 80004d8:	fa82 f54c 	uadd8	r5, r2, ip
 80004dc:	ea82 0406 	eor.w	r4, r2, r6
 80004e0:	faa4 f48c 	sel	r4, r4, ip
 80004e4:	bb6c      	cbnz	r4, 8000542 <strcmp+0xda>
 80004e6:	fa83 f54c 	uadd8	r5, r3, ip
 80004ea:	ea83 0507 	eor.w	r5, r3, r7
 80004ee:	faa5 f58c 	sel	r5, r5, ip
 80004f2:	b995      	cbnz	r5, 800051a <strcmp+0xb2>
 80004f4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 80004f8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 80004fc:	fa82 f54c 	uadd8	r5, r2, ip
 8000500:	ea82 0406 	eor.w	r4, r2, r6
 8000504:	faa4 f48c 	sel	r4, r4, ip
 8000508:	fa83 f54c 	uadd8	r5, r3, ip
 800050c:	ea83 0507 	eor.w	r5, r3, r7
 8000510:	faa5 f58c 	sel	r5, r5, ip
 8000514:	4325      	orrs	r5, r4
 8000516:	d0db      	beq.n	80004d0 <strcmp+0x68>
 8000518:	b99c      	cbnz	r4, 8000542 <strcmp+0xda>
 800051a:	ba2d      	rev	r5, r5
 800051c:	fab5 f485 	clz	r4, r5
 8000520:	f024 0407 	bic.w	r4, r4, #7
 8000524:	fa27 f104 	lsr.w	r1, r7, r4
 8000528:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800052c:	fa23 f304 	lsr.w	r3, r3, r4
 8000530:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8000534:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000538:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800053c:	eba0 0001 	sub.w	r0, r0, r1
 8000540:	4770      	bx	lr
 8000542:	ba24      	rev	r4, r4
 8000544:	fab4 f484 	clz	r4, r4
 8000548:	f024 0407 	bic.w	r4, r4, #7
 800054c:	fa26 f104 	lsr.w	r1, r6, r4
 8000550:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000554:	fa22 f204 	lsr.w	r2, r2, r4
 8000558:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800055c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000560:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000564:	eba0 0001 	sub.w	r0, r0, r1
 8000568:	4770      	bx	lr
 800056a:	f014 0f03 	tst.w	r4, #3
 800056e:	d13c      	bne.n	80005ea <strcmp+0x182>
 8000570:	f010 0403 	ands.w	r4, r0, #3
 8000574:	d128      	bne.n	80005c8 <strcmp+0x160>
 8000576:	f850 2b08 	ldr.w	r2, [r0], #8
 800057a:	f851 3b08 	ldr.w	r3, [r1], #8
 800057e:	fa82 f54c 	uadd8	r5, r2, ip
 8000582:	ea82 0503 	eor.w	r5, r2, r3
 8000586:	faa5 f58c 	sel	r5, r5, ip
 800058a:	b95d      	cbnz	r5, 80005a4 <strcmp+0x13c>
 800058c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8000590:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000594:	fa82 f54c 	uadd8	r5, r2, ip
 8000598:	ea82 0503 	eor.w	r5, r2, r3
 800059c:	faa5 f58c 	sel	r5, r5, ip
 80005a0:	2d00      	cmp	r5, #0
 80005a2:	d0e8      	beq.n	8000576 <strcmp+0x10e>
 80005a4:	ba2d      	rev	r5, r5
 80005a6:	fab5 f485 	clz	r4, r5
 80005aa:	f024 0407 	bic.w	r4, r4, #7
 80005ae:	fa23 f104 	lsr.w	r1, r3, r4
 80005b2:	fa22 f204 	lsr.w	r2, r2, r4
 80005b6:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 80005ba:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80005be:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80005c2:	eba0 0001 	sub.w	r0, r0, r1
 80005c6:	4770      	bx	lr
 80005c8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 80005cc:	f020 0003 	bic.w	r0, r0, #3
 80005d0:	f850 2b08 	ldr.w	r2, [r0], #8
 80005d4:	f021 0103 	bic.w	r1, r1, #3
 80005d8:	f851 3b08 	ldr.w	r3, [r1], #8
 80005dc:	fa0c f404 	lsl.w	r4, ip, r4
 80005e0:	ea62 0204 	orn	r2, r2, r4
 80005e4:	ea63 0304 	orn	r3, r3, r4
 80005e8:	e7c9      	b.n	800057e <strcmp+0x116>
 80005ea:	f010 0403 	ands.w	r4, r0, #3
 80005ee:	d01a      	beq.n	8000626 <strcmp+0x1be>
 80005f0:	eba1 0104 	sub.w	r1, r1, r4
 80005f4:	f020 0003 	bic.w	r0, r0, #3
 80005f8:	07e4      	lsls	r4, r4, #31
 80005fa:	f850 2b04 	ldr.w	r2, [r0], #4
 80005fe:	d006      	beq.n	800060e <strcmp+0x1a6>
 8000600:	d20f      	bcs.n	8000622 <strcmp+0x1ba>
 8000602:	788b      	ldrb	r3, [r1, #2]
 8000604:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 8000608:	1ae4      	subs	r4, r4, r3
 800060a:	d106      	bne.n	800061a <strcmp+0x1b2>
 800060c:	b12b      	cbz	r3, 800061a <strcmp+0x1b2>
 800060e:	78cb      	ldrb	r3, [r1, #3]
 8000610:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 8000614:	1ae4      	subs	r4, r4, r3
 8000616:	d100      	bne.n	800061a <strcmp+0x1b2>
 8000618:	b91b      	cbnz	r3, 8000622 <strcmp+0x1ba>
 800061a:	4620      	mov	r0, r4
 800061c:	f85d 4b10 	ldr.w	r4, [sp], #16
 8000620:	4770      	bx	lr
 8000622:	f101 0104 	add.w	r1, r1, #4
 8000626:	f850 2b04 	ldr.w	r2, [r0], #4
 800062a:	07cc      	lsls	r4, r1, #31
 800062c:	f021 0103 	bic.w	r1, r1, #3
 8000630:	f851 3b04 	ldr.w	r3, [r1], #4
 8000634:	d848      	bhi.n	80006c8 <strcmp+0x260>
 8000636:	d224      	bcs.n	8000682 <strcmp+0x21a>
 8000638:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 800063c:	fa82 f54c 	uadd8	r5, r2, ip
 8000640:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8000644:	faa5 f58c 	sel	r5, r5, ip
 8000648:	d10a      	bne.n	8000660 <strcmp+0x1f8>
 800064a:	b965      	cbnz	r5, 8000666 <strcmp+0x1fe>
 800064c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000650:	ea84 0402 	eor.w	r4, r4, r2
 8000654:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8000658:	d10e      	bne.n	8000678 <strcmp+0x210>
 800065a:	f850 2b04 	ldr.w	r2, [r0], #4
 800065e:	e7eb      	b.n	8000638 <strcmp+0x1d0>
 8000660:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000664:	e055      	b.n	8000712 <strcmp+0x2aa>
 8000666:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 800066a:	d14d      	bne.n	8000708 <strcmp+0x2a0>
 800066c:	7808      	ldrb	r0, [r1, #0]
 800066e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000672:	f1c0 0000 	rsb	r0, r0, #0
 8000676:	4770      	bx	lr
 8000678:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800067c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000680:	e047      	b.n	8000712 <strcmp+0x2aa>
 8000682:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8000686:	fa82 f54c 	uadd8	r5, r2, ip
 800068a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 800068e:	faa5 f58c 	sel	r5, r5, ip
 8000692:	d10a      	bne.n	80006aa <strcmp+0x242>
 8000694:	b965      	cbnz	r5, 80006b0 <strcmp+0x248>
 8000696:	f851 3b04 	ldr.w	r3, [r1], #4
 800069a:	ea84 0402 	eor.w	r4, r4, r2
 800069e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 80006a2:	d10c      	bne.n	80006be <strcmp+0x256>
 80006a4:	f850 2b04 	ldr.w	r2, [r0], #4
 80006a8:	e7eb      	b.n	8000682 <strcmp+0x21a>
 80006aa:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80006ae:	e030      	b.n	8000712 <strcmp+0x2aa>
 80006b0:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 80006b4:	d128      	bne.n	8000708 <strcmp+0x2a0>
 80006b6:	880b      	ldrh	r3, [r1, #0]
 80006b8:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80006bc:	e029      	b.n	8000712 <strcmp+0x2aa>
 80006be:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80006c2:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 80006c6:	e024      	b.n	8000712 <strcmp+0x2aa>
 80006c8:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 80006cc:	fa82 f54c 	uadd8	r5, r2, ip
 80006d0:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 80006d4:	faa5 f58c 	sel	r5, r5, ip
 80006d8:	d10a      	bne.n	80006f0 <strcmp+0x288>
 80006da:	b965      	cbnz	r5, 80006f6 <strcmp+0x28e>
 80006dc:	f851 3b04 	ldr.w	r3, [r1], #4
 80006e0:	ea84 0402 	eor.w	r4, r4, r2
 80006e4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 80006e8:	d109      	bne.n	80006fe <strcmp+0x296>
 80006ea:	f850 2b04 	ldr.w	r2, [r0], #4
 80006ee:	e7eb      	b.n	80006c8 <strcmp+0x260>
 80006f0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80006f4:	e00d      	b.n	8000712 <strcmp+0x2aa>
 80006f6:	f015 0fff 	tst.w	r5, #255	; 0xff
 80006fa:	d105      	bne.n	8000708 <strcmp+0x2a0>
 80006fc:	680b      	ldr	r3, [r1, #0]
 80006fe:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8000702:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000706:	e004      	b.n	8000712 <strcmp+0x2aa>
 8000708:	f04f 0000 	mov.w	r0, #0
 800070c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000710:	4770      	bx	lr
 8000712:	ba12      	rev	r2, r2
 8000714:	ba1b      	rev	r3, r3
 8000716:	fa82 f44c 	uadd8	r4, r2, ip
 800071a:	ea82 0403 	eor.w	r4, r2, r3
 800071e:	faa4 f58c 	sel	r5, r4, ip
 8000722:	fab5 f485 	clz	r4, r5
 8000726:	fa02 f204 	lsl.w	r2, r2, r4
 800072a:	fa03 f304 	lsl.w	r3, r3, r4
 800072e:	ea4f 6012 	mov.w	r0, r2, lsr #24
 8000732:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000736:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 800073a:	4770      	bx	lr
 800073c:	0000      	movs	r0, r0
	...

08000740 <notify3.lto_priv.56>:

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE;
 8000740:	4a02      	ldr	r2, [pc, #8]	; (800074c <notify3.lto_priv.56+0xc>)
 8000742:	68d3      	ldr	r3, [r2, #12]
 8000744:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000748:	60d3      	str	r3, [r2, #12]
 800074a:	4770      	bx	lr
 800074c:	40004800 	.word	0x40004800

08000750 <spi_lld_serve_tx_interrupt.lto_priv.68>:
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000750:	f011 0f0c 	tst.w	r1, #12
 8000754:	d100      	bne.n	8000758 <spi_lld_serve_tx_interrupt.lto_priv.68+0x8>
 8000756:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000758:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800075a:	4b02      	ldr	r3, [pc, #8]	; (8000764 <spi_lld_serve_tx_interrupt.lto_priv.68+0x14>)
 800075c:	4a02      	ldr	r2, [pc, #8]	; (8000768 <spi_lld_serve_tx_interrupt.lto_priv.68+0x18>)
 800075e:	62da      	str	r2, [r3, #44]	; 0x2c
 8000760:	e7fe      	b.n	8000760 <spi_lld_serve_tx_interrupt.lto_priv.68+0x10>
 8000762:	bf00      	nop
 8000764:	20002740 	.word	0x20002740
 8000768:	08005470 	.word	0x08005470
 800076c:	00000000 	.word	0x00000000

08000770 <cmd_info>:
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8000770:	2900      	cmp	r1, #0
 8000772:	dd03      	ble.n	800077c <cmd_info+0xc>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8000774:	4919      	ldr	r1, [pc, #100]	; (80007dc <cmd_info+0x6c>)
 8000776:	4a1a      	ldr	r2, [pc, #104]	; (80007e0 <cmd_info+0x70>)
 8000778:	f001 bde2 	b.w	8002340 <chprintf>
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 800077c:	b510      	push	{r4, lr}
  if (argc > 0) {
    usage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 800077e:	4919      	ldr	r1, [pc, #100]	; (80007e4 <cmd_info+0x74>)
 8000780:	4a19      	ldr	r2, [pc, #100]	; (80007e8 <cmd_info+0x78>)
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8000782:	b082      	sub	sp, #8
 8000784:	4604      	mov	r4, r0
  if (argc > 0) {
    usage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 8000786:	f001 fddb 	bl	8002340 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s\r\n", PORT_COMPILER_NAME);
 800078a:	4620      	mov	r0, r4
 800078c:	4917      	ldr	r1, [pc, #92]	; (80007ec <cmd_info+0x7c>)
 800078e:	4a18      	ldr	r2, [pc, #96]	; (80007f0 <cmd_info+0x80>)
 8000790:	f001 fdd6 	bl	8002340 <chprintf>
#endif
  chprintf(chp, "Architecture: %s\r\n", PORT_ARCHITECTURE_NAME);
 8000794:	4620      	mov	r0, r4
 8000796:	4917      	ldr	r1, [pc, #92]	; (80007f4 <cmd_info+0x84>)
 8000798:	4a17      	ldr	r2, [pc, #92]	; (80007f8 <cmd_info+0x88>)
 800079a:	f001 fdd1 	bl	8002340 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s\r\n", PORT_CORE_VARIANT_NAME);
 800079e:	4620      	mov	r0, r4
 80007a0:	4916      	ldr	r1, [pc, #88]	; (80007fc <cmd_info+0x8c>)
 80007a2:	4a17      	ldr	r2, [pc, #92]	; (8000800 <cmd_info+0x90>)
 80007a4:	f001 fdcc 	bl	8002340 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s\r\n", PORT_INFO);
 80007a8:	4620      	mov	r0, r4
 80007aa:	4916      	ldr	r1, [pc, #88]	; (8000804 <cmd_info+0x94>)
 80007ac:	4a16      	ldr	r2, [pc, #88]	; (8000808 <cmd_info+0x98>)
 80007ae:	f001 fdc7 	bl	8002340 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s\r\n", PLATFORM_NAME);
 80007b2:	4620      	mov	r0, r4
 80007b4:	4915      	ldr	r1, [pc, #84]	; (800080c <cmd_info+0x9c>)
 80007b6:	4a16      	ldr	r2, [pc, #88]	; (8000810 <cmd_info+0xa0>)
 80007b8:	f001 fdc2 	bl	8002340 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s\r\n", BOARD_NAME);
 80007bc:	4620      	mov	r0, r4
 80007be:	4915      	ldr	r1, [pc, #84]	; (8000814 <cmd_info+0xa4>)
 80007c0:	4a15      	ldr	r2, [pc, #84]	; (8000818 <cmd_info+0xa8>)
 80007c2:	f001 fdbd 	bl	8002340 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
 80007c6:	4b15      	ldr	r3, [pc, #84]	; (800081c <cmd_info+0xac>)
 80007c8:	9300      	str	r3, [sp, #0]
 80007ca:	4620      	mov	r0, r4
 80007cc:	4914      	ldr	r1, [pc, #80]	; (8000820 <cmd_info+0xb0>)
 80007ce:	4a15      	ldr	r2, [pc, #84]	; (8000824 <cmd_info+0xb4>)
 80007d0:	4b15      	ldr	r3, [pc, #84]	; (8000828 <cmd_info+0xb8>)
 80007d2:	f001 fdb5 	bl	8002340 <chprintf>
#endif
#endif
}
 80007d6:	b002      	add	sp, #8
 80007d8:	bd10      	pop	{r4, pc}
 80007da:	bf00      	nop
 80007dc:	0800547c 	.word	0x0800547c
 80007e0:	08005488 	.word	0x08005488
 80007e4:	08005490 	.word	0x08005490
 80007e8:	080054a4 	.word	0x080054a4
 80007ec:	080054ac 	.word	0x080054ac
 80007f0:	080054c0 	.word	0x080054c0
 80007f4:	08005508 	.word	0x08005508
 80007f8:	0800551c 	.word	0x0800551c
 80007fc:	08005528 	.word	0x08005528
 8000800:	0800553c 	.word	0x0800553c
 8000804:	08005548 	.word	0x08005548
 8000808:	0800555c 	.word	0x0800555c
 800080c:	08005574 	.word	0x08005574
 8000810:	08005588 	.word	0x08005588
 8000814:	080055b4 	.word	0x080055b4
 8000818:	080055c8 	.word	0x080055c8
 800081c:	0800560c 	.word	0x0800560c
 8000820:	080055e4 	.word	0x080055e4
 8000824:	080055fc 	.word	0x080055fc
 8000828:	08005608 	.word	0x08005608
 800082c:	00000000 	.word	0x00000000

08000830 <Vector108>:
/**
 * @brief   TIM5 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM5_HANDLER) {
 8000830:	b538      	push	{r3, r4, r5, lr}
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8000832:	4d1a      	ldr	r5, [pc, #104]	; (800089c <Vector108+0x6c>)
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM5_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8000834:	f002 fb9c 	bl	8002f70 <_stats_increase_irq>
 8000838:	f002 fde2 	bl	8003400 <_dbg_check_enter_isr>
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 800083c:	69ab      	ldr	r3, [r5, #24]
 800083e:	691a      	ldr	r2, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8000840:	68dc      	ldr	r4, [r3, #12]
 8000842:	4014      	ands	r4, r2
 8000844:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
 8000846:	43d2      	mvns	r2, r2
 8000848:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800084a:	07a3      	lsls	r3, r4, #30
 800084c:	d504      	bpl.n	8000858 <Vector108+0x28>
      (pwmp->config->channels[0].callback != NULL))
 800084e:	686b      	ldr	r3, [r5, #4]
 8000850:	691b      	ldr	r3, [r3, #16]
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8000852:	b10b      	cbz	r3, 8000858 <Vector108+0x28>
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
 8000854:	4628      	mov	r0, r5
 8000856:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8000858:	0760      	lsls	r0, r4, #29
 800085a:	d504      	bpl.n	8000866 <Vector108+0x36>
      (pwmp->config->channels[1].callback != NULL))
 800085c:	686b      	ldr	r3, [r5, #4]
 800085e:	699b      	ldr	r3, [r3, #24]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8000860:	b10b      	cbz	r3, 8000866 <Vector108+0x36>
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
 8000862:	480e      	ldr	r0, [pc, #56]	; (800089c <Vector108+0x6c>)
 8000864:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8000866:	0721      	lsls	r1, r4, #28
 8000868:	d504      	bpl.n	8000874 <Vector108+0x44>
      (pwmp->config->channels[2].callback != NULL))
 800086a:	686b      	ldr	r3, [r5, #4]
 800086c:	6a1b      	ldr	r3, [r3, #32]
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800086e:	b10b      	cbz	r3, 8000874 <Vector108+0x44>
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
 8000870:	480a      	ldr	r0, [pc, #40]	; (800089c <Vector108+0x6c>)
 8000872:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8000874:	06e2      	lsls	r2, r4, #27
 8000876:	d504      	bpl.n	8000882 <Vector108+0x52>
      (pwmp->config->channels[3].callback != NULL))
 8000878:	686b      	ldr	r3, [r5, #4]
 800087a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800087c:	b10b      	cbz	r3, 8000882 <Vector108+0x52>
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
 800087e:	4807      	ldr	r0, [pc, #28]	; (800089c <Vector108+0x6c>)
 8000880:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8000882:	07e3      	lsls	r3, r4, #31
 8000884:	d504      	bpl.n	8000890 <Vector108+0x60>
 8000886:	686b      	ldr	r3, [r5, #4]
 8000888:	689b      	ldr	r3, [r3, #8]
 800088a:	b10b      	cbz	r3, 8000890 <Vector108+0x60>
    pwmp->config->callback(pwmp);
 800088c:	4803      	ldr	r0, [pc, #12]	; (800089c <Vector108+0x6c>)
 800088e:	4798      	blx	r3

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD5);

  OSAL_IRQ_EPILOGUE();
 8000890:	f002 fd9e 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000894:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD5);

  OSAL_IRQ_EPILOGUE();
 8000898:	f000 bd62 	b.w	8001360 <_port_irq_epilogue>
 800089c:	20000de4 	.word	0x20000de4

080008a0 <can_lld_sce_handler>:
 */
static void can_lld_sce_handler(CANDriver *canp) {
  uint32_t msr;

  /* Clearing IRQ sources.*/
  msr = canp->can->MSR;
 80008a0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_sce_handler(CANDriver *canp) {
 80008a2:	b570      	push	{r4, r5, r6, lr}
  uint32_t msr;

  /* Clearing IRQ sources.*/
  msr = canp->can->MSR;
 80008a4:	685c      	ldr	r4, [r3, #4]
  canp->can->MSR = msr;
 80008a6:	605c      	str	r4, [r3, #4]

  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
 80008a8:	0722      	lsls	r2, r4, #28
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_sce_handler(CANDriver *canp) {
 80008aa:	4605      	mov	r5, r0
  msr = canp->can->MSR;
  canp->can->MSR = msr;

  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
 80008ac:	d417      	bmi.n	80008de <can_lld_sce_handler+0x3e>
    osalEventBroadcastFlagsI(&canp->wakeup_event, 0);
    osalSysUnlockFromISR();
  }
#endif /* CAN_USE_SLEEP_MODE */
  /* Error event.*/
  if (msr & CAN_MSR_ERRI) {
 80008ae:	0763      	lsls	r3, r4, #29
 80008b0:	d514      	bpl.n	80008dc <can_lld_sce_handler+0x3c>
    eventflags_t flags;
    uint32_t esr = canp->can->ESR;
 80008b2:	6aea      	ldr	r2, [r5, #44]	; 0x2c

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80008b4:	2320      	movs	r3, #32
 80008b6:	6994      	ldr	r4, [r2, #24]
 80008b8:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 80008bc:	f002 fba8 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 80008c0:	f002 fdce 	bl	8003460 <_dbg_check_lock_from_isr>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80008c4:	f105 0020 	add.w	r0, r5, #32
 80008c8:	0421      	lsls	r1, r4, #16
 80008ca:	f001 f801 	bl	80018d0 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80008ce:	f002 fdaf 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80008d2:	f002 fb85 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 80008d6:	2300      	movs	r3, #0
 80008d8:	f383 8811 	msr	BASEPRI, r3
 80008dc:	bd70      	pop	{r4, r5, r6, pc}

  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
    canp->state = CAN_READY;
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 80008de:	681a      	ldr	r2, [r3, #0]
  canp->can->MSR = msr;

  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
    canp->state = CAN_READY;
 80008e0:	4606      	mov	r6, r0
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 80008e2:	f022 0202 	bic.w	r2, r2, #2
  canp->can->MSR = msr;

  /* Wakeup event.*/
#if CAN_USE_SLEEP_MODE
  if (msr & CAN_MSR_WKUI) {
    canp->state = CAN_READY;
 80008e6:	2103      	movs	r1, #3
 80008e8:	f806 1b28 	strb.w	r1, [r6], #40
 80008ec:	2120      	movs	r1, #32
    canp->can->MCR &= ~CAN_MCR_SLEEP;
 80008ee:	601a      	str	r2, [r3, #0]
 80008f0:	f381 8811 	msr	BASEPRI, r1
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 80008f4:	f002 fb8c 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 80008f8:	f002 fdb2 	bl	8003460 <_dbg_check_lock_from_isr>
 80008fc:	4630      	mov	r0, r6
 80008fe:	2100      	movs	r1, #0
 8000900:	f000 ffe6 	bl	80018d0 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000904:	f002 fd94 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8000908:	f002 fb6a 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 800090c:	2300      	movs	r3, #0
 800090e:	f383 8811 	msr	BASEPRI, r3
 8000912:	e7cc      	b.n	80008ae <can_lld_sce_handler+0xe>
	...

08000920 <Vector148>:
/**
 * @brief   CAN2 SCE interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN2_SCE_HANDLER) {
 8000920:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000922:	f002 fb25 	bl	8002f70 <_stats_increase_irq>
 8000926:	f002 fd6b 	bl	8003400 <_dbg_check_enter_isr>

  can_lld_sce_handler(&CAND2);
 800092a:	4804      	ldr	r0, [pc, #16]	; (800093c <Vector148+0x1c>)
 800092c:	f7ff ffb8 	bl	80008a0 <can_lld_sce_handler>

  OSAL_IRQ_EPILOGUE();
 8000930:	f002 fd4e 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000934:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_sce_handler(&CAND2);

  OSAL_IRQ_EPILOGUE();
 8000938:	f000 bd12 	b.w	8001360 <_port_irq_epilogue>
 800093c:	20000db4 	.word	0x20000db4

08000940 <Vector98>:
/**
 * @brief   CAN1 SCE interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_SCE_HANDLER) {
 8000940:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000942:	f002 fb15 	bl	8002f70 <_stats_increase_irq>
 8000946:	f002 fd5b 	bl	8003400 <_dbg_check_enter_isr>

  can_lld_sce_handler(&CAND1);
 800094a:	4804      	ldr	r0, [pc, #16]	; (800095c <Vector98+0x1c>)
 800094c:	f7ff ffa8 	bl	80008a0 <can_lld_sce_handler>

  OSAL_IRQ_EPILOGUE();
 8000950:	f002 fd3e 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000954:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_sce_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 8000958:	f000 bd02 	b.w	8001360 <_port_irq_epilogue>
 800095c:	20000d84 	.word	0x20000d84

08000960 <VectorDC>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 8000960:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8000964:	4c8d      	ldr	r4, [pc, #564]	; (8000b9c <VectorDC+0x23c>)
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8000966:	f002 fb03 	bl	8002f70 <_stats_increase_irq>
 800096a:	f002 fd49 	bl	8003400 <_dbg_check_enter_isr>
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 800096e:	6f66      	ldr	r6, [r4, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8000970:	68f7      	ldr	r7, [r6, #12]
  uint16_t sr = u->SR;
 8000972:	6833      	ldr	r3, [r6, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8000974:	05da      	lsls	r2, r3, #23
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 8000976:	b29d      	uxth	r5, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8000978:	d515      	bpl.n	80009a6 <VectorDC+0x46>
 800097a:	2320      	movs	r3, #32
 800097c:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8000980:	f002 fb46 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8000984:	f002 fd6c 	bl	8003460 <_dbg_check_lock_from_isr>
 8000988:	1d20      	adds	r0, r4, #4
 800098a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800098e:	f000 ff9f 	bl	80018d0 <chEvtBroadcastFlagsI>
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 8000992:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8000996:	6033      	str	r3, [r6, #0]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000998:	f002 fd4a 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 800099c:	f002 fb20 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 80009a0:	2300      	movs	r3, #0
 80009a2:	f383 8811 	msr	BASEPRI, r3
 80009a6:	2320      	movs	r3, #32
 80009a8:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 80009ac:	f002 fb30 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 80009b0:	f002 fd56 	bl	8003460 <_dbg_check_lock_from_isr>
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80009b4:	f015 0f2f 	tst.w	r5, #47	; 0x2f
 80009b8:	d00e      	beq.n	80009d8 <VectorDC+0x78>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 80009ba:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 8000b9c <VectorDC+0x23c>
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 80009be:	f108 090c 	add.w	r9, r8, #12
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 80009c2:	072b      	lsls	r3, r5, #28
 80009c4:	d14f      	bne.n	8000a66 <VectorDC+0x106>
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 80009c6:	06a8      	lsls	r0, r5, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 80009c8:	f8d6 a004 	ldr.w	sl, [r6, #4]
    if (sr & USART_SR_RXNE)
 80009cc:	d418      	bmi.n	8000a00 <VectorDC+0xa0>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 80009ce:	6835      	ldr	r5, [r6, #0]
 80009d0:	b2ad      	uxth	r5, r5
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80009d2:	f015 0f2f 	tst.w	r5, #47	; 0x2f
 80009d6:	d1f4      	bne.n	80009c2 <VectorDC+0x62>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80009d8:	f002 fd2a 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80009dc:	f002 fb00 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 80009e0:	2300      	movs	r3, #0
 80009e2:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 80009e6:	0639      	lsls	r1, r7, #24
 80009e8:	d501      	bpl.n	80009ee <VectorDC+0x8e>
 80009ea:	062a      	lsls	r2, r5, #24
 80009ec:	d455      	bmi.n	8000a9a <VectorDC+0x13a>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 80009ee:	066b      	lsls	r3, r5, #25
 80009f0:	f100 8092 	bmi.w	8000b18 <VectorDC+0x1b8>

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);

  OSAL_IRQ_EPILOGUE();
 80009f4:	f002 fcec 	bl	80033d0 <_dbg_check_leave_isr>
}
 80009f8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);

  OSAL_IRQ_EPILOGUE();
 80009fc:	f000 bcb0 	b.w	8001360 <_port_irq_epilogue>
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
 8000a00:	f002 fb9e 	bl	8003140 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8000a04:	f002 fb9c 	bl	8003140 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8000a08:	6963      	ldr	r3, [r4, #20]
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8000a0a:	b91b      	cbnz	r3, 8000a14 <VectorDC+0xb4>
 8000a0c:	4864      	ldr	r0, [pc, #400]	; (8000ba0 <VectorDC+0x240>)
 8000a0e:	2104      	movs	r1, #4
 8000a10:	f000 ff5e 	bl	80018d0 <chEvtBroadcastFlagsI>
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();
 8000a14:	f002 fb94 	bl	8003140 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8000a18:	f002 fb92 	bl	8003140 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8000a1c:	6a23      	ldr	r3, [r4, #32]
 8000a1e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000a20:	4293      	cmp	r3, r2
 8000a22:	f000 80a9 	beq.w	8000b78 <VectorDC+0x218>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8000a26:	6962      	ldr	r2, [r4, #20]
  *iqp->q_wrptr++ = b;
 8000a28:	1c59      	adds	r1, r3, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8000a2a:	3201      	adds	r2, #1
 8000a2c:	6162      	str	r2, [r4, #20]
  *iqp->q_wrptr++ = b;
 8000a2e:	6221      	str	r1, [r4, #32]
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8000a30:	f883 a000 	strb.w	sl, [r3]
  if (iqp->q_wrptr >= iqp->q_top) {
 8000a34:	6a22      	ldr	r2, [r4, #32]
 8000a36:	69e3      	ldr	r3, [r4, #28]
 8000a38:	429a      	cmp	r2, r3
 8000a3a:	d303      	bcc.n	8000a44 <VectorDC+0xe4>
    iqp->q_wrptr = iqp->q_buffer;
 8000a3c:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8000a40:	f8c8 3020 	str.w	r3, [r8, #32]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000a44:	68e0      	ldr	r0, [r4, #12]
 8000a46:	4548      	cmp	r0, r9
 8000a48:	d0c1      	beq.n	80009ce <VectorDC+0x6e>

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 8000a4a:	f890 2020 	ldrb.w	r2, [r0, #32]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000a4e:	6803      	ldr	r3, [r0, #0]
 8000a50:	f8c8 300c 	str.w	r3, [r8, #12]
 8000a54:	2a04      	cmp	r2, #4
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000a56:	f8c3 9004 	str.w	r9, [r3, #4]
 8000a5a:	d019      	beq.n	8000a90 <VectorDC+0x130>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a5c:	b672      	cpsid	i
 8000a5e:	4b51      	ldr	r3, [pc, #324]	; (8000ba4 <VectorDC+0x244>)
 8000a60:	4a51      	ldr	r2, [pc, #324]	; (8000ba8 <VectorDC+0x248>)
 8000a62:	62da      	str	r2, [r3, #44]	; 0x2c
 8000a64:	e7fe      	b.n	8000a64 <VectorDC+0x104>
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
 8000a66:	f015 0f08 	tst.w	r5, #8
 8000a6a:	bf0c      	ite	eq
 8000a6c:	2100      	moveq	r1, #0
 8000a6e:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 8000a70:	07e8      	lsls	r0, r5, #31
    sts |= SD_PARITY_ERROR;
 8000a72:	bf48      	it	mi
 8000a74:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8000a78:	07aa      	lsls	r2, r5, #30
    sts |= SD_FRAMING_ERROR;
 8000a7a:	bf48      	it	mi
 8000a7c:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8000a80:	076b      	lsls	r3, r5, #29
    sts |= SD_NOISE_ERROR;
 8000a82:	bf48      	it	mi
 8000a84:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 8000a88:	4845      	ldr	r0, [pc, #276]	; (8000ba0 <VectorDC+0x240>)
 8000a8a:	f000 ff21 	bl	80018d0 <chEvtBroadcastFlagsI>
 8000a8e:	e79a      	b.n	80009c6 <VectorDC+0x66>

  tp->p_u.rdymsg = msg;
 8000a90:	2300      	movs	r3, #0
 8000a92:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000a94:	f002 fc34 	bl	8003300 <chSchReadyI>
 8000a98:	e799      	b.n	80009ce <VectorDC+0x6e>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000a9a:	2320      	movs	r3, #32
 8000a9c:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8000aa0:	f002 fab6 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8000aa4:	f002 fcdc 	bl	8003460 <_dbg_check_lock_from_isr>
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
  uint8_t b;

  chDbgCheckClassI();
 8000aa8:	f002 fb4a 	bl	8003140 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8000aac:	f002 fb48 	bl	8003140 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000ab0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000ab2:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8000ab4:	4839      	ldr	r0, [pc, #228]	; (8000b9c <VectorDC+0x23c>)
 8000ab6:	429a      	cmp	r2, r3
 8000ab8:	d050      	beq.n	8000b5c <VectorDC+0x1fc>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000aba:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000abc:	4937      	ldr	r1, [pc, #220]	; (8000b9c <VectorDC+0x23c>)
  b = *oqp->q_rdptr++;
 8000abe:	1c58      	adds	r0, r3, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000ac0:	3201      	adds	r2, #1
 8000ac2:	63a2      	str	r2, [r4, #56]	; 0x38
  b = *oqp->q_rdptr++;
 8000ac4:	64a0      	str	r0, [r4, #72]	; 0x48
 8000ac6:	f893 8000 	ldrb.w	r8, [r3]
  if (oqp->q_rdptr >= oqp->q_top) {
 8000aca:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8000acc:	4298      	cmp	r0, r3
 8000ace:	d301      	bcc.n	8000ad4 <VectorDC+0x174>
    oqp->q_rdptr = oqp->q_buffer;
 8000ad0:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8000ad2:	648b      	str	r3, [r1, #72]	; 0x48
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000ad4:	4a31      	ldr	r2, [pc, #196]	; (8000b9c <VectorDC+0x23c>)
 8000ad6:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8000ad8:	f102 0330 	add.w	r3, r2, #48	; 0x30
 8000adc:	4298      	cmp	r0, r3
 8000ade:	d00f      	beq.n	8000b00 <VectorDC+0x1a0>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000ae0:	6801      	ldr	r1, [r0, #0]
 8000ae2:	6311      	str	r1, [r2, #48]	; 0x30

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 8000ae4:	f890 2020 	ldrb.w	r2, [r0, #32]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000ae8:	604b      	str	r3, [r1, #4]
 8000aea:	2a04      	cmp	r2, #4
 8000aec:	d004      	beq.n	8000af8 <VectorDC+0x198>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000aee:	b672      	cpsid	i
 8000af0:	4b2c      	ldr	r3, [pc, #176]	; (8000ba4 <VectorDC+0x244>)
 8000af2:	4a2d      	ldr	r2, [pc, #180]	; (8000ba8 <VectorDC+0x248>)
 8000af4:	62da      	str	r2, [r3, #44]	; 0x2c
 8000af6:	e7fe      	b.n	8000af6 <VectorDC+0x196>

  tp->p_u.rdymsg = msg;
 8000af8:	2300      	movs	r3, #0
 8000afa:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000afc:	f002 fc00 	bl	8003300 <chSchReadyI>
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 8000b00:	f8c6 8004 	str.w	r8, [r6, #4]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000b04:	f002 fc94 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8000b08:	f002 fa6a 	bl	8002fe0 <_stats_stop_measure_crit_isr>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000b0c:	2300      	movs	r3, #0
 8000b0e:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8000b12:	066b      	lsls	r3, r5, #25
 8000b14:	f57f af6e 	bpl.w	80009f4 <VectorDC+0x94>
 8000b18:	2320      	movs	r3, #32
 8000b1a:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8000b1e:	f002 fa77 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8000b22:	f002 fc9d 	bl	8003460 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8000b26:	f002 fb0b 	bl	8003140 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000b2a:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8000b2c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000b2e:	481b      	ldr	r0, [pc, #108]	; (8000b9c <VectorDC+0x23c>)
 8000b30:	429a      	cmp	r2, r3
 8000b32:	d02b      	beq.n	8000b8c <VectorDC+0x22c>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000b34:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 8000b38:	403b      	ands	r3, r7
    u->SR = ~USART_SR_TC;
 8000b3a:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000b3e:	60f3      	str	r3, [r6, #12]
    u->SR = ~USART_SR_TC;
 8000b40:	6032      	str	r2, [r6, #0]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000b42:	f002 fc75 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8000b46:	f002 fa4b 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 8000b4a:	2300      	movs	r3, #0
 8000b4c:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);

  OSAL_IRQ_EPILOGUE();
 8000b50:	f002 fc3e 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000b54:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);

  OSAL_IRQ_EPILOGUE();
 8000b58:	f000 bc02 	b.w	8001360 <_port_irq_epilogue>
 8000b5c:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8000b5e:	2a00      	cmp	r2, #0
 8000b60:	d0ab      	beq.n	8000aba <VectorDC+0x15a>
 8000b62:	3004      	adds	r0, #4
 8000b64:	2108      	movs	r1, #8
 8000b66:	f000 feb3 	bl	80018d0 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8000b6a:	f64f 733f 	movw	r3, #65343	; 0xff3f
 8000b6e:	403b      	ands	r3, r7
 8000b70:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000b74:	60f3      	str	r3, [r6, #12]
 8000b76:	e7c5      	b.n	8000b04 <VectorDC+0x1a4>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8000b78:	f8d8 2014 	ldr.w	r2, [r8, #20]
 8000b7c:	2a00      	cmp	r2, #0
 8000b7e:	f43f af52 	beq.w	8000a26 <VectorDC+0xc6>
 8000b82:	4807      	ldr	r0, [pc, #28]	; (8000ba0 <VectorDC+0x240>)
 8000b84:	2180      	movs	r1, #128	; 0x80
 8000b86:	f000 fea3 	bl	80018d0 <chEvtBroadcastFlagsI>
 8000b8a:	e720      	b.n	80009ce <VectorDC+0x6e>
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000b8c:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8000b8e:	2b00      	cmp	r3, #0
 8000b90:	d0d0      	beq.n	8000b34 <VectorDC+0x1d4>
 8000b92:	3004      	adds	r0, #4
 8000b94:	2110      	movs	r1, #16
 8000b96:	f000 fe9b 	bl	80018d0 <chEvtBroadcastFlagsI>
 8000b9a:	e7cb      	b.n	8000b34 <VectorDC+0x1d4>
 8000b9c:	200021c4 	.word	0x200021c4
 8000ba0:	200021c8 	.word	0x200021c8
 8000ba4:	20002740 	.word	0x20002740
 8000ba8:	08006b80 	.word	0x08006b80
 8000bac:	00000000 	.word	0x00000000

08000bb0 <spi_lld_serve_rx_interrupt.lto_priv.67>:
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000bb0:	f011 0f0c 	tst.w	r1, #12
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 8000bb4:	b538      	push	{r3, r4, r5, lr}

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000bb6:	d13a      	bne.n	8000c2e <spi_lld_serve_rx_interrupt.lto_priv.67+0x7e>
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 8000bb8:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8000bba:	680b      	ldr	r3, [r1, #0]
 8000bbc:	681a      	ldr	r2, [r3, #0]
 8000bbe:	f022 021f 	bic.w	r2, r2, #31
 8000bc2:	601a      	str	r2, [r3, #0]
 8000bc4:	681a      	ldr	r2, [r3, #0]
 8000bc6:	07d4      	lsls	r4, r2, #31
 8000bc8:	d4fc      	bmi.n	8000bc4 <spi_lld_serve_rx_interrupt.lto_priv.67+0x14>
 8000bca:	7a0d      	ldrb	r5, [r1, #8]
  dmaStreamDisable(spip->dmarx);
 8000bcc:	6a02      	ldr	r2, [r0, #32]
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 8000bce:	684c      	ldr	r4, [r1, #4]
  dmaStreamDisable(spip->dmarx);
 8000bd0:	6813      	ldr	r3, [r2, #0]
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 8000bd2:	213d      	movs	r1, #61	; 0x3d
 8000bd4:	40a9      	lsls	r1, r5
 8000bd6:	6021      	str	r1, [r4, #0]
  dmaStreamDisable(spip->dmarx);
 8000bd8:	6819      	ldr	r1, [r3, #0]
 8000bda:	f021 011f 	bic.w	r1, r1, #31
 8000bde:	6019      	str	r1, [r3, #0]
 8000be0:	6819      	ldr	r1, [r3, #0]
 8000be2:	07c9      	lsls	r1, r1, #31
 8000be4:	d4fc      	bmi.n	8000be0 <spi_lld_serve_rx_interrupt.lto_priv.67+0x30>

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 8000be6:	6843      	ldr	r3, [r0, #4]
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
  dmaStreamDisable(spip->dmarx);
 8000be8:	6851      	ldr	r1, [r2, #4]
 8000bea:	4604      	mov	r4, r0
 8000bec:	7a10      	ldrb	r0, [r2, #8]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 8000bee:	681a      	ldr	r2, [r3, #0]
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
  dmaStreamDisable(spip->dmarx);
 8000bf0:	233d      	movs	r3, #61	; 0x3d
 8000bf2:	4083      	lsls	r3, r0
 8000bf4:	600b      	str	r3, [r1, #0]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 8000bf6:	b1fa      	cbz	r2, 8000c38 <spi_lld_serve_rx_interrupt.lto_priv.67+0x88>
 8000bf8:	2304      	movs	r3, #4
 8000bfa:	7023      	strb	r3, [r4, #0]
 8000bfc:	4620      	mov	r0, r4
 8000bfe:	4790      	blx	r2
 8000c00:	7823      	ldrb	r3, [r4, #0]
 8000c02:	2b04      	cmp	r3, #4
 8000c04:	d018      	beq.n	8000c38 <spi_lld_serve_rx_interrupt.lto_priv.67+0x88>
 8000c06:	2320      	movs	r3, #32
 8000c08:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8000c0c:	f002 fa00 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8000c10:	f002 fc26 	bl	8003460 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 8000c14:	f104 0008 	add.w	r0, r4, #8
 8000c18:	2100      	movs	r1, #0
 8000c1a:	f002 fb99 	bl	8003350 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000c1e:	f002 fc07 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8000c22:	f002 f9dd 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 8000c26:	2300      	movs	r3, #0
 8000c28:	f383 8811 	msr	BASEPRI, r3
 8000c2c:	bd38      	pop	{r3, r4, r5, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c2e:	b672      	cpsid	i
 8000c30:	4b03      	ldr	r3, [pc, #12]	; (8000c40 <spi_lld_serve_rx_interrupt.lto_priv.67+0x90>)
 8000c32:	4a04      	ldr	r2, [pc, #16]	; (8000c44 <spi_lld_serve_rx_interrupt.lto_priv.67+0x94>)
 8000c34:	62da      	str	r2, [r3, #44]	; 0x2c
 8000c36:	e7fe      	b.n	8000c36 <spi_lld_serve_rx_interrupt.lto_priv.67+0x86>
 8000c38:	2302      	movs	r3, #2
 8000c3a:	7023      	strb	r3, [r4, #0]
 8000c3c:	e7e3      	b.n	8000c06 <spi_lld_serve_rx_interrupt.lto_priv.67+0x56>
 8000c3e:	bf00      	nop
 8000c40:	20002740 	.word	0x20002740
 8000c44:	08005470 	.word	0x08005470
	...

08000c50 <i2c_lld_serve_error_interrupt>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in]  sr       content of the SR1 register to be decoded
 *
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {
 8000c50:	b570      	push	{r4, r5, r6, lr}

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8000c52:	6b05      	ldr	r5, [r0, #48]	; 0x30
 8000c54:	682a      	ldr	r2, [r5, #0]
 8000c56:	6813      	ldr	r3, [r2, #0]
 8000c58:	f023 031f 	bic.w	r3, r3, #31
 8000c5c:	6013      	str	r3, [r2, #0]
 8000c5e:	6813      	ldr	r3, [r2, #0]
 8000c60:	07de      	lsls	r6, r3, #31
 8000c62:	d4fc      	bmi.n	8000c5e <i2c_lld_serve_error_interrupt+0xe>
 8000c64:	7a2e      	ldrb	r6, [r5, #8]
  dmaStreamDisable(i2cp->dmarx);
 8000c66:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8000c68:	686d      	ldr	r5, [r5, #4]
  dmaStreamDisable(i2cp->dmarx);
 8000c6a:	6822      	ldr	r2, [r4, #0]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8000c6c:	233d      	movs	r3, #61	; 0x3d
 8000c6e:	40b3      	lsls	r3, r6
 8000c70:	602b      	str	r3, [r5, #0]
  dmaStreamDisable(i2cp->dmarx);
 8000c72:	6813      	ldr	r3, [r2, #0]
 8000c74:	f023 031f 	bic.w	r3, r3, #31
 8000c78:	6013      	str	r3, [r2, #0]
 8000c7a:	6813      	ldr	r3, [r2, #0]
 8000c7c:	f013 0301 	ands.w	r3, r3, #1
 8000c80:	d1fb      	bne.n	8000c7a <i2c_lld_serve_error_interrupt+0x2a>
 8000c82:	7a25      	ldrb	r5, [r4, #8]
 8000c84:	6864      	ldr	r4, [r4, #4]
 8000c86:	223d      	movs	r2, #61	; 0x3d
 8000c88:	40aa      	lsls	r2, r5

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8000c8a:	05cd      	lsls	r5, r1, #23
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);
 8000c8c:	6022      	str	r2, [r4, #0]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 8000c8e:	bf48      	it	mi
 8000c90:	2301      	movmi	r3, #1

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 8000c92:	058c      	lsls	r4, r1, #22
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 8000c94:	6083      	str	r3, [r0, #8]

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8000c96:	bf44      	itt	mi
 8000c98:	f043 0302 	orrmi.w	r3, r3, #2
 8000c9c:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 8000c9e:	054a      	lsls	r2, r1, #21
 8000ca0:	d50b      	bpl.n	8000cba <i2c_lld_serve_error_interrupt+0x6a>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8000ca2:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8000ca4:	6854      	ldr	r4, [r2, #4]
 8000ca6:	f424 7400 	bic.w	r4, r4, #512	; 0x200
 8000caa:	6054      	str	r4, [r2, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8000cac:	6814      	ldr	r4, [r2, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8000cae:	f043 0304 	orr.w	r3, r3, #4
  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8000cb2:	f444 7400 	orr.w	r4, r4, #512	; 0x200
 8000cb6:	6014      	str	r4, [r2, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8000cb8:	6083      	str	r3, [r0, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 8000cba:	050e      	lsls	r6, r1, #20
    i2cp->errors |= I2C_OVERRUN;
 8000cbc:	bf44      	itt	mi
 8000cbe:	f043 0308 	orrmi.w	r3, r3, #8
 8000cc2:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 8000cc4:	044d      	lsls	r5, r1, #17
    i2cp->errors |= I2C_TIMEOUT;
 8000cc6:	bf44      	itt	mi
 8000cc8:	f043 0320 	orrmi.w	r3, r3, #32
 8000ccc:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 8000cce:	04cc      	lsls	r4, r1, #19
 8000cd0:	d51a      	bpl.n	8000d08 <i2c_lld_serve_error_interrupt+0xb8>
    i2cp->errors |= I2C_PEC_ERROR;
 8000cd2:	f043 0310 	orr.w	r3, r3, #16

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8000cd6:	0409      	lsls	r1, r1, #16

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;
 8000cd8:	6083      	str	r3, [r0, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8000cda:	d41a      	bmi.n	8000d12 <i2c_lld_serve_error_interrupt+0xc2>
 8000cdc:	4604      	mov	r4, r0

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000cde:	2320      	movs	r3, #32
 8000ce0:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8000ce4:	f002 f994 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8000ce8:	f002 fbba 	bl	8003460 <_dbg_check_lock_from_isr>
 8000cec:	f104 001c 	add.w	r0, r4, #28
 8000cf0:	f06f 0101 	mvn.w	r1, #1
 8000cf4:	f002 fb2c 	bl	8003350 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000cf8:	f002 fb9a 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8000cfc:	f002 f970 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 8000d00:	2300      	movs	r3, #0
 8000d02:	f383 8811 	msr	BASEPRI, r3
 8000d06:	bd70      	pop	{r4, r5, r6, pc}
 8000d08:	040a      	lsls	r2, r1, #16
 8000d0a:	d402      	bmi.n	8000d12 <i2c_lld_serve_error_interrupt+0xc2>
    i2cp->errors |= I2C_SMB_ALERT;

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 8000d0c:	2b00      	cmp	r3, #0
 8000d0e:	d1e5      	bne.n	8000cdc <i2c_lld_serve_error_interrupt+0x8c>
 8000d10:	bd70      	pop	{r4, r5, r6, pc}

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
    i2cp->errors |= I2C_SMB_ALERT;
 8000d12:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000d16:	6083      	str	r3, [r0, #8]
 8000d18:	e7e0      	b.n	8000cdc <i2c_lld_serve_error_interrupt+0x8c>
 8000d1a:	bf00      	nop
 8000d1c:	0000      	movs	r0, r0
	...

08000d20 <VectorC8>:
/**
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
 8000d20:	b538      	push	{r3, r4, r5, lr}
  uint16_t sr = I2CD2.i2c->SR1;
 8000d22:	4d0b      	ldr	r5, [pc, #44]	; (8000d50 <VectorC8+0x30>)
 8000d24:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000d26:	695c      	ldr	r4, [r3, #20]

  OSAL_IRQ_PROLOGUE();
 8000d28:	f002 f922 	bl	8002f70 <_stats_increase_irq>
 8000d2c:	f002 fb68 	bl	8003400 <_dbg_check_enter_isr>
 8000d30:	b2a1      	uxth	r1, r4

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8000d32:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8000d34:	f401 435f 	and.w	r3, r1, #57088	; 0xdf00
 8000d38:	43db      	mvns	r3, r3
 8000d3a:	6153      	str	r3, [r2, #20]
  i2c_lld_serve_error_interrupt(&I2CD2, sr);
 8000d3c:	4628      	mov	r0, r5
 8000d3e:	f7ff ff87 	bl	8000c50 <i2c_lld_serve_error_interrupt>

  OSAL_IRQ_EPILOGUE();
 8000d42:	f002 fb45 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000d46:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
 8000d4a:	f000 bb09 	b.w	8001360 <_port_irq_epilogue>
 8000d4e:	bf00      	nop
 8000d50:	20001fc8 	.word	0x20001fc8
	...

08000d60 <VectorC0>:
}

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 8000d60:	b538      	push	{r3, r4, r5, lr}
  uint16_t sr = I2CD1.i2c->SR1;
 8000d62:	4d0b      	ldr	r5, [pc, #44]	; (8000d90 <VectorC0+0x30>)
 8000d64:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000d66:	695c      	ldr	r4, [r3, #20]

  OSAL_IRQ_PROLOGUE();
 8000d68:	f002 f902 	bl	8002f70 <_stats_increase_irq>
 8000d6c:	f002 fb48 	bl	8003400 <_dbg_check_enter_isr>
 8000d70:	b2a1      	uxth	r1, r4

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8000d72:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8000d74:	f401 435f 	and.w	r3, r1, #57088	; 0xdf00
 8000d78:	43db      	mvns	r3, r3
 8000d7a:	6153      	str	r3, [r2, #20]
  i2c_lld_serve_error_interrupt(&I2CD1, sr);
 8000d7c:	4628      	mov	r0, r5
 8000d7e:	f7ff ff67 	bl	8000c50 <i2c_lld_serve_error_interrupt>

  OSAL_IRQ_EPILOGUE();
 8000d82:	f002 fb25 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000d86:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 8000d8a:	f000 bae9 	b.w	8001360 <_port_irq_epilogue>
 8000d8e:	bf00      	nop
 8000d90:	20001f90 	.word	0x20001f90
	...

08000da0 <i2c_lld_serve_event_interrupt>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
 8000da0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 8000da2:	6b44      	ldr	r4, [r0, #52]	; 0x34
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8000da4:	4a3f      	ldr	r2, [pc, #252]	; (8000ea4 <i2c_lld_serve_event_interrupt+0x104>)
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t regSR2 = dp->SR2;
 8000da6:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 8000da8:	6966      	ldr	r6, [r4, #20]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8000daa:	ea46 4303 	orr.w	r3, r6, r3, lsl #16
 8000dae:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000db2:	4293      	cmp	r3, r2
 8000db4:	d04b      	beq.n	8000e4e <i2c_lld_serve_event_interrupt+0xae>
 8000db6:	d81b      	bhi.n	8000df0 <i2c_lld_serve_event_interrupt+0x50>
 8000db8:	3a07      	subs	r2, #7
 8000dba:	4293      	cmp	r3, r2
 8000dbc:	d03b      	beq.n	8000e36 <i2c_lld_serve_event_interrupt+0x96>
 8000dbe:	3201      	adds	r2, #1
 8000dc0:	4293      	cmp	r3, r2
 8000dc2:	d110      	bne.n	8000de6 <i2c_lld_serve_event_interrupt+0x46>
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8000dc4:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 8000dc6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8000dc8:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 8000dcc:	681b      	ldr	r3, [r3, #0]
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8000dce:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 8000dd0:	681a      	ldr	r2, [r3, #0]
 8000dd2:	f042 0201 	orr.w	r2, r2, #1
 8000dd6:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 8000dd8:	6862      	ldr	r2, [r4, #4]
 8000dda:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8000dde:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 8000de0:	685b      	ldr	r3, [r3, #4]
 8000de2:	2b01      	cmp	r3, #1
 8000de4:	d958      	bls.n	8000e98 <i2c_lld_serve_event_interrupt+0xf8>
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8000de6:	f016 0f0a 	tst.w	r6, #10
    (void)dp->SR2;
 8000dea:	bf18      	it	ne
 8000dec:	69a3      	ldrne	r3, [r4, #24]
 8000dee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8000df0:	4a2d      	ldr	r2, [pc, #180]	; (8000ea8 <i2c_lld_serve_event_interrupt+0x108>)
 8000df2:	4293      	cmp	r3, r2
 8000df4:	d010      	beq.n	8000e18 <i2c_lld_serve_event_interrupt+0x78>
 8000df6:	3202      	adds	r2, #2
 8000df8:	4293      	cmp	r3, r2
 8000dfa:	d1f4      	bne.n	8000de6 <i2c_lld_serve_event_interrupt+0x46>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmatx);
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 8000dfc:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8000dfe:	681b      	ldr	r3, [r3, #0]
 8000e00:	685f      	ldr	r7, [r3, #4]
 8000e02:	2f00      	cmp	r7, #0
 8000e04:	d02c      	beq.n	8000e60 <i2c_lld_serve_event_interrupt+0xc0>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8000e06:	8c02      	ldrh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8000e08:	6823      	ldr	r3, [r4, #0]
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8000e0a:	f042 0201 	orr.w	r2, r2, #1
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8000e0e:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8000e12:	8402      	strh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8000e14:	6023      	str	r3, [r4, #0]
 8000e16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8000e18:	6863      	ldr	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8000e1a:	6b02      	ldr	r2, [r0, #48]	; 0x30
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8000e1c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 8000e20:	6812      	ldr	r2, [r2, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8000e22:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8000e24:	6813      	ldr	r3, [r2, #0]
 8000e26:	f043 0301 	orr.w	r3, r3, #1
 8000e2a:	6013      	str	r3, [r2, #0]
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8000e2c:	f016 0f0a 	tst.w	r6, #10
    (void)dp->SR2;
 8000e30:	bf18      	it	ne
 8000e32:	69a3      	ldrne	r3, [r4, #24]
 8000e34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 8000e36:	8c03      	ldrh	r3, [r0, #32]
 8000e38:	0a1a      	lsrs	r2, r3, #8
 8000e3a:	d00b      	beq.n	8000e54 <i2c_lld_serve_event_interrupt+0xb4>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 8000e3c:	f003 0301 	and.w	r3, r3, #1
 8000e40:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8000e44:	f002 0206 	and.w	r2, r2, #6
 8000e48:	4313      	orrs	r3, r2
 8000e4a:	6123      	str	r3, [r4, #16]
 8000e4c:	e7cb      	b.n	8000de6 <i2c_lld_serve_event_interrupt+0x46>
      dp->DR = i2cp->addr;
    }
    break;
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 8000e4e:	8c03      	ldrh	r3, [r0, #32]
 8000e50:	f3c3 0347 	ubfx	r3, r3, #1, #8
 8000e54:	6123      	str	r3, [r4, #16]
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8000e56:	f016 0f0a 	tst.w	r6, #10
    (void)dp->SR2;
 8000e5a:	bf18      	it	ne
 8000e5c:	69a3      	ldrne	r3, [r4, #24]
 8000e5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
      return;
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8000e60:	6863      	ldr	r3, [r4, #4]
 8000e62:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000e66:	6063      	str	r3, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 8000e68:	6823      	ldr	r3, [r4, #0]
 8000e6a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000e6e:	6023      	str	r3, [r4, #0]
 8000e70:	4605      	mov	r5, r0
 8000e72:	2320      	movs	r3, #32
 8000e74:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8000e78:	f002 f8ca 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8000e7c:	f002 faf0 	bl	8003460 <_dbg_check_lock_from_isr>
 8000e80:	f105 001c 	add.w	r0, r5, #28
 8000e84:	4639      	mov	r1, r7
 8000e86:	f002 fa63 	bl	8003350 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000e8a:	f002 fad1 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8000e8e:	f002 f8a7 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 8000e92:	f387 8811 	msr	BASEPRI, r7
 8000e96:	e7a6      	b.n	8000de6 <i2c_lld_serve_event_interrupt+0x46>
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmarx);
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
 8000e98:	6823      	ldr	r3, [r4, #0]
 8000e9a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000e9e:	6023      	str	r3, [r4, #0]
 8000ea0:	e7a1      	b.n	8000de6 <i2c_lld_serve_event_interrupt+0x46>
 8000ea2:	bf00      	nop
 8000ea4:	00030008 	.word	0x00030008
 8000ea8:	00070082 	.word	0x00070082
 8000eac:	00000000 	.word	0x00000000

08000eb0 <VectorC4>:
/**
 * @brief   I2C2 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_EVENT_HANDLER) {
 8000eb0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000eb2:	f002 f85d 	bl	8002f70 <_stats_increase_irq>
 8000eb6:	f002 faa3 	bl	8003400 <_dbg_check_enter_isr>

  i2c_lld_serve_event_interrupt(&I2CD2);
 8000eba:	4804      	ldr	r0, [pc, #16]	; (8000ecc <VectorC4+0x1c>)
 8000ebc:	f7ff ff70 	bl	8000da0 <i2c_lld_serve_event_interrupt>

  OSAL_IRQ_EPILOGUE();
 8000ec0:	f002 fa86 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000ec4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
 8000ec8:	f000 ba4a 	b.w	8001360 <_port_irq_epilogue>
 8000ecc:	20001fc8 	.word	0x20001fc8

08000ed0 <VectorBC>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 8000ed0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000ed2:	f002 f84d 	bl	8002f70 <_stats_increase_irq>
 8000ed6:	f002 fa93 	bl	8003400 <_dbg_check_enter_isr>

  i2c_lld_serve_event_interrupt(&I2CD1);
 8000eda:	4804      	ldr	r0, [pc, #16]	; (8000eec <VectorBC+0x1c>)
 8000edc:	f7ff ff60 	bl	8000da0 <i2c_lld_serve_event_interrupt>

  OSAL_IRQ_EPILOGUE();
 8000ee0:	f002 fa76 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000ee4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 8000ee8:	f000 ba3a 	b.w	8001360 <_port_irq_epilogue>
 8000eec:	20001f90 	.word	0x20001f90

08000ef0 <Vector144>:
/**
 * @brief   CAN2 RX1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN2_RX1_HANDLER) {
 8000ef0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000ef2:	f002 f83d 	bl	8002f70 <_stats_increase_irq>
 8000ef6:	f002 fa83 	bl	8003400 <_dbg_check_enter_isr>

  can_lld_rx1_handler(&CAND2);
 8000efa:	4804      	ldr	r0, [pc, #16]	; (8000f0c <Vector144+0x1c>)
 8000efc:	f000 fd38 	bl	8001970 <can_lld_rx1_handler.lto_priv.70>

  OSAL_IRQ_EPILOGUE();
 8000f00:	f002 fa66 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000f04:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx1_handler(&CAND2);

  OSAL_IRQ_EPILOGUE();
 8000f08:	f000 ba2a 	b.w	8001360 <_port_irq_epilogue>
 8000f0c:	20000db4 	.word	0x20000db4

08000f10 <Vector94>:
/**
 * @brief   CAN1 RX1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_RX1_HANDLER) {
 8000f10:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000f12:	f002 f82d 	bl	8002f70 <_stats_increase_irq>
 8000f16:	f002 fa73 	bl	8003400 <_dbg_check_enter_isr>

  can_lld_rx1_handler(&CAND1);
 8000f1a:	4804      	ldr	r0, [pc, #16]	; (8000f2c <Vector94+0x1c>)
 8000f1c:	f000 fd28 	bl	8001970 <can_lld_rx1_handler.lto_priv.70>

  OSAL_IRQ_EPILOGUE();
 8000f20:	f002 fa56 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000f24:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx1_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 8000f28:	f000 ba1a 	b.w	8001360 <_port_irq_epilogue>
 8000f2c:	20000d84 	.word	0x20000d84

08000f30 <Vector140>:
/*
 * @brief   CAN2 RX0 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN2_RX0_HANDLER) {
 8000f30:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000f32:	f002 f81d 	bl	8002f70 <_stats_increase_irq>
 8000f36:	f002 fa63 	bl	8003400 <_dbg_check_enter_isr>

  can_lld_rx0_handler(&CAND2);
 8000f3a:	4804      	ldr	r0, [pc, #16]	; (8000f4c <Vector140+0x1c>)
 8000f3c:	f000 fd78 	bl	8001a30 <can_lld_rx0_handler.lto_priv.71>

  OSAL_IRQ_EPILOGUE();
 8000f40:	f002 fa46 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000f44:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx0_handler(&CAND2);

  OSAL_IRQ_EPILOGUE();
 8000f48:	f000 ba0a 	b.w	8001360 <_port_irq_epilogue>
 8000f4c:	20000db4 	.word	0x20000db4

08000f50 <Vector90>:
/*
 * @brief   CAN1 RX0 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_RX0_HANDLER) {
 8000f50:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000f52:	f002 f80d 	bl	8002f70 <_stats_increase_irq>
 8000f56:	f002 fa53 	bl	8003400 <_dbg_check_enter_isr>

  can_lld_rx0_handler(&CAND1);
 8000f5a:	4804      	ldr	r0, [pc, #16]	; (8000f6c <Vector90+0x1c>)
 8000f5c:	f000 fd68 	bl	8001a30 <can_lld_rx0_handler.lto_priv.71>

  OSAL_IRQ_EPILOGUE();
 8000f60:	f002 fa36 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000f64:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx0_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 8000f68:	f000 b9fa 	b.w	8001360 <_port_irq_epilogue>
 8000f6c:	20000d84 	.word	0x20000d84

08000f70 <Vector13C>:
/**
 * @brief   CAN2 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN2_TX_HANDLER) {
 8000f70:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000f72:	f001 fffd 	bl	8002f70 <_stats_increase_irq>
 8000f76:	f002 fa43 	bl	8003400 <_dbg_check_enter_isr>

  can_lld_tx_handler(&CAND2);
 8000f7a:	4804      	ldr	r0, [pc, #16]	; (8000f8c <Vector13C+0x1c>)
 8000f7c:	f000 fd98 	bl	8001ab0 <can_lld_tx_handler.lto_priv.72>

  OSAL_IRQ_EPILOGUE();
 8000f80:	f002 fa26 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000f84:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_tx_handler(&CAND2);

  OSAL_IRQ_EPILOGUE();
 8000f88:	f000 b9ea 	b.w	8001360 <_port_irq_epilogue>
 8000f8c:	20000db4 	.word	0x20000db4

08000f90 <Vector8C>:
/**
 * @brief   CAN1 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_TX_HANDLER) {
 8000f90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000f92:	f001 ffed 	bl	8002f70 <_stats_increase_irq>
 8000f96:	f002 fa33 	bl	8003400 <_dbg_check_enter_isr>

  can_lld_tx_handler(&CAND1);
 8000f9a:	4804      	ldr	r0, [pc, #16]	; (8000fac <Vector8C+0x1c>)
 8000f9c:	f000 fd88 	bl	8001ab0 <can_lld_tx_handler.lto_priv.72>

  OSAL_IRQ_EPILOGUE();
 8000fa0:	f002 fa16 	bl	80033d0 <_dbg_check_leave_isr>
}
 8000fa4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_tx_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 8000fa8:	f000 b9da 	b.w	8001360 <_port_irq_epilogue>
 8000fac:	20000d84 	.word	0x20000d84

08000fb0 <__early_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000fb0:	492c      	ldr	r1, [pc, #176]	; (8001064 <__early_init+0xb4>)

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8000fb2:	4b2d      	ldr	r3, [pc, #180]	; (8001068 <__early_init+0xb8>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000fb4:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8000fb8:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000fbc:	6408      	str	r0, [r1, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8000fbe:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000fc0:	680b      	ldr	r3, [r1, #0]
 8000fc2:	f043 0301 	orr.w	r3, r3, #1
 8000fc6:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8000fc8:	680a      	ldr	r2, [r1, #0]
 8000fca:	4b26      	ldr	r3, [pc, #152]	; (8001064 <__early_init+0xb4>)
 8000fcc:	0790      	lsls	r0, r2, #30
 8000fce:	d5fb      	bpl.n	8000fc8 <__early_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8000fd0:	689a      	ldr	r2, [r3, #8]
 8000fd2:	f022 0203 	bic.w	r2, r2, #3
 8000fd6:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8000fd8:	689a      	ldr	r2, [r3, #8]
 8000fda:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000fdc:	4619      	mov	r1, r3
 8000fde:	688b      	ldr	r3, [r1, #8]
 8000fe0:	4a20      	ldr	r2, [pc, #128]	; (8001064 <__early_init+0xb4>)
 8000fe2:	f013 030c 	ands.w	r3, r3, #12
 8000fe6:	d1fa      	bne.n	8000fde <__early_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8000fe8:	6811      	ldr	r1, [r2, #0]
 8000fea:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 8000fee:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8000ff0:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8000ff2:	6813      	ldr	r3, [r2, #0]
 8000ff4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000ff8:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8000ffa:	6811      	ldr	r1, [r2, #0]
 8000ffc:	4b19      	ldr	r3, [pc, #100]	; (8001064 <__early_init+0xb4>)
 8000ffe:	0389      	lsls	r1, r1, #14
 8001000:	d5fb      	bpl.n	8000ffa <__early_init+0x4a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001002:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8001004:	f042 0201 	orr.w	r2, r2, #1
 8001008:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800100a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800100c:	4915      	ldr	r1, [pc, #84]	; (8001064 <__early_init+0xb4>)
 800100e:	0790      	lsls	r0, r2, #30
 8001010:	d5fb      	bpl.n	800100a <__early_init+0x5a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8001012:	4b16      	ldr	r3, [pc, #88]	; (800106c <__early_init+0xbc>)
 8001014:	604b      	str	r3, [r1, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8001016:	680b      	ldr	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001018:	4a13      	ldr	r2, [pc, #76]	; (8001068 <__early_init+0xb8>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 800101a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800101e:	600b      	str	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001020:	6853      	ldr	r3, [r2, #4]
 8001022:	0459      	lsls	r1, r3, #17
 8001024:	d5fc      	bpl.n	8001020 <__early_init+0x70>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001026:	490f      	ldr	r1, [pc, #60]	; (8001064 <__early_init+0xb4>)
 8001028:	680a      	ldr	r2, [r1, #0]
 800102a:	4b0e      	ldr	r3, [pc, #56]	; (8001064 <__early_init+0xb4>)
 800102c:	0192      	lsls	r2, r2, #6
 800102e:	d5fb      	bpl.n	8001028 <__early_init+0x78>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8001030:	4a0f      	ldr	r2, [pc, #60]	; (8001070 <__early_init+0xc0>)
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8001032:	4910      	ldr	r1, [pc, #64]	; (8001074 <__early_init+0xc4>)
 8001034:	6099      	str	r1, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8001036:	f240 7105 	movw	r1, #1797	; 0x705
 800103a:	6011      	str	r1, [r2, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800103c:	689a      	ldr	r2, [r3, #8]
 800103e:	f042 0202 	orr.w	r2, r2, #2
 8001042:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001044:	461a      	mov	r2, r3
 8001046:	6893      	ldr	r3, [r2, #8]
 8001048:	4906      	ldr	r1, [pc, #24]	; (8001064 <__early_init+0xb4>)
 800104a:	f003 030c 	and.w	r3, r3, #12
 800104e:	2b08      	cmp	r3, #8
 8001050:	d1f9      	bne.n	8001046 <__early_init+0x96>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8001052:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 8001054:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001058:	644b      	str	r3, [r1, #68]	; 0x44
 800105a:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 800105c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001060:	664b      	str	r3, [r1, #100]	; 0x64
 8001062:	4770      	bx	lr
 8001064:	40023800 	.word	0x40023800
 8001068:	40007000 	.word	0x40007000
 800106c:	07405408 	.word	0x07405408
 8001070:	40023c00 	.word	0x40023c00
 8001074:	38889400 	.word	0x38889400
	...

08001080 <shell_thread.lto_priv.54>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 8001080:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8001084:	4b76      	ldr	r3, [pc, #472]	; (8001260 <shell_thread.lto_priv.54+0x1e0>)
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
 8001086:	6804      	ldr	r4, [r0, #0]
 8001088:	699b      	ldr	r3, [r3, #24]
 800108a:	4a76      	ldr	r2, [pc, #472]	; (8001264 <shell_thread.lto_priv.54+0x1e4>)
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
 800108c:	6847      	ldr	r7, [r0, #4]
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 800108e:	4976      	ldr	r1, [pc, #472]	; (8001268 <shell_thread.lto_priv.54+0x1e8>)
 8001090:	619a      	str	r2, [r3, #24]
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 8001092:	b099      	sub	sp, #100	; 0x64
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 8001094:	4620      	mov	r0, r4
 8001096:	f001 f953 	bl	8002340 <chprintf>
 800109a:	ae08      	add	r6, sp, #32
  while (true) {
    chprintf(chp, "ch> ");
 800109c:	4620      	mov	r0, r4
 800109e:	4973      	ldr	r1, [pc, #460]	; (800126c <shell_thread.lto_priv.54+0x1ec>)
 80010a0:	f001 f94e 	bl	8002340 <chprintf>
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
  char *p = line;
 80010a4:	4635      	mov	r5, r6

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
 80010a6:	6823      	ldr	r3, [r4, #0]
 80010a8:	4620      	mov	r0, r4
 80010aa:	685b      	ldr	r3, [r3, #4]
 80010ac:	f10d 0107 	add.w	r1, sp, #7
 80010b0:	2201      	movs	r2, #1
 80010b2:	4798      	blx	r3
 80010b4:	b380      	cbz	r0, 8001118 <shell_thread.lto_priv.54+0x98>
      return true;
    if (c == 4) {
 80010b6:	f89d 1007 	ldrb.w	r1, [sp, #7]
 80010ba:	2904      	cmp	r1, #4
 80010bc:	d028      	beq.n	8001110 <shell_thread.lto_priv.54+0x90>
      chprintf(chp, "^D");
      return true;
    }
    if ((c == 8) || (c == 127)) {
 80010be:	2908      	cmp	r1, #8
 80010c0:	d012      	beq.n	80010e8 <shell_thread.lto_priv.54+0x68>
 80010c2:	297f      	cmp	r1, #127	; 0x7f
 80010c4:	d010      	beq.n	80010e8 <shell_thread.lto_priv.54+0x68>
        chSequentialStreamPut(chp, 0x08);
        p--;
      }
      continue;
    }
    if (c == '\r') {
 80010c6:	290d      	cmp	r1, #13
      *p = 0;
      return false;
    }
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 80010c8:	f10d 035f 	add.w	r3, sp, #95	; 0x5f
        chSequentialStreamPut(chp, 0x08);
        p--;
      }
      continue;
    }
    if (c == '\r') {
 80010cc:	d039      	beq.n	8001142 <shell_thread.lto_priv.54+0xc2>
      chprintf(chp, "\r\n");
      *p = 0;
      return false;
    }
    if (c < 0x20)
 80010ce:	291f      	cmp	r1, #31
 80010d0:	d9e9      	bls.n	80010a6 <shell_thread.lto_priv.54+0x26>
      continue;
    if (p < line + size - 1) {
 80010d2:	429d      	cmp	r5, r3
 80010d4:	d2e7      	bcs.n	80010a6 <shell_thread.lto_priv.54+0x26>
      chSequentialStreamPut(chp, c);
 80010d6:	6823      	ldr	r3, [r4, #0]
 80010d8:	4620      	mov	r0, r4
 80010da:	689b      	ldr	r3, [r3, #8]
 80010dc:	4798      	blx	r3
      *p++ = (char)c;
 80010de:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80010e2:	702b      	strb	r3, [r5, #0]
 80010e4:	3501      	adds	r5, #1
 80010e6:	e7de      	b.n	80010a6 <shell_thread.lto_priv.54+0x26>
    if (c == 4) {
      chprintf(chp, "^D");
      return true;
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
 80010e8:	42b5      	cmp	r5, r6
        chSequentialStreamPut(chp, 0x08);
 80010ea:	f04f 0108 	mov.w	r1, #8
 80010ee:	4620      	mov	r0, r4
    if (c == 4) {
      chprintf(chp, "^D");
      return true;
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
 80010f0:	d0d9      	beq.n	80010a6 <shell_thread.lto_priv.54+0x26>
        chSequentialStreamPut(chp, 0x08);
 80010f2:	6823      	ldr	r3, [r4, #0]
 80010f4:	689b      	ldr	r3, [r3, #8]
 80010f6:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x20);
 80010f8:	6823      	ldr	r3, [r4, #0]
 80010fa:	4620      	mov	r0, r4
 80010fc:	689b      	ldr	r3, [r3, #8]
 80010fe:	2120      	movs	r1, #32
 8001100:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x08);
 8001102:	6823      	ldr	r3, [r4, #0]
 8001104:	4620      	mov	r0, r4
 8001106:	689b      	ldr	r3, [r3, #8]
 8001108:	2108      	movs	r1, #8
        p--;
 800110a:	3d01      	subs	r5, #1
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
        chSequentialStreamPut(chp, 0x08);
        chSequentialStreamPut(chp, 0x20);
        chSequentialStreamPut(chp, 0x08);
 800110c:	4798      	blx	r3
 800110e:	e7ca      	b.n	80010a6 <shell_thread.lto_priv.54+0x26>
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
      return true;
    if (c == 4) {
      chprintf(chp, "^D");
 8001110:	4620      	mov	r0, r4
 8001112:	4957      	ldr	r1, [pc, #348]	; (8001270 <shell_thread.lto_priv.54+0x1f0>)
 8001114:	f001 f914 	bl	8002340 <chprintf>
  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
  while (true) {
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
 8001118:	4620      	mov	r0, r4
 800111a:	4956      	ldr	r1, [pc, #344]	; (8001274 <shell_thread.lto_priv.54+0x1f4>)
 800111c:	f001 f910 	bl	8002340 <chprintf>
 8001120:	2320      	movs	r3, #32
 8001122:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 8001126:	f001 ff7b 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800112a:	f002 f9f9 	bl	8003520 <_dbg_check_lock>
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 800112e:	2100      	movs	r1, #0
 8001130:	4851      	ldr	r0, [pc, #324]	; (8001278 <shell_thread.lto_priv.54+0x1f8>)
 8001132:	f000 fbcd 	bl	80018d0 <chEvtBroadcastFlagsI>

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
 8001136:	2000      	movs	r0, #0
 8001138:	f002 f922 	bl	8003380 <chThdExitS>
        chprintf(chp, " ?\r\n");
      }
    }
  }
  shellExit(MSG_OK);
}
 800113c:	b019      	add	sp, #100	; 0x64
 800113e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        p--;
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, "\r\n");
 8001142:	494e      	ldr	r1, [pc, #312]	; (800127c <shell_thread.lto_priv.54+0x1fc>)
 8001144:	4620      	mov	r0, r4
 8001146:	f001 f8fb 	bl	8002340 <chprintf>
      *p = 0;
 800114a:	2300      	movs	r3, #0
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 800114c:	a902      	add	r1, sp, #8
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, "\r\n");
      *p = 0;
 800114e:	702b      	strb	r3, [r5, #0]
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 8001150:	4630      	mov	r0, r6
    cmd = lp;
    n = 0;
 8001152:	461d      	mov	r5, r3
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 8001154:	f003 f87c 	bl	8004250 <_strtok.constprop.9>
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8001158:	a902      	add	r1, sp, #8
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 800115a:	4681      	mov	r9, r0
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 800115c:	2000      	movs	r0, #0
 800115e:	f10d 080c 	add.w	r8, sp, #12
 8001162:	f003 f875 	bl	8004250 <_strtok.constprop.9>
 8001166:	b150      	cbz	r0, 800117e <shell_thread.lto_priv.54+0xfe>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8001168:	2d04      	cmp	r5, #4
 800116a:	d01d      	beq.n	80011a8 <shell_thread.lto_priv.54+0x128>
        chprintf(chp, "too many arguments\r\n");
        cmd = NULL;
        break;
      }
      args[n++] = lp;
 800116c:	f848 0b04 	str.w	r0, [r8], #4
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8001170:	a902      	add	r1, sp, #8
 8001172:	2000      	movs	r0, #0
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments\r\n");
        cmd = NULL;
        break;
      }
      args[n++] = lp;
 8001174:	3501      	adds	r5, #1
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8001176:	f003 f86b 	bl	8004250 <_strtok.constprop.9>
 800117a:	2800      	cmp	r0, #0
 800117c:	d1f4      	bne.n	8001168 <shell_thread.lto_priv.54+0xe8>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 800117e:	ab18      	add	r3, sp, #96	; 0x60
 8001180:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 8001184:	f843 0c54 	str.w	r0, [r3, #-84]
    if (cmd != NULL) {
 8001188:	f1b9 0f00 	cmp.w	r9, #0
 800118c:	d086      	beq.n	800109c <shell_thread.lto_priv.54+0x1c>
      if (strcmp(cmd, "exit") == 0) {
 800118e:	4648      	mov	r0, r9
 8001190:	493b      	ldr	r1, [pc, #236]	; (8001280 <shell_thread.lto_priv.54+0x200>)
 8001192:	f7ff f969 	bl	8000468 <strcmp>
 8001196:	b970      	cbnz	r0, 80011b6 <shell_thread.lto_priv.54+0x136>
        if (n > 0) {
 8001198:	2d00      	cmp	r5, #0
 800119a:	d0c1      	beq.n	8001120 <shell_thread.lto_priv.54+0xa0>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 800119c:	4620      	mov	r0, r4
 800119e:	4939      	ldr	r1, [pc, #228]	; (8001284 <shell_thread.lto_priv.54+0x204>)
 80011a0:	4a37      	ldr	r2, [pc, #220]	; (8001280 <shell_thread.lto_priv.54+0x200>)
 80011a2:	f001 f8cd 	bl	8002340 <chprintf>
 80011a6:	e779      	b.n	800109c <shell_thread.lto_priv.54+0x1c>
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments\r\n");
 80011a8:	4620      	mov	r0, r4
 80011aa:	4937      	ldr	r1, [pc, #220]	; (8001288 <shell_thread.lto_priv.54+0x208>)
 80011ac:	f001 f8c8 	bl	8002340 <chprintf>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 80011b0:	2300      	movs	r3, #0
 80011b2:	9307      	str	r3, [sp, #28]
 80011b4:	e772      	b.n	800109c <shell_thread.lto_priv.54+0x1c>
          usage(chp, "exit");
          continue;
        }
        break;
      }
      else if (strcmp(cmd, "help") == 0) {
 80011b6:	4648      	mov	r0, r9
 80011b8:	4934      	ldr	r1, [pc, #208]	; (800128c <shell_thread.lto_priv.54+0x20c>)
 80011ba:	f7ff f955 	bl	8000468 <strcmp>
 80011be:	b930      	cbnz	r0, 80011ce <shell_thread.lto_priv.54+0x14e>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 80011c0:	4620      	mov	r0, r4
          continue;
        }
        break;
      }
      else if (strcmp(cmd, "help") == 0) {
        if (n > 0) {
 80011c2:	b1bd      	cbz	r5, 80011f4 <shell_thread.lto_priv.54+0x174>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 80011c4:	492f      	ldr	r1, [pc, #188]	; (8001284 <shell_thread.lto_priv.54+0x204>)
 80011c6:	4a31      	ldr	r2, [pc, #196]	; (800128c <shell_thread.lto_priv.54+0x20c>)
 80011c8:	f001 f8ba 	bl	8002340 <chprintf>
 80011cc:	e766      	b.n	800109c <shell_thread.lto_priv.54+0x1c>
 80011ce:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 8001298 <shell_thread.lto_priv.54+0x218>
          usage(chp, "exit");
          continue;
        }
        break;
      }
      else if (strcmp(cmd, "help") == 0) {
 80011d2:	482f      	ldr	r0, [pc, #188]	; (8001290 <shell_thread.lto_priv.54+0x210>)
 80011d4:	e002      	b.n	80011dc <shell_thread.lto_priv.54+0x15c>
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 80011d6:	f858 0f08 	ldr.w	r0, [r8, #8]!
 80011da:	b348      	cbz	r0, 8001230 <shell_thread.lto_priv.54+0x1b0>
    if (strcmp(scp->sc_name, name) == 0) {
 80011dc:	4649      	mov	r1, r9
 80011de:	f7ff f943 	bl	8000468 <strcmp>
 80011e2:	2800      	cmp	r0, #0
 80011e4:	d1f7      	bne.n	80011d6 <shell_thread.lto_priv.54+0x156>
      scp->sc_function(chp, argc, argv);
 80011e6:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80011ea:	4629      	mov	r1, r5
 80011ec:	aa03      	add	r2, sp, #12
 80011ee:	4620      	mov	r0, r4
 80011f0:	4798      	blx	r3
 80011f2:	e753      	b.n	800109c <shell_thread.lto_priv.54+0x1c>
      else if (strcmp(cmd, "help") == 0) {
        if (n > 0) {
          usage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help exit ");
 80011f4:	4927      	ldr	r1, [pc, #156]	; (8001294 <shell_thread.lto_priv.54+0x214>)
 80011f6:	4d28      	ldr	r5, [pc, #160]	; (8001298 <shell_thread.lto_priv.54+0x218>)
 80011f8:	f001 f8a2 	bl	8002340 <chprintf>
 80011fc:	4a24      	ldr	r2, [pc, #144]	; (8001290 <shell_thread.lto_priv.54+0x210>)
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
    chprintf(chp, "%s ", scp->sc_name);
 80011fe:	4927      	ldr	r1, [pc, #156]	; (800129c <shell_thread.lto_priv.54+0x21c>)
 8001200:	4620      	mov	r0, r4
 8001202:	f001 f89d 	bl	8002340 <chprintf>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8001206:	f855 2f08 	ldr.w	r2, [r5, #8]!
 800120a:	2a00      	cmp	r2, #0
 800120c:	d1f7      	bne.n	80011fe <shell_thread.lto_priv.54+0x17e>
          usage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help exit ");
        list_commands(chp, local_commands);
        if (scp != NULL)
 800120e:	b157      	cbz	r7, 8001226 <shell_thread.lto_priv.54+0x1a6>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8001210:	683a      	ldr	r2, [r7, #0]
 8001212:	b142      	cbz	r2, 8001226 <shell_thread.lto_priv.54+0x1a6>
 8001214:	463d      	mov	r5, r7
    chprintf(chp, "%s ", scp->sc_name);
 8001216:	4620      	mov	r0, r4
 8001218:	4920      	ldr	r1, [pc, #128]	; (800129c <shell_thread.lto_priv.54+0x21c>)
 800121a:	f001 f891 	bl	8002340 <chprintf>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 800121e:	f855 2f08 	ldr.w	r2, [r5, #8]!
 8001222:	2a00      	cmp	r2, #0
 8001224:	d1f7      	bne.n	8001216 <shell_thread.lto_priv.54+0x196>
        }
        chprintf(chp, "Commands: help exit ");
        list_commands(chp, local_commands);
        if (scp != NULL)
          list_commands(chp, scp);
        chprintf(chp, "\r\n");
 8001226:	4620      	mov	r0, r4
 8001228:	4914      	ldr	r1, [pc, #80]	; (800127c <shell_thread.lto_priv.54+0x1fc>)
 800122a:	f001 f889 	bl	8002340 <chprintf>
 800122e:	e735      	b.n	800109c <shell_thread.lto_priv.54+0x1c>
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
 8001230:	b167      	cbz	r7, 800124c <shell_thread.lto_priv.54+0x1cc>
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 8001232:	6838      	ldr	r0, [r7, #0]
 8001234:	b150      	cbz	r0, 800124c <shell_thread.lto_priv.54+0x1cc>
 8001236:	46b8      	mov	r8, r7
 8001238:	e002      	b.n	8001240 <shell_thread.lto_priv.54+0x1c0>
 800123a:	f858 0f08 	ldr.w	r0, [r8, #8]!
 800123e:	b128      	cbz	r0, 800124c <shell_thread.lto_priv.54+0x1cc>
    if (strcmp(scp->sc_name, name) == 0) {
 8001240:	4649      	mov	r1, r9
 8001242:	f7ff f911 	bl	8000468 <strcmp>
 8001246:	2800      	cmp	r0, #0
 8001248:	d1f7      	bne.n	800123a <shell_thread.lto_priv.54+0x1ba>
 800124a:	e7cc      	b.n	80011e6 <shell_thread.lto_priv.54+0x166>
          list_commands(chp, scp);
        chprintf(chp, "\r\n");
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
        chprintf(chp, "%s", cmd);
 800124c:	464a      	mov	r2, r9
 800124e:	4620      	mov	r0, r4
 8001250:	4913      	ldr	r1, [pc, #76]	; (80012a0 <shell_thread.lto_priv.54+0x220>)
 8001252:	f001 f875 	bl	8002340 <chprintf>
        chprintf(chp, " ?\r\n");
 8001256:	4620      	mov	r0, r4
 8001258:	4912      	ldr	r1, [pc, #72]	; (80012a4 <shell_thread.lto_priv.54+0x224>)
 800125a:	f001 f871 	bl	8002340 <chprintf>
 800125e:	e71d      	b.n	800109c <shell_thread.lto_priv.54+0x1c>
 8001260:	20002740 	.word	0x20002740
 8001264:	08005618 	.word	0x08005618
 8001268:	08005620 	.word	0x08005620
 800126c:	08005638 	.word	0x08005638
 8001270:	08005640 	.word	0x08005640
 8001274:	08005694 	.word	0x08005694
 8001278:	20000800 	.word	0x20000800
 800127c:	080055c4 	.word	0x080055c4
 8001280:	0800565c 	.word	0x0800565c
 8001284:	0800547c 	.word	0x0800547c
 8001288:	08005644 	.word	0x08005644
 800128c:	08005664 	.word	0x08005664
 8001290:	08005488 	.word	0x08005488
 8001294:	0800566c 	.word	0x0800566c
 8001298:	080056c0 	.word	0x080056c0
 800129c:	08005684 	.word	0x08005684
 80012a0:	08005688 	.word	0x08005688
 80012a4:	0800568c 	.word	0x0800568c
	...

080012b0 <cmd_systime>:
}

static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 80012b0:	2900      	cmp	r1, #0
 80012b2:	dd03      	ble.n	80012bc <cmd_systime+0xc>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 80012b4:	4915      	ldr	r1, [pc, #84]	; (800130c <cmd_systime+0x5c>)
 80012b6:	4a16      	ldr	r2, [pc, #88]	; (8001310 <cmd_systime+0x60>)
 80012b8:	f001 b842 	b.w	8002340 <chprintf>
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
#endif
#endif
}

static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
 80012bc:	b538      	push	{r3, r4, r5, lr}
 80012be:	4604      	mov	r4, r0
 80012c0:	2320      	movs	r3, #32
 80012c2:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 80012c6:	f001 feab 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80012ca:	f002 f929 	bl	8003520 <_dbg_check_lock>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80012ce:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80012d2:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80012d4:	f002 f914 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80012d8:	f001 fe8a 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80012dc:	4b0d      	ldr	r3, [pc, #52]	; (8001314 <cmd_systime+0x64>)
 80012de:	6819      	ldr	r1, [r3, #0]
 80012e0:	4299      	cmp	r1, r3
 80012e2:	d004      	beq.n	80012ee <cmd_systime+0x3e>
 80012e4:	6998      	ldr	r0, [r3, #24]
 80012e6:	688a      	ldr	r2, [r1, #8]
 80012e8:	6881      	ldr	r1, [r0, #8]
 80012ea:	4291      	cmp	r1, r2
 80012ec:	d309      	bcc.n	8001302 <cmd_systime+0x52>
 80012ee:	2300      	movs	r3, #0
 80012f0:	f383 8811 	msr	BASEPRI, r3
  (void)argv;
  if (argc > 0) {
    usage(chp, "systime");
    return;
  }
  chprintf(chp, "%lu\r\n", (unsigned long)chVTGetSystemTime());
 80012f4:	4908      	ldr	r1, [pc, #32]	; (8001318 <cmd_systime+0x68>)
 80012f6:	4620      	mov	r0, r4
 80012f8:	462a      	mov	r2, r5
}
 80012fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  (void)argv;
  if (argc > 0) {
    usage(chp, "systime");
    return;
  }
  chprintf(chp, "%lu\r\n", (unsigned long)chVTGetSystemTime());
 80012fe:	f001 b81f 	b.w	8002340 <chprintf>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001302:	b672      	cpsid	i
 8001304:	4a05      	ldr	r2, [pc, #20]	; (800131c <cmd_systime+0x6c>)
 8001306:	62da      	str	r2, [r3, #44]	; 0x2c
 8001308:	e7fe      	b.n	8001308 <cmd_systime+0x58>
 800130a:	bf00      	nop
 800130c:	0800547c 	.word	0x0800547c
 8001310:	080056a0 	.word	0x080056a0
 8001314:	20002740 	.word	0x20002740
 8001318:	080056a8 	.word	0x080056a8
 800131c:	080056b0 	.word	0x080056b0

08001320 <SVC_Handler>:
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8001320:	4a06      	ldr	r2, [pc, #24]	; (800133c <SVC_Handler+0x1c>)
 8001322:	6853      	ldr	r3, [r2, #4]
 8001324:	f023 0301 	bic.w	r3, r3, #1
 8001328:	6053      	str	r3, [r2, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800132a:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 800132e:	3368      	adds	r3, #104	; 0x68

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001330:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001334:	2300      	movs	r3, #0
 8001336:	f383 8811 	msr	BASEPRI, r3
 800133a:	4770      	bx	lr
 800133c:	e000ef30 	.word	0xe000ef30

08001340 <stSetAlarm>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8001340:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001344:	68da      	ldr	r2, [r3, #12]
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8001346:	0792      	lsls	r2, r2, #30
 8001348:	d501      	bpl.n	800134e <stSetAlarm+0xe>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800134a:	6358      	str	r0, [r3, #52]	; 0x34
 800134c:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800134e:	b672      	cpsid	i
 8001350:	4b01      	ldr	r3, [pc, #4]	; (8001358 <stSetAlarm+0x18>)
 8001352:	4a02      	ldr	r2, [pc, #8]	; (800135c <stSetAlarm+0x1c>)
 8001354:	62da      	str	r2, [r3, #44]	; 0x2c
 8001356:	e7fe      	b.n	8001356 <stSetAlarm+0x16>
 8001358:	20002740 	.word	0x20002740
 800135c:	08005730 	.word	0x08005730

08001360 <_port_irq_epilogue>:

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001360:	2320      	movs	r3, #32
 8001362:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8001366:	4b12      	ldr	r3, [pc, #72]	; (80013b0 <_port_irq_epilogue+0x50>)
 8001368:	685b      	ldr	r3, [r3, #4]
 800136a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800136e:	d102      	bne.n	8001376 <_port_irq_epilogue+0x16>
 8001370:	f383 8811 	msr	BASEPRI, r3
 8001374:	4770      	bx	lr
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8001376:	eef1 3a10 	vmrs	r3, fpscr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800137a:	f3ef 8309 	mrs	r3, PSP
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 800137e:	4a0d      	ldr	r2, [pc, #52]	; (80013b4 <_port_irq_epilogue+0x54>)
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8001380:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8001384:	68d2      	ldr	r2, [r2, #12]
 8001386:	f843 2c08 	str.w	r2, [r3, #-8]
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800138a:	f843 1c4c 	str.w	r1, [r3, #-76]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 800138e:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001392:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8001396:	4a08      	ldr	r2, [pc, #32]	; (80013b8 <_port_irq_epilogue+0x58>)
 8001398:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->p_prio;
 800139a:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800139c:	6889      	ldr	r1, [r1, #8]
 800139e:	6892      	ldr	r2, [r2, #8]
 80013a0:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80013a2:	bf8c      	ite	hi
 80013a4:	4a05      	ldrhi	r2, [pc, #20]	; (80013bc <_port_irq_epilogue+0x5c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80013a6:	4a06      	ldrls	r2, [pc, #24]	; (80013c0 <_port_irq_epilogue+0x60>)
 80013a8:	f843 2c50 	str.w	r2, [r3, #-80]
 80013ac:	4770      	bx	lr
 80013ae:	bf00      	nop
 80013b0:	e000ed00 	.word	0xe000ed00
 80013b4:	e000ef30 	.word	0xe000ef30
 80013b8:	20002740 	.word	0x20002740
 80013bc:	08000301 	.word	0x08000301
 80013c0:	08000314 	.word	0x08000314
	...

080013d0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80013d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80013d4:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 80013d8:	f001 fdca 	bl	8002f70 <_stats_increase_irq>
 80013dc:	f002 f810 	bl	8003400 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80013e0:	6933      	ldr	r3, [r6, #16]
 80013e2:	079b      	lsls	r3, r3, #30
 80013e4:	d405      	bmi.n	80013f2 <VectorB0+0x22>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 80013e6:	f001 fff3 	bl	80033d0 <_dbg_check_leave_isr>
}
 80013ea:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 80013ee:	f7ff bfb7 	b.w	8001360 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 80013f2:	2700      	movs	r7, #0
 80013f4:	6137      	str	r7, [r6, #16]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80013f6:	f04f 0920 	mov.w	r9, #32
 80013fa:	f389 8811 	msr	BASEPRI, r9
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 80013fe:	4d2f      	ldr	r5, [pc, #188]	; (80014bc <VectorB0+0xec>)
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8001400:	f001 fe06 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8001404:	f002 f82c 	bl	8003460 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
 8001408:	f001 fe9a 	bl	8003140 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();
 800140c:	f001 fe98 	bl	8003140 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8001410:	69ec      	ldr	r4, [r5, #28]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001412:	6a72      	ldr	r2, [r6, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8001414:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8001416:	68a3      	ldr	r3, [r4, #8]
 8001418:	1a50      	subs	r0, r2, r1
 800141a:	4298      	cmp	r0, r3
 800141c:	bf38      	it	cc
 800141e:	f105 061c 	addcc.w	r6, r5, #28
 8001422:	d325      	bcc.n	8001470 <VectorB0+0xa0>
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 8001424:	46b8      	mov	r8, r7
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8001426:	4637      	mov	r7, r6
 8001428:	f105 061c 	add.w	r6, r5, #28
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800142c:	6822      	ldr	r2, [r4, #0]
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 800142e:	f8d4 a00c 	ldr.w	sl, [r4, #12]
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8001432:	440b      	add	r3, r1
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8001434:	42b2      	cmp	r2, r6
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8001436:	62ab      	str	r3, [r5, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001438:	6056      	str	r6, [r2, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 800143a:	61ea      	str	r2, [r5, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 800143c:	f8c4 800c 	str.w	r8, [r4, #12]
 8001440:	bf08      	it	eq
 8001442:	f8c7 800c 	streq.w	r8, [r7, #12]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8001446:	f001 fff3 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 800144a:	f001 fdc9 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 800144e:	f388 8811 	msr	BASEPRI, r8
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8001452:	6920      	ldr	r0, [r4, #16]
 8001454:	47d0      	blx	sl
 8001456:	f389 8811 	msr	BASEPRI, r9
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 800145a:	f001 fdd9 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800145e:	f001 ffff 	bl	8003460 <_dbg_check_lock_from_isr>
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 8001462:	69ec      	ldr	r4, [r5, #28]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001464:	6a7a      	ldr	r2, [r7, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8001466:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8001468:	68a3      	ldr	r3, [r4, #8]
 800146a:	1a50      	subs	r0, r2, r1
 800146c:	4283      	cmp	r3, r0
 800146e:	d9dd      	bls.n	800142c <VectorB0+0x5c>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8001470:	42b4      	cmp	r4, r6
 8001472:	d015      	beq.n	80014a0 <VectorB0+0xd0>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8001474:	440b      	add	r3, r1
 8001476:	1a9b      	subs	r3, r3, r2
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001478:	2b01      	cmp	r3, #1
 800147a:	bf98      	it	ls
 800147c:	2302      	movls	r3, #2
  }
  port_timer_set_alarm(now + delta);
 800147e:	189c      	adds	r4, r3, r2
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8001480:	4620      	mov	r0, r4
 8001482:	f7ff ff5d 	bl	8001340 <stSetAlarm>
 8001486:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
 800148a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800148c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800148e:	480b      	ldr	r0, [pc, #44]	; (80014bc <VectorB0+0xec>)
 8001490:	1a63      	subs	r3, r4, r1
 8001492:	1a52      	subs	r2, r2, r1
 8001494:	429a      	cmp	r2, r3
 8001496:	d903      	bls.n	80014a0 <VectorB0+0xd0>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001498:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800149a:	4b09      	ldr	r3, [pc, #36]	; (80014c0 <VectorB0+0xf0>)
 800149c:	62c3      	str	r3, [r0, #44]	; 0x2c
 800149e:	e7fe      	b.n	800149e <VectorB0+0xce>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80014a0:	f001 ffc6 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80014a4:	f001 fd9c 	bl	8002fe0 <_stats_stop_measure_crit_isr>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80014a8:	2300      	movs	r3, #0
 80014aa:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 80014ae:	f001 ff8f 	bl	80033d0 <_dbg_check_leave_isr>
}
 80014b2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 80014b6:	f7ff bf53 	b.w	8001360 <_port_irq_epilogue>
 80014ba:	bf00      	nop
 80014bc:	20002740 	.word	0x20002740
 80014c0:	08005720 	.word	0x08005720
	...

080014d0 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 80014d0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80014d2:	f001 fd4d 	bl	8002f70 <_stats_increase_irq>
 80014d6:	f001 ff93 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80014da:	4b09      	ldr	r3, [pc, #36]	; (8001500 <Vector158+0x30>)
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
 80014dc:	4809      	ldr	r0, [pc, #36]	; (8001504 <Vector158+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80014de:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
 80014e0:	6f82      	ldr	r2, [r0, #120]	; 0x78
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80014e2:	0d89      	lsrs	r1, r1, #22
 80014e4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 22U;
 80014e8:	058c      	lsls	r4, r1, #22
 80014ea:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 80014ec:	b10a      	cbz	r2, 80014f2 <Vector158+0x22>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 80014ee:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 80014f0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80014f2:	f001 ff6d 	bl	80033d0 <_dbg_check_leave_isr>
}
 80014f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80014fa:	f7ff bf31 	b.w	8001360 <_port_irq_epilogue>
 80014fe:	bf00      	nop
 8001500:	40026400 	.word	0x40026400
 8001504:	200030c8 	.word	0x200030c8
	...

08001510 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8001510:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001512:	f001 fd2d 	bl	8002f70 <_stats_increase_irq>
 8001516:	f001 ff73 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800151a:	4b09      	ldr	r3, [pc, #36]	; (8001540 <Vector154+0x30>)
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
 800151c:	4809      	ldr	r0, [pc, #36]	; (8001544 <Vector154+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800151e:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
 8001520:	6f02      	ldr	r2, [r0, #112]	; 0x70
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8001522:	0c09      	lsrs	r1, r1, #16
 8001524:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 16U;
 8001528:	040c      	lsls	r4, r1, #16
 800152a:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 800152c:	b10a      	cbz	r2, 8001532 <Vector154+0x22>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 800152e:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8001530:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001532:	f001 ff4d 	bl	80033d0 <_dbg_check_leave_isr>
}
 8001536:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800153a:	f7ff bf11 	b.w	8001360 <_port_irq_epilogue>
 800153e:	bf00      	nop
 8001540:	40026400 	.word	0x40026400
 8001544:	200030c8 	.word	0x200030c8
	...

08001550 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8001550:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001552:	f001 fd0d 	bl	8002f70 <_stats_increase_irq>
 8001556:	f001 ff53 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800155a:	4b09      	ldr	r3, [pc, #36]	; (8001580 <Vector150+0x30>)
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
 800155c:	4809      	ldr	r0, [pc, #36]	; (8001584 <Vector150+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800155e:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
 8001560:	6e82      	ldr	r2, [r0, #104]	; 0x68
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8001562:	0989      	lsrs	r1, r1, #6
 8001564:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 6U;
 8001568:	018c      	lsls	r4, r1, #6
 800156a:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 800156c:	b10a      	cbz	r2, 8001572 <Vector150+0x22>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 800156e:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8001570:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001572:	f001 ff2d 	bl	80033d0 <_dbg_check_leave_isr>
}
 8001576:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800157a:	f7ff bef1 	b.w	8001360 <_port_irq_epilogue>
 800157e:	bf00      	nop
 8001580:	40026400 	.word	0x40026400
 8001584:	200030c8 	.word	0x200030c8
	...

08001590 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8001590:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001592:	f001 fced 	bl	8002f70 <_stats_increase_irq>
 8001596:	f001 ff33 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800159a:	4b08      	ldr	r3, [pc, #32]	; (80015bc <Vector130+0x2c>)
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
 800159c:	4808      	ldr	r0, [pc, #32]	; (80015c0 <Vector130+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800159e:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
 80015a0:	6e02      	ldr	r2, [r0, #96]	; 0x60
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 80015a2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 80015a6:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 80015a8:	b10a      	cbz	r2, 80015ae <Vector130+0x1e>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 80015aa:	6e40      	ldr	r0, [r0, #100]	; 0x64
 80015ac:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80015ae:	f001 ff0f 	bl	80033d0 <_dbg_check_leave_isr>
}
 80015b2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80015b6:	f7ff bed3 	b.w	8001360 <_port_irq_epilogue>
 80015ba:	bf00      	nop
 80015bc:	40026400 	.word	0x40026400
 80015c0:	200030c8 	.word	0x200030c8
	...

080015d0 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 80015d0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80015d2:	f001 fccd 	bl	8002f70 <_stats_increase_irq>
 80015d6:	f001 ff13 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80015da:	4b09      	ldr	r3, [pc, #36]	; (8001600 <Vector12C+0x30>)
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
 80015dc:	4809      	ldr	r0, [pc, #36]	; (8001604 <Vector12C+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80015de:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
 80015e0:	6d82      	ldr	r2, [r0, #88]	; 0x58
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80015e2:	0d89      	lsrs	r1, r1, #22
 80015e4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 22U;
 80015e8:	058c      	lsls	r4, r1, #22
 80015ea:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 80015ec:	b10a      	cbz	r2, 80015f2 <Vector12C+0x22>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 80015ee:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 80015f0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80015f2:	f001 feed 	bl	80033d0 <_dbg_check_leave_isr>
}
 80015f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80015fa:	f7ff beb1 	b.w	8001360 <_port_irq_epilogue>
 80015fe:	bf00      	nop
 8001600:	40026400 	.word	0x40026400
 8001604:	200030c8 	.word	0x200030c8
	...

08001610 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8001610:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001612:	f001 fcad 	bl	8002f70 <_stats_increase_irq>
 8001616:	f001 fef3 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800161a:	4b09      	ldr	r3, [pc, #36]	; (8001640 <Vector128+0x30>)
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
 800161c:	4809      	ldr	r0, [pc, #36]	; (8001644 <Vector128+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800161e:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
 8001620:	6d02      	ldr	r2, [r0, #80]	; 0x50
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8001622:	0c09      	lsrs	r1, r1, #16
 8001624:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 16U;
 8001628:	040c      	lsls	r4, r1, #16
 800162a:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 800162c:	b10a      	cbz	r2, 8001632 <Vector128+0x22>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 800162e:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8001630:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001632:	f001 fecd 	bl	80033d0 <_dbg_check_leave_isr>
}
 8001636:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800163a:	f7ff be91 	b.w	8001360 <_port_irq_epilogue>
 800163e:	bf00      	nop
 8001640:	40026400 	.word	0x40026400
 8001644:	200030c8 	.word	0x200030c8
	...

08001650 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8001650:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001652:	f001 fc8d 	bl	8002f70 <_stats_increase_irq>
 8001656:	f001 fed3 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800165a:	4b09      	ldr	r3, [pc, #36]	; (8001680 <Vector124+0x30>)
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
 800165c:	4809      	ldr	r0, [pc, #36]	; (8001684 <Vector124+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800165e:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
 8001660:	6c82      	ldr	r2, [r0, #72]	; 0x48
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8001662:	0989      	lsrs	r1, r1, #6
 8001664:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 6U;
 8001668:	018c      	lsls	r4, r1, #6
 800166a:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 800166c:	b10a      	cbz	r2, 8001672 <Vector124+0x22>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 800166e:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8001670:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001672:	f001 fead 	bl	80033d0 <_dbg_check_leave_isr>
}
 8001676:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800167a:	f7ff be71 	b.w	8001360 <_port_irq_epilogue>
 800167e:	bf00      	nop
 8001680:	40026400 	.word	0x40026400
 8001684:	200030c8 	.word	0x200030c8
	...

08001690 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8001690:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001692:	f001 fc6d 	bl	8002f70 <_stats_increase_irq>
 8001696:	f001 feb3 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800169a:	4b08      	ldr	r3, [pc, #32]	; (80016bc <Vector120+0x2c>)
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
 800169c:	4808      	ldr	r0, [pc, #32]	; (80016c0 <Vector120+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800169e:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
 80016a0:	6c02      	ldr	r2, [r0, #64]	; 0x40
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80016a2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 80016a6:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 80016a8:	b10a      	cbz	r2, 80016ae <Vector120+0x1e>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 80016aa:	6c40      	ldr	r0, [r0, #68]	; 0x44
 80016ac:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80016ae:	f001 fe8f 	bl	80033d0 <_dbg_check_leave_isr>
}
 80016b2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80016b6:	f7ff be53 	b.w	8001360 <_port_irq_epilogue>
 80016ba:	bf00      	nop
 80016bc:	40026400 	.word	0x40026400
 80016c0:	200030c8 	.word	0x200030c8
	...

080016d0 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 80016d0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80016d2:	f001 fc4d 	bl	8002f70 <_stats_increase_irq>
 80016d6:	f001 fe93 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80016da:	4b09      	ldr	r3, [pc, #36]	; (8001700 <VectorFC+0x30>)
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
 80016dc:	4809      	ldr	r0, [pc, #36]	; (8001704 <VectorFC+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80016de:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
 80016e0:	6b82      	ldr	r2, [r0, #56]	; 0x38
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80016e2:	0d89      	lsrs	r1, r1, #22
 80016e4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 22U;
 80016e8:	058c      	lsls	r4, r1, #22
 80016ea:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 80016ec:	b10a      	cbz	r2, 80016f2 <VectorFC+0x22>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 80016ee:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 80016f0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80016f2:	f001 fe6d 	bl	80033d0 <_dbg_check_leave_isr>
}
 80016f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80016fa:	f7ff be31 	b.w	8001360 <_port_irq_epilogue>
 80016fe:	bf00      	nop
 8001700:	40026000 	.word	0x40026000
 8001704:	200030c8 	.word	0x200030c8
	...

08001710 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8001710:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001712:	f001 fc2d 	bl	8002f70 <_stats_increase_irq>
 8001716:	f001 fe73 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800171a:	4b09      	ldr	r3, [pc, #36]	; (8001740 <Vector84+0x30>)
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
 800171c:	4809      	ldr	r0, [pc, #36]	; (8001744 <Vector84+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800171e:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
 8001720:	6b02      	ldr	r2, [r0, #48]	; 0x30
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8001722:	0c09      	lsrs	r1, r1, #16
 8001724:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 16U;
 8001728:	040c      	lsls	r4, r1, #16
 800172a:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 800172c:	b10a      	cbz	r2, 8001732 <Vector84+0x22>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 800172e:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8001730:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001732:	f001 fe4d 	bl	80033d0 <_dbg_check_leave_isr>
}
 8001736:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800173a:	f7ff be11 	b.w	8001360 <_port_irq_epilogue>
 800173e:	bf00      	nop
 8001740:	40026000 	.word	0x40026000
 8001744:	200030c8 	.word	0x200030c8
	...

08001750 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8001750:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001752:	f001 fc0d 	bl	8002f70 <_stats_increase_irq>
 8001756:	f001 fe53 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800175a:	4b09      	ldr	r3, [pc, #36]	; (8001780 <Vector80+0x30>)
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
 800175c:	4809      	ldr	r0, [pc, #36]	; (8001784 <Vector80+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800175e:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
 8001760:	6a82      	ldr	r2, [r0, #40]	; 0x28
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8001762:	0989      	lsrs	r1, r1, #6
 8001764:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 6U;
 8001768:	018c      	lsls	r4, r1, #6
 800176a:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 800176c:	b10a      	cbz	r2, 8001772 <Vector80+0x22>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 800176e:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8001770:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001772:	f001 fe2d 	bl	80033d0 <_dbg_check_leave_isr>
}
 8001776:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800177a:	f7ff bdf1 	b.w	8001360 <_port_irq_epilogue>
 800177e:	bf00      	nop
 8001780:	40026000 	.word	0x40026000
 8001784:	200030c8 	.word	0x200030c8
	...

08001790 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8001790:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001792:	f001 fbed 	bl	8002f70 <_stats_increase_irq>
 8001796:	f001 fe33 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800179a:	4b08      	ldr	r3, [pc, #32]	; (80017bc <Vector7C+0x2c>)
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
 800179c:	4808      	ldr	r0, [pc, #32]	; (80017c0 <Vector7C+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800179e:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
 80017a0:	6a02      	ldr	r2, [r0, #32]
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 80017a2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 80017a6:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 80017a8:	b10a      	cbz	r2, 80017ae <Vector7C+0x1e>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 80017aa:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80017ac:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80017ae:	f001 fe0f 	bl	80033d0 <_dbg_check_leave_isr>
}
 80017b2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80017b6:	f7ff bdd3 	b.w	8001360 <_port_irq_epilogue>
 80017ba:	bf00      	nop
 80017bc:	40026000 	.word	0x40026000
 80017c0:	200030c8 	.word	0x200030c8
	...

080017d0 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80017d0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80017d2:	f001 fbcd 	bl	8002f70 <_stats_increase_irq>
 80017d6:	f001 fe13 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80017da:	4b09      	ldr	r3, [pc, #36]	; (8001800 <Vector78+0x30>)
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
 80017dc:	4809      	ldr	r0, [pc, #36]	; (8001804 <Vector78+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80017de:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
 80017e0:	6982      	ldr	r2, [r0, #24]
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80017e2:	0d89      	lsrs	r1, r1, #22
 80017e4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 22U;
 80017e8:	058c      	lsls	r4, r1, #22
 80017ea:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 80017ec:	b10a      	cbz	r2, 80017f2 <Vector78+0x22>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 80017ee:	69c0      	ldr	r0, [r0, #28]
 80017f0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80017f2:	f001 fded 	bl	80033d0 <_dbg_check_leave_isr>
}
 80017f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80017fa:	f7ff bdb1 	b.w	8001360 <_port_irq_epilogue>
 80017fe:	bf00      	nop
 8001800:	40026000 	.word	0x40026000
 8001804:	200030c8 	.word	0x200030c8
	...

08001810 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8001810:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001812:	f001 fbad 	bl	8002f70 <_stats_increase_irq>
 8001816:	f001 fdf3 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800181a:	4b09      	ldr	r3, [pc, #36]	; (8001840 <Vector74+0x30>)
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
 800181c:	4809      	ldr	r0, [pc, #36]	; (8001844 <Vector74+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800181e:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
 8001820:	6902      	ldr	r2, [r0, #16]
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8001822:	0c09      	lsrs	r1, r1, #16
 8001824:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 16U;
 8001828:	040c      	lsls	r4, r1, #16
 800182a:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 800182c:	b10a      	cbz	r2, 8001832 <Vector74+0x22>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 800182e:	6940      	ldr	r0, [r0, #20]
 8001830:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001832:	f001 fdcd 	bl	80033d0 <_dbg_check_leave_isr>
}
 8001836:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800183a:	f7ff bd91 	b.w	8001360 <_port_irq_epilogue>
 800183e:	bf00      	nop
 8001840:	40026000 	.word	0x40026000
 8001844:	200030c8 	.word	0x200030c8
	...

08001850 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8001850:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001852:	f001 fb8d 	bl	8002f70 <_stats_increase_irq>
 8001856:	f001 fdd3 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800185a:	4b09      	ldr	r3, [pc, #36]	; (8001880 <Vector70+0x30>)
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
 800185c:	4809      	ldr	r0, [pc, #36]	; (8001884 <Vector70+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800185e:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
 8001860:	6882      	ldr	r2, [r0, #8]
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8001862:	0989      	lsrs	r1, r1, #6
 8001864:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 6U;
 8001868:	018c      	lsls	r4, r1, #6
 800186a:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 800186c:	b10a      	cbz	r2, 8001872 <Vector70+0x22>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 800186e:	68c0      	ldr	r0, [r0, #12]
 8001870:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001872:	f001 fdad 	bl	80033d0 <_dbg_check_leave_isr>
}
 8001876:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800187a:	f7ff bd71 	b.w	8001360 <_port_irq_epilogue>
 800187e:	bf00      	nop
 8001880:	40026000 	.word	0x40026000
 8001884:	200030c8 	.word	0x200030c8
	...

08001890 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8001890:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001892:	f001 fb6d 	bl	8002f70 <_stats_increase_irq>
 8001896:	f001 fdb3 	bl	8003400 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800189a:	4b08      	ldr	r3, [pc, #32]	; (80018bc <Vector6C+0x2c>)
  DMA1->LIFCR = flags << 0U;
  if (dma_isr_redir[0].dma_func)
 800189c:	4a08      	ldr	r2, [pc, #32]	; (80018c0 <Vector6C+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800189e:	6819      	ldr	r1, [r3, #0]
 80018a0:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 80018a4:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 80018a6:	6813      	ldr	r3, [r2, #0]
 80018a8:	b10b      	cbz	r3, 80018ae <Vector6C+0x1e>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 80018aa:	6850      	ldr	r0, [r2, #4]
 80018ac:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80018ae:	f001 fd8f 	bl	80033d0 <_dbg_check_leave_isr>
}
 80018b2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 0U;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80018b6:	f7ff bd53 	b.w	8001360 <_port_irq_epilogue>
 80018ba:	bf00      	nop
 80018bc:	40026000 	.word	0x40026000
 80018c0:	200030c8 	.word	0x200030c8
	...

080018d0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80018d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80018d4:	4680      	mov	r8, r0
 80018d6:	460e      	mov	r6, r1
  event_listener_t *elp;

  chDbgCheckClassI();
 80018d8:	f001 fc32 	bl	8003140 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 80018dc:	f1b8 0f00 	cmp.w	r8, #0
 80018e0:	d039      	beq.n	8001956 <chEvtBroadcastFlagsI+0x86>

  elp = esp->es_next;
 80018e2:	f8d8 4000 	ldr.w	r4, [r8]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80018e6:	45a0      	cmp	r8, r4
 80018e8:	d026      	beq.n	8001938 <chEvtBroadcastFlagsI+0x68>
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 80018ea:	2700      	movs	r7, #0
 80018ec:	e002      	b.n	80018f4 <chEvtBroadcastFlagsI+0x24>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 80018ee:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80018f0:	45a0      	cmp	r8, r4
 80018f2:	d021      	beq.n	8001938 <chEvtBroadcastFlagsI+0x68>
  /*lint -restore*/
    elp->el_flags |= flags;
 80018f4:	68e3      	ldr	r3, [r4, #12]
 80018f6:	4333      	orrs	r3, r6
 80018f8:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80018fa:	b116      	cbz	r6, 8001902 <chEvtBroadcastFlagsI+0x32>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 80018fc:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80018fe:	4213      	tst	r3, r2
 8001900:	d0f5      	beq.n	80018ee <chEvtBroadcastFlagsI+0x1e>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8001902:	6865      	ldr	r5, [r4, #4]
 8001904:	f8d4 9008 	ldr.w	r9, [r4, #8]
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
 8001908:	f001 fc1a 	bl	8003140 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800190c:	b1f5      	cbz	r5, 800194c <chEvtBroadcastFlagsI+0x7c>

  tp->p_epending |= events;
 800190e:	6bab      	ldr	r3, [r5, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001910:	f895 2020 	ldrb.w	r2, [r5, #32]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001914:	ea49 0303 	orr.w	r3, r9, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001918:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 800191a:	63ab      	str	r3, [r5, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800191c:	d00e      	beq.n	800193c <chEvtBroadcastFlagsI+0x6c>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800191e:	2a0b      	cmp	r2, #11
 8001920:	d1e5      	bne.n	80018ee <chEvtBroadcastFlagsI+0x1e>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8001922:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8001924:	4013      	ands	r3, r2

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8001926:	429a      	cmp	r2, r3
 8001928:	d1e1      	bne.n	80018ee <chEvtBroadcastFlagsI+0x1e>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 800192a:	626f      	str	r7, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 800192c:	4628      	mov	r0, r5
 800192e:	f001 fce7 	bl	8003300 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 8001932:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8001934:	45a0      	cmp	r8, r4
 8001936:	d1dd      	bne.n	80018f4 <chEvtBroadcastFlagsI+0x24>
 8001938:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800193c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800193e:	4213      	tst	r3, r2
 8001940:	d0d5      	beq.n	80018ee <chEvtBroadcastFlagsI+0x1e>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8001942:	626f      	str	r7, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 8001944:	4628      	mov	r0, r5
 8001946:	f001 fcdb 	bl	8003300 <chSchReadyI>
 800194a:	e7f2      	b.n	8001932 <chEvtBroadcastFlagsI+0x62>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800194c:	b672      	cpsid	i
 800194e:	4b04      	ldr	r3, [pc, #16]	; (8001960 <chEvtBroadcastFlagsI+0x90>)
 8001950:	4a04      	ldr	r2, [pc, #16]	; (8001964 <chEvtBroadcastFlagsI+0x94>)
 8001952:	62da      	str	r2, [r3, #44]	; 0x2c
 8001954:	e7fe      	b.n	8001954 <chEvtBroadcastFlagsI+0x84>
 8001956:	b672      	cpsid	i
 8001958:	4b01      	ldr	r3, [pc, #4]	; (8001960 <chEvtBroadcastFlagsI+0x90>)
 800195a:	4a03      	ldr	r2, [pc, #12]	; (8001968 <chEvtBroadcastFlagsI+0x98>)
 800195c:	62da      	str	r2, [r3, #44]	; 0x2c
 800195e:	e7fe      	b.n	800195e <chEvtBroadcastFlagsI+0x8e>
 8001960:	20002740 	.word	0x20002740
 8001964:	08005710 	.word	0x08005710
 8001968:	080056f0 	.word	0x080056f0
 800196c:	00000000 	.word	0x00000000

08001970 <can_lld_rx1_handler.lto_priv.70>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx1_handler(CANDriver *canp) {
 8001970:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
 8001972:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8001974:	691e      	ldr	r6, [r3, #16]
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
 8001976:	07b2      	lsls	r2, r6, #30
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx1_handler(CANDriver *canp) {
 8001978:	4604      	mov	r4, r0
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
 800197a:	d118      	bne.n	80019ae <can_lld_rx1_handler.lto_priv.70+0x3e>
    osalSysLockFromISR();
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(2U));
    osalSysUnlockFromISR();
  }
  if ((rf1r & CAN_RF1R_FOVR1) > 0) {
 800197c:	06f3      	lsls	r3, r6, #27
 800197e:	d515      	bpl.n	80019ac <can_lld_rx1_handler.lto_priv.70+0x3c>
    /* Overflow events handling.*/
    canp->can->RF1R = CAN_RF1R_FOVR1;
 8001980:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001982:	2510      	movs	r5, #16
 8001984:	611d      	str	r5, [r3, #16]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001986:	2320      	movs	r3, #32
 8001988:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 800198c:	f001 fb40 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8001990:	f001 fd66 	bl	8003460 <_dbg_check_lock_from_isr>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001994:	f104 0020 	add.w	r0, r4, #32
 8001998:	4629      	mov	r1, r5
 800199a:	f7ff ff99 	bl	80018d0 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800199e:	f001 fd47 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80019a2:	f001 fb1d 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 80019a6:	2300      	movs	r3, #0
 80019a8:	f383 8811 	msr	BASEPRI, r3
 80019ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE1;
 80019ae:	695a      	ldr	r2, [r3, #20]
 80019b0:	f022 0210 	bic.w	r2, r2, #16
 80019b4:	615a      	str	r2, [r3, #20]
 80019b6:	2320      	movs	r3, #32
 80019b8:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 80019bc:	f001 fb28 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 80019c0:	f001 fd4e 	bl	8003460 <_dbg_check_lock_from_isr>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80019c4:	6920      	ldr	r0, [r4, #16]
    osalSysLockFromISR();
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
 80019c6:	f104 0510 	add.w	r5, r4, #16
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 80019ca:	4285      	cmp	r5, r0
 80019cc:	d01f      	beq.n	8001a0e <can_lld_rx1_handler.lto_priv.70+0x9e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80019ce:	6803      	ldr	r3, [r0, #0]
 80019d0:	6123      	str	r3, [r4, #16]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 80019d2:	f890 2020 	ldrb.w	r2, [r0, #32]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80019d6:	605d      	str	r5, [r3, #4]
 80019d8:	2a04      	cmp	r2, #4
 80019da:	d004      	beq.n	80019e6 <can_lld_rx1_handler.lto_priv.70+0x76>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80019dc:	b672      	cpsid	i
 80019de:	4b12      	ldr	r3, [pc, #72]	; (8001a28 <can_lld_rx1_handler.lto_priv.70+0xb8>)
 80019e0:	4a12      	ldr	r2, [pc, #72]	; (8001a2c <can_lld_rx1_handler.lto_priv.70+0xbc>)
 80019e2:	62da      	str	r2, [r3, #44]	; 0x2c
 80019e4:	e7fe      	b.n	80019e4 <can_lld_rx1_handler.lto_priv.70+0x74>

  tp->p_u.rdymsg = msg;
 80019e6:	2700      	movs	r7, #0
 80019e8:	6247      	str	r7, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 80019ea:	f001 fc89 	bl	8003300 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80019ee:	6920      	ldr	r0, [r4, #16]
 80019f0:	4285      	cmp	r5, r0
 80019f2:	d00c      	beq.n	8001a0e <can_lld_rx1_handler.lto_priv.70+0x9e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80019f4:	6803      	ldr	r3, [r0, #0]
 80019f6:	6123      	str	r3, [r4, #16]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 80019f8:	f890 2020 	ldrb.w	r2, [r0, #32]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80019fc:	605d      	str	r5, [r3, #4]
 80019fe:	2a04      	cmp	r2, #4
 8001a00:	d1ec      	bne.n	80019dc <can_lld_rx1_handler.lto_priv.70+0x6c>

  tp->p_u.rdymsg = msg;
 8001a02:	6247      	str	r7, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8001a04:	f001 fc7c 	bl	8003300 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001a08:	6920      	ldr	r0, [r4, #16]
 8001a0a:	4285      	cmp	r5, r0
 8001a0c:	d1f2      	bne.n	80019f4 <can_lld_rx1_handler.lto_priv.70+0x84>
 8001a0e:	f104 0018 	add.w	r0, r4, #24
 8001a12:	2102      	movs	r1, #2
 8001a14:	f7ff ff5c 	bl	80018d0 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8001a18:	f001 fd0a 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8001a1c:	f001 fae0 	bl	8002fe0 <_stats_stop_measure_crit_isr>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001a20:	2300      	movs	r3, #0
 8001a22:	f383 8811 	msr	BASEPRI, r3
 8001a26:	e7a9      	b.n	800197c <can_lld_rx1_handler.lto_priv.70+0xc>
 8001a28:	20002740 	.word	0x20002740
 8001a2c:	08006b80 	.word	0x08006b80

08001a30 <can_lld_rx0_handler.lto_priv.71>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx0_handler(CANDriver *canp) {
 8001a30:	b538      	push	{r3, r4, r5, lr}
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
 8001a32:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8001a34:	68dd      	ldr	r5, [r3, #12]
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
 8001a36:	07aa      	lsls	r2, r5, #30
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx0_handler(CANDriver *canp) {
 8001a38:	4604      	mov	r4, r0
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
 8001a3a:	d118      	bne.n	8001a6e <can_lld_rx0_handler.lto_priv.71+0x3e>
    osalSysLockFromISR();
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(1U));
    osalSysUnlockFromISR();
  }
  if ((rf0r & CAN_RF0R_FOVR0) > 0) {
 8001a3c:	06eb      	lsls	r3, r5, #27
 8001a3e:	d515      	bpl.n	8001a6c <can_lld_rx0_handler.lto_priv.71+0x3c>
    /* Overflow events handling.*/
    canp->can->RF0R = CAN_RF0R_FOVR0;
 8001a40:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001a42:	2510      	movs	r5, #16
 8001a44:	60dd      	str	r5, [r3, #12]
 8001a46:	2320      	movs	r3, #32
 8001a48:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8001a4c:	f001 fae0 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8001a50:	f001 fd06 	bl	8003460 <_dbg_check_lock_from_isr>
 8001a54:	f104 0020 	add.w	r0, r4, #32
 8001a58:	4629      	mov	r1, r5
 8001a5a:	f7ff ff39 	bl	80018d0 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8001a5e:	f001 fce7 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8001a62:	f001 fabd 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 8001a66:	2300      	movs	r3, #0
 8001a68:	f383 8811 	msr	BASEPRI, r3
 8001a6c:	bd38      	pop	{r3, r4, r5, pc}
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE0;
 8001a6e:	695a      	ldr	r2, [r3, #20]
 8001a70:	f022 0202 	bic.w	r2, r2, #2
 8001a74:	615a      	str	r2, [r3, #20]
 8001a76:	2320      	movs	r3, #32
 8001a78:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8001a7c:	f001 fac8 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8001a80:	f001 fcee 	bl	8003460 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8001a84:	f104 0010 	add.w	r0, r4, #16
 8001a88:	f002 fb4a 	bl	8004120 <chThdDequeueAllI.constprop.39>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001a8c:	f104 0018 	add.w	r0, r4, #24
 8001a90:	2101      	movs	r1, #1
 8001a92:	f7ff ff1d 	bl	80018d0 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8001a96:	f001 fccb 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8001a9a:	f001 faa1 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 8001a9e:	2300      	movs	r3, #0
 8001aa0:	f383 8811 	msr	BASEPRI, r3
 8001aa4:	e7ca      	b.n	8001a3c <can_lld_rx0_handler.lto_priv.71+0xc>
 8001aa6:	bf00      	nop
	...

08001ab0 <can_lld_tx_handler.lto_priv.72>:
static void can_lld_tx_handler(CANDriver *canp) {
  uint32_t tsr;
  eventflags_t flags;

  /* Clearing IRQ sources.*/
  tsr = canp->can->TSR;
 8001ab0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_tx_handler(CANDriver *canp) {
 8001ab2:	b538      	push	{r3, r4, r5, lr}
  uint32_t tsr;
  eventflags_t flags;

  /* Clearing IRQ sources.*/
  tsr = canp->can->TSR;
 8001ab4:	6893      	ldr	r3, [r2, #8]
  canp->can->TSR = tsr;
 8001ab6:	6093      	str	r3, [r2, #8]

  /* Flags to be signaled through the TX event source.*/
  flags = 0U;

  /* Checking mailbox 0.*/
  if ((tsr & CAN_TSR_RQCP0) != 0U) {
 8001ab8:	f013 0401 	ands.w	r4, r3, #1
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_tx_handler(CANDriver *canp) {
 8001abc:	4605      	mov	r5, r0

  /* Flags to be signaled through the TX event source.*/
  flags = 0U;

  /* Checking mailbox 0.*/
  if ((tsr & CAN_TSR_RQCP0) != 0U) {
 8001abe:	d005      	beq.n	8001acc <can_lld_tx_handler.lto_priv.72+0x1c>
    if ((tsr & (CAN_TSR_ALST0 | CAN_TSR_TERR0)) != 0U) {
      flags |= CAN_MAILBOX_TO_MASK(1U) << 16U;
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(1U);
 8001ac0:	f013 0f0c 	tst.w	r3, #12
 8001ac4:	bf14      	ite	ne
 8001ac6:	f44f 3480 	movne.w	r4, #65536	; 0x10000
 8001aca:	2401      	moveq	r4, #1
    }
  }

  /* Checking mailbox 1.*/
  if ((tsr & CAN_TSR_RQCP1) != 0U) {
 8001acc:	05d9      	lsls	r1, r3, #23
 8001ace:	d506      	bpl.n	8001ade <can_lld_tx_handler.lto_priv.72+0x2e>
    if ((tsr & (CAN_TSR_ALST1 | CAN_TSR_TERR1)) != 0U) {
 8001ad0:	f413 6f40 	tst.w	r3, #3072	; 0xc00
      flags |= CAN_MAILBOX_TO_MASK(2U) << 16U;
 8001ad4:	bf14      	ite	ne
 8001ad6:	f444 3400 	orrne.w	r4, r4, #131072	; 0x20000
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(2U);
 8001ada:	f044 0402 	orreq.w	r4, r4, #2
    }
  }

  /* Checking mailbox 2.*/
  if ((tsr & CAN_TSR_RQCP2) != 0U) {
 8001ade:	03da      	lsls	r2, r3, #15
 8001ae0:	d506      	bpl.n	8001af0 <can_lld_tx_handler.lto_priv.72+0x40>
    if ((tsr & (CAN_TSR_ALST2 | CAN_TSR_TERR2)) != 0U) {
 8001ae2:	f413 2f40 	tst.w	r3, #786432	; 0xc0000
      flags |= CAN_MAILBOX_TO_MASK(3U) << 16U;
 8001ae6:	bf14      	ite	ne
 8001ae8:	f444 2480 	orrne.w	r4, r4, #262144	; 0x40000
    }
    else {
      flags |= CAN_MAILBOX_TO_MASK(3U);
 8001aec:	f044 0404 	orreq.w	r4, r4, #4
 8001af0:	2320      	movs	r3, #32
 8001af2:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 8001af6:	f001 fa8b 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8001afa:	f001 fcb1 	bl	8003460 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8001afe:	f105 0008 	add.w	r0, r5, #8
 8001b02:	f002 fb0d 	bl	8004120 <chThdDequeueAllI.constprop.39>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001b06:	f105 001c 	add.w	r0, r5, #28
 8001b0a:	4621      	mov	r1, r4
 8001b0c:	f7ff fee0 	bl	80018d0 <chEvtBroadcastFlagsI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8001b10:	f001 fc8e 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8001b14:	f001 fa64 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 8001b18:	2300      	movs	r3, #0
 8001b1a:	f383 8811 	msr	BASEPRI, r3
 8001b1e:	bd38      	pop	{r3, r4, r5, pc}

08001b20 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8001b20:	b510      	push	{r4, lr}
 8001b22:	2320      	movs	r3, #32
 8001b24:	4604      	mov	r4, r0
 8001b26:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 8001b2a:	f001 fa79 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8001b2e:	f001 fcf7 	bl	8003520 <_dbg_check_lock>
 * @iclass
 */
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();
 8001b32:	f001 fb05 	bl	8003140 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8001b36:	4812      	ldr	r0, [pc, #72]	; (8001b80 <chCoreAlloc+0x60>)
 8001b38:	4b12      	ldr	r3, [pc, #72]	; (8001b84 <chCoreAlloc+0x64>)
 8001b3a:	6802      	ldr	r2, [r0, #0]
 8001b3c:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8001b3e:	1de3      	adds	r3, r4, #7
 8001b40:	f023 0307 	bic.w	r3, r3, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8001b44:	1a89      	subs	r1, r1, r2
 8001b46:	428b      	cmp	r3, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 8001b48:	bf9d      	ittte	ls
 8001b4a:	189b      	addls	r3, r3, r2
 8001b4c:	6003      	strls	r3, [r0, #0]

  return p;
 8001b4e:	4614      	movls	r4, r2

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 8001b50:	2400      	movhi	r4, #0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001b52:	f001 fcd5 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001b56:	f001 fa4b 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001b5a:	4b0b      	ldr	r3, [pc, #44]	; (8001b88 <chCoreAlloc+0x68>)
 8001b5c:	681a      	ldr	r2, [r3, #0]
 8001b5e:	429a      	cmp	r2, r3
 8001b60:	d004      	beq.n	8001b6c <chCoreAlloc+0x4c>
 8001b62:	6999      	ldr	r1, [r3, #24]
 8001b64:	6892      	ldr	r2, [r2, #8]
 8001b66:	6889      	ldr	r1, [r1, #8]
 8001b68:	4291      	cmp	r1, r2
 8001b6a:	d304      	bcc.n	8001b76 <chCoreAlloc+0x56>
 8001b6c:	2300      	movs	r3, #0
 8001b6e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 8001b72:	4620      	mov	r0, r4
 8001b74:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001b76:	b672      	cpsid	i
 8001b78:	4a04      	ldr	r2, [pc, #16]	; (8001b8c <chCoreAlloc+0x6c>)
 8001b7a:	62da      	str	r2, [r3, #44]	; 0x2c
 8001b7c:	e7fe      	b.n	8001b7c <chCoreAlloc+0x5c>
 8001b7e:	bf00      	nop
 8001b80:	20000808 	.word	0x20000808
 8001b84:	20002000 	.word	0x20002000
 8001b88:	20002740 	.word	0x20002740
 8001b8c:	08005750 	.word	0x08005750

08001b90 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8001b90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001b94:	b083      	sub	sp, #12
 8001b96:	4683      	mov	fp, r0
 8001b98:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 8001b9a:	f8d0 901c 	ldr.w	r9, [r0, #28]
  size_t w = 0;

  chDbgCheck(n > 0U);
 8001b9e:	4617      	mov	r7, r2
 8001ba0:	2a00      	cmp	r2, #0
 8001ba2:	d06e      	beq.n	8001c82 <chOQWriteTimeout+0xf2>
 8001ba4:	4688      	mov	r8, r1

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001ba6:	2620      	movs	r6, #32
 8001ba8:	f386 8811 	msr	BASEPRI, r6
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 8001bac:	f001 fa38 	bl	8003020 <_stats_start_measure_crit_thd>
 8001bb0:	4c38      	ldr	r4, [pc, #224]	; (8001c94 <chOQWriteTimeout+0x104>)
  _dbg_check_lock();
 8001bb2:	f001 fcb5 	bl	8003520 <_dbg_check_lock>
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
 8001bb6:	2500      	movs	r5, #0

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001bb8:	46a2      	mov	sl, r4
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8001bba:	f001 fac1 	bl	8003140 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 8001bbe:	f8db 3008 	ldr.w	r3, [fp, #8]
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 8001bc2:	4658      	mov	r0, fp

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8001bc4:	2b00      	cmp	r3, #0
 8001bc6:	d03e      	beq.n	8001c46 <chOQWriteTimeout+0xb6>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001bc8:	f8db 2014 	ldr.w	r2, [fp, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8001bcc:	f8db 3008 	ldr.w	r3, [fp, #8]
    *oqp->q_wrptr++ = *bp++;
 8001bd0:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8001bd2:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 8001bd4:	f8cb 1014 	str.w	r1, [fp, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8001bd8:	f8cb 3008 	str.w	r3, [fp, #8]
    *oqp->q_wrptr++ = *bp++;
 8001bdc:	f898 3000 	ldrb.w	r3, [r8]
 8001be0:	7013      	strb	r3, [r2, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8001be2:	f8db 3010 	ldr.w	r3, [fp, #16]
 8001be6:	f8db 2014 	ldr.w	r2, [fp, #20]
 8001bea:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8001bec:	bf24      	itt	cs
 8001bee:	f8db 300c 	ldrcs.w	r3, [fp, #12]
 8001bf2:	f8cb 3014 	strcs.w	r3, [fp, #20]
    }

    if (nfy != NULL) {
 8001bf6:	f1b9 0f00 	cmp.w	r9, #0
 8001bfa:	d000      	beq.n	8001bfe <chOQWriteTimeout+0x6e>
      nfy(oqp);
 8001bfc:	47c8      	blx	r9
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001bfe:	f001 fc7f 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001c02:	f001 f9f5 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001c06:	6823      	ldr	r3, [r4, #0]
 8001c08:	4a22      	ldr	r2, [pc, #136]	; (8001c94 <chOQWriteTimeout+0x104>)
 8001c0a:	42a3      	cmp	r3, r4
 8001c0c:	d005      	beq.n	8001c1a <chOQWriteTimeout+0x8a>
 8001c0e:	f8da 1018 	ldr.w	r1, [sl, #24]
 8001c12:	689b      	ldr	r3, [r3, #8]
 8001c14:	6889      	ldr	r1, [r1, #8]
 8001c16:	4299      	cmp	r1, r3
 8001c18:	d32f      	bcc.n	8001c7a <chOQWriteTimeout+0xea>
 8001c1a:	2300      	movs	r3, #0
 8001c1c:	f383 8811 	msr	BASEPRI, r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 8001c20:	3f01      	subs	r7, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 8001c22:	f105 0501 	add.w	r5, r5, #1
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001c26:	f108 0801 	add.w	r8, r8, #1
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 8001c2a:	d022      	beq.n	8001c72 <chOQWriteTimeout+0xe2>
 8001c2c:	f386 8811 	msr	BASEPRI, r6
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 8001c30:	f001 f9f6 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8001c34:	f001 fc74 	bl	8003520 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8001c38:	f001 fa82 	bl	8003140 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 8001c3c:	f8db 3008 	ldr.w	r3, [fp, #8]
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 8001c40:	4658      	mov	r0, fp

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8001c42:	2b00      	cmp	r3, #0
 8001c44:	d1c0      	bne.n	8001bc8 <chOQWriteTimeout+0x38>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8001c46:	4658      	mov	r0, fp
 8001c48:	9901      	ldr	r1, [sp, #4]
 8001c4a:	f001 fb41 	bl	80032d0 <chThdEnqueueTimeoutS>
 8001c4e:	2800      	cmp	r0, #0
 8001c50:	d0b3      	beq.n	8001bba <chOQWriteTimeout+0x2a>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001c52:	f001 fc55 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001c56:	f001 f9cb 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001c5a:	6822      	ldr	r2, [r4, #0]
 8001c5c:	4b0d      	ldr	r3, [pc, #52]	; (8001c94 <chOQWriteTimeout+0x104>)
 8001c5e:	42a2      	cmp	r2, r4
 8001c60:	d004      	beq.n	8001c6c <chOQWriteTimeout+0xdc>
 8001c62:	6999      	ldr	r1, [r3, #24]
 8001c64:	6892      	ldr	r2, [r2, #8]
 8001c66:	6889      	ldr	r1, [r1, #8]
 8001c68:	4291      	cmp	r1, r2
 8001c6a:	d30f      	bcc.n	8001c8c <chOQWriteTimeout+0xfc>
 8001c6c:	2300      	movs	r3, #0
 8001c6e:	f383 8811 	msr	BASEPRI, r3
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 8001c72:	4628      	mov	r0, r5
 8001c74:	b003      	add	sp, #12
 8001c76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c7a:	b672      	cpsid	i
 8001c7c:	4b06      	ldr	r3, [pc, #24]	; (8001c98 <chOQWriteTimeout+0x108>)
 8001c7e:	62d3      	str	r3, [r2, #44]	; 0x2c
 8001c80:	e7fe      	b.n	8001c80 <chOQWriteTimeout+0xf0>
 8001c82:	b672      	cpsid	i
 8001c84:	4b03      	ldr	r3, [pc, #12]	; (8001c94 <chOQWriteTimeout+0x104>)
 8001c86:	4a05      	ldr	r2, [pc, #20]	; (8001c9c <chOQWriteTimeout+0x10c>)
 8001c88:	62da      	str	r2, [r3, #44]	; 0x2c
 8001c8a:	e7fe      	b.n	8001c8a <chOQWriteTimeout+0xfa>
 8001c8c:	b672      	cpsid	i
 8001c8e:	4a02      	ldr	r2, [pc, #8]	; (8001c98 <chOQWriteTimeout+0x108>)
 8001c90:	62da      	str	r2, [r3, #44]	; 0x2c
 8001c92:	e7fe      	b.n	8001c92 <chOQWriteTimeout+0x102>
 8001c94:	20002740 	.word	0x20002740
 8001c98:	08005740 	.word	0x08005740
 8001c9c:	08005760 	.word	0x08005760

08001ca0 <writet.lto_priv.65>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8001ca0:	3030      	adds	r0, #48	; 0x30
 8001ca2:	f7ff bf75 	b.w	8001b90 <chOQWriteTimeout>
 8001ca6:	bf00      	nop
	...

08001cb0 <write.lto_priv.59>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8001cb0:	3030      	adds	r0, #48	; 0x30
 8001cb2:	f04f 33ff 	mov.w	r3, #4294967295
 8001cb6:	f7ff bf6b 	b.w	8001b90 <chOQWriteTimeout>
 8001cba:	bf00      	nop
 8001cbc:	0000      	movs	r0, r0
	...

08001cc0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8001cc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001cc2:	4604      	mov	r4, r0
 8001cc4:	460f      	mov	r7, r1
 8001cc6:	4616      	mov	r6, r2

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001cc8:	2320      	movs	r3, #32
 8001cca:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 8001cce:	f001 f9a7 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8001cd2:	f001 fc25 	bl	8003520 <_dbg_check_lock>
 8001cd6:	e003      	b.n	8001ce0 <chOQPutTimeout+0x20>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8001cd8:	f001 fafa 	bl	80032d0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8001cdc:	1e05      	subs	r5, r0, #0
 8001cde:	db28      	blt.n	8001d32 <chOQPutTimeout+0x72>
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();
 8001ce0:	f001 fa2e 	bl	8003140 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 8001ce4:	68a3      	ldr	r3, [r4, #8]
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8001ce6:	4620      	mov	r0, r4
 8001ce8:	4631      	mov	r1, r6
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8001cea:	2b00      	cmp	r3, #0
 8001cec:	d0f4      	beq.n	8001cd8 <chOQPutTimeout+0x18>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8001cee:	6962      	ldr	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8001cf0:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8001cf2:	1c51      	adds	r1, r2, #1
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8001cf4:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8001cf6:	6161      	str	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8001cf8:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8001cfa:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8001cfc:	6923      	ldr	r3, [r4, #16]
 8001cfe:	6962      	ldr	r2, [r4, #20]
 8001d00:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8001d02:	bf24      	itt	cs
 8001d04:	68e3      	ldrcs	r3, [r4, #12]
 8001d06:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 8001d08:	69e3      	ldr	r3, [r4, #28]
 8001d0a:	b10b      	cbz	r3, 8001d10 <chOQPutTimeout+0x50>
    oqp->q_notify(oqp);
 8001d0c:	4620      	mov	r0, r4
 8001d0e:	4798      	blx	r3
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001d10:	f001 fbf6 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001d14:	f001 f96c 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001d18:	4b13      	ldr	r3, [pc, #76]	; (8001d68 <chOQPutTimeout+0xa8>)
 8001d1a:	681a      	ldr	r2, [r3, #0]
 8001d1c:	429a      	cmp	r2, r3
 8001d1e:	d004      	beq.n	8001d2a <chOQPutTimeout+0x6a>
 8001d20:	6999      	ldr	r1, [r3, #24]
 8001d22:	6892      	ldr	r2, [r2, #8]
 8001d24:	6889      	ldr	r1, [r1, #8]
 8001d26:	4291      	cmp	r1, r2
 8001d28:	d319      	bcc.n	8001d5e <chOQPutTimeout+0x9e>
 8001d2a:	2000      	movs	r0, #0
 8001d2c:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 8001d30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001d32:	f001 fbe5 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001d36:	f001 f95b 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001d3a:	4b0b      	ldr	r3, [pc, #44]	; (8001d68 <chOQPutTimeout+0xa8>)
 8001d3c:	681a      	ldr	r2, [r3, #0]
 8001d3e:	429a      	cmp	r2, r3
 8001d40:	d004      	beq.n	8001d4c <chOQPutTimeout+0x8c>
 8001d42:	6999      	ldr	r1, [r3, #24]
 8001d44:	6892      	ldr	r2, [r2, #8]
 8001d46:	6889      	ldr	r1, [r1, #8]
 8001d48:	4291      	cmp	r1, r2
 8001d4a:	d304      	bcc.n	8001d56 <chOQPutTimeout+0x96>
 8001d4c:	2300      	movs	r3, #0
 8001d4e:	f383 8811 	msr	BASEPRI, r3
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8001d52:	4628      	mov	r0, r5
 8001d54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001d56:	b672      	cpsid	i
 8001d58:	4a04      	ldr	r2, [pc, #16]	; (8001d6c <chOQPutTimeout+0xac>)
 8001d5a:	62da      	str	r2, [r3, #44]	; 0x2c
 8001d5c:	e7fe      	b.n	8001d5c <chOQPutTimeout+0x9c>
 8001d5e:	b672      	cpsid	i
 8001d60:	4a02      	ldr	r2, [pc, #8]	; (8001d6c <chOQPutTimeout+0xac>)
 8001d62:	62da      	str	r2, [r3, #44]	; 0x2c
 8001d64:	e7fe      	b.n	8001d64 <chOQPutTimeout+0xa4>
 8001d66:	bf00      	nop
 8001d68:	20002740 	.word	0x20002740
 8001d6c:	08005740 	.word	0x08005740

08001d70 <putt.lto_priv.63>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8001d70:	3030      	adds	r0, #48	; 0x30
 8001d72:	f7ff bfa5 	b.w	8001cc0 <chOQPutTimeout>
 8001d76:	bf00      	nop
	...

08001d80 <put.lto_priv.61>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8001d80:	3030      	adds	r0, #48	; 0x30
 8001d82:	f04f 32ff 	mov.w	r2, #4294967295
 8001d86:	f7ff bf9b 	b.w	8001cc0 <chOQPutTimeout>
 8001d8a:	bf00      	nop
 8001d8c:	0000      	movs	r0, r0
	...

08001d90 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8001d90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001d94:	b083      	sub	sp, #12
 8001d96:	4699      	mov	r9, r3
  qnotify_t nfy = iqp->q_notify;
 8001d98:	69c3      	ldr	r3, [r0, #28]
 8001d9a:	9301      	str	r3, [sp, #4]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8001d9c:	4682      	mov	sl, r0
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;

  chDbgCheck(n > 0U);
 8001d9e:	4614      	mov	r4, r2
 8001da0:	2a00      	cmp	r2, #0
 8001da2:	d065      	beq.n	8001e70 <chIQReadTimeout+0xe0>
 8001da4:	460e      	mov	r6, r1

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001da6:	f04f 0820 	mov.w	r8, #32
 8001daa:	f388 8811 	msr	BASEPRI, r8
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 8001dae:	f001 f937 	bl	8003020 <_stats_start_measure_crit_thd>
 8001db2:	4d36      	ldr	r5, [pc, #216]	; (8001e8c <chIQReadTimeout+0xfc>)
  _dbg_check_lock();
 8001db4:	f001 fbb4 	bl	8003520 <_dbg_check_lock>
 8001db8:	3c01      	subs	r4, #1
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
 8001dba:	2700      	movs	r7, #0
 8001dbc:	4434      	add	r4, r6

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001dbe:	46ab      	mov	fp, r5

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 8001dc0:	9b01      	ldr	r3, [sp, #4]
 8001dc2:	b133      	cbz	r3, 8001dd2 <chIQReadTimeout+0x42>
      nfy(iqp);
 8001dc4:	4650      	mov	r0, sl
 8001dc6:	4798      	blx	r3
 8001dc8:	e003      	b.n	8001dd2 <chIQReadTimeout+0x42>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8001dca:	f001 fa81 	bl	80032d0 <chThdEnqueueTimeoutS>
 8001dce:	2800      	cmp	r0, #0
 8001dd0:	d13a      	bne.n	8001e48 <chIQReadTimeout+0xb8>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8001dd2:	f001 f9b5 	bl	8003140 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8001dd6:	f8da 3008 	ldr.w	r3, [sl, #8]
 8001dda:	4650      	mov	r0, sl
 8001ddc:	4649      	mov	r1, r9
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8001dde:	2b00      	cmp	r3, #0
 8001de0:	d0f3      	beq.n	8001dca <chIQReadTimeout+0x3a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8001de2:	f8da 2018 	ldr.w	r2, [sl, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001de6:	f8da 3008 	ldr.w	r3, [sl, #8]
    *bp++ = *iqp->q_rdptr++;
 8001dea:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001dec:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 8001dee:	f8ca 1018 	str.w	r1, [sl, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001df2:	f8ca 3008 	str.w	r3, [sl, #8]
    *bp++ = *iqp->q_rdptr++;
 8001df6:	7813      	ldrb	r3, [r2, #0]
 8001df8:	7033      	strb	r3, [r6, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 8001dfa:	f8da 3010 	ldr.w	r3, [sl, #16]
 8001dfe:	f8da 2018 	ldr.w	r2, [sl, #24]
 8001e02:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8001e04:	bf24      	itt	cs
 8001e06:	f8da 300c 	ldrcs.w	r3, [sl, #12]
 8001e0a:	f8ca 3018 	strcs.w	r3, [sl, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001e0e:	f001 fb77 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001e12:	f001 f8ed 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001e16:	682b      	ldr	r3, [r5, #0]
 8001e18:	4a1c      	ldr	r2, [pc, #112]	; (8001e8c <chIQReadTimeout+0xfc>)
 8001e1a:	42ab      	cmp	r3, r5
 8001e1c:	d005      	beq.n	8001e2a <chIQReadTimeout+0x9a>
 8001e1e:	f8db 1018 	ldr.w	r1, [fp, #24]
 8001e22:	689b      	ldr	r3, [r3, #8]
 8001e24:	6889      	ldr	r1, [r1, #8]
 8001e26:	4299      	cmp	r1, r3
 8001e28:	d327      	bcc.n	8001e7a <chIQReadTimeout+0xea>
 8001e2a:	2300      	movs	r3, #0
 8001e2c:	f383 8811 	msr	BASEPRI, r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
    if (--n == 0U) {
 8001e30:	42a6      	cmp	r6, r4
    if (iqp->q_rdptr >= iqp->q_top) {
      iqp->q_rdptr = iqp->q_buffer;
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 8001e32:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
 8001e36:	d017      	beq.n	8001e68 <chIQReadTimeout+0xd8>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8001e38:	3601      	adds	r6, #1
 8001e3a:	f388 8811 	msr	BASEPRI, r8
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 8001e3e:	f001 f8ef 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8001e42:	f001 fb6d 	bl	8003520 <_dbg_check_lock>
 8001e46:	e7bb      	b.n	8001dc0 <chIQReadTimeout+0x30>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001e48:	f001 fb5a 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001e4c:	f001 f8d0 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001e50:	682a      	ldr	r2, [r5, #0]
 8001e52:	4b0e      	ldr	r3, [pc, #56]	; (8001e8c <chIQReadTimeout+0xfc>)
 8001e54:	42aa      	cmp	r2, r5
 8001e56:	d004      	beq.n	8001e62 <chIQReadTimeout+0xd2>
 8001e58:	6999      	ldr	r1, [r3, #24]
 8001e5a:	6892      	ldr	r2, [r2, #8]
 8001e5c:	6889      	ldr	r1, [r1, #8]
 8001e5e:	4291      	cmp	r1, r2
 8001e60:	d30f      	bcc.n	8001e82 <chIQReadTimeout+0xf2>
 8001e62:	2300      	movs	r3, #0
 8001e64:	f383 8811 	msr	BASEPRI, r3
      return r;
    }

    chSysLock();
  }
}
 8001e68:	4638      	mov	r0, r7
 8001e6a:	b003      	add	sp, #12
 8001e6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001e70:	b672      	cpsid	i
 8001e72:	4b06      	ldr	r3, [pc, #24]	; (8001e8c <chIQReadTimeout+0xfc>)
 8001e74:	4a06      	ldr	r2, [pc, #24]	; (8001e90 <chIQReadTimeout+0x100>)
 8001e76:	62da      	str	r2, [r3, #44]	; 0x2c
 8001e78:	e7fe      	b.n	8001e78 <chIQReadTimeout+0xe8>
 8001e7a:	b672      	cpsid	i
 8001e7c:	4b05      	ldr	r3, [pc, #20]	; (8001e94 <chIQReadTimeout+0x104>)
 8001e7e:	62d3      	str	r3, [r2, #44]	; 0x2c
 8001e80:	e7fe      	b.n	8001e80 <chIQReadTimeout+0xf0>
 8001e82:	b672      	cpsid	i
 8001e84:	4a03      	ldr	r2, [pc, #12]	; (8001e94 <chIQReadTimeout+0x104>)
 8001e86:	62da      	str	r2, [r3, #44]	; 0x2c
 8001e88:	e7fe      	b.n	8001e88 <chIQReadTimeout+0xf8>
 8001e8a:	bf00      	nop
 8001e8c:	20002740 	.word	0x20002740
 8001e90:	080056e0 	.word	0x080056e0
 8001e94:	08005740 	.word	0x08005740
	...

08001ea0 <readt.lto_priv.66>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8001ea0:	300c      	adds	r0, #12
 8001ea2:	f7ff bf75 	b.w	8001d90 <chIQReadTimeout>
 8001ea6:	bf00      	nop
	...

08001eb0 <read.lto_priv.60>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001eb0:	300c      	adds	r0, #12
 8001eb2:	f04f 33ff 	mov.w	r3, #4294967295
 8001eb6:	f7ff bf6b 	b.w	8001d90 <chIQReadTimeout>
 8001eba:	bf00      	nop
 8001ebc:	0000      	movs	r0, r0
	...

08001ec0 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8001ec0:	b570      	push	{r4, r5, r6, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001ec2:	2320      	movs	r3, #32
 8001ec4:	4604      	mov	r4, r0
 8001ec6:	460e      	mov	r6, r1
 8001ec8:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 8001ecc:	f001 f8a8 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8001ed0:	f001 fb26 	bl	8003520 <_dbg_check_lock>
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 8001ed4:	69e3      	ldr	r3, [r4, #28]
 8001ed6:	b133      	cbz	r3, 8001ee6 <chIQGetTimeout+0x26>
    iqp->q_notify(iqp);
 8001ed8:	4620      	mov	r0, r4
 8001eda:	4798      	blx	r3
 8001edc:	e003      	b.n	8001ee6 <chIQGetTimeout+0x26>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8001ede:	f001 f9f7 	bl	80032d0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8001ee2:	1e05      	subs	r5, r0, #0
 8001ee4:	db25      	blt.n	8001f32 <chIQGetTimeout+0x72>
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();
 8001ee6:	f001 f92b 	bl	8003140 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8001eea:	68a3      	ldr	r3, [r4, #8]
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8001eec:	4620      	mov	r0, r4
 8001eee:	4631      	mov	r1, r6
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8001ef0:	2b00      	cmp	r3, #0
 8001ef2:	d0f4      	beq.n	8001ede <chIQGetTimeout+0x1e>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001ef4:	69a1      	ldr	r1, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001ef6:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8001ef8:	6920      	ldr	r0, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001efa:	1c4a      	adds	r2, r1, #1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001efc:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8001efe:	4282      	cmp	r2, r0
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001f00:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8001f02:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8001f04:	bf28      	it	cs
 8001f06:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001f08:	780d      	ldrb	r5, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8001f0a:	bf28      	it	cs
 8001f0c:	61a3      	strcs	r3, [r4, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001f0e:	f001 faf7 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001f12:	f001 f86d 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001f16:	4b11      	ldr	r3, [pc, #68]	; (8001f5c <chIQGetTimeout+0x9c>)
 8001f18:	681a      	ldr	r2, [r3, #0]
 8001f1a:	429a      	cmp	r2, r3
 8001f1c:	d004      	beq.n	8001f28 <chIQGetTimeout+0x68>
 8001f1e:	6999      	ldr	r1, [r3, #24]
 8001f20:	6892      	ldr	r2, [r2, #8]
 8001f22:	6889      	ldr	r1, [r1, #8]
 8001f24:	4291      	cmp	r1, r2
 8001f26:	d315      	bcc.n	8001f54 <chIQGetTimeout+0x94>
 8001f28:	2300      	movs	r3, #0
 8001f2a:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return (msg_t)b;
 8001f2e:	4628      	mov	r0, r5
}
 8001f30:	bd70      	pop	{r4, r5, r6, pc}
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001f32:	f001 fae5 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001f36:	f001 f85b 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8001f3a:	4b08      	ldr	r3, [pc, #32]	; (8001f5c <chIQGetTimeout+0x9c>)
 8001f3c:	681a      	ldr	r2, [r3, #0]
 8001f3e:	429a      	cmp	r2, r3
 8001f40:	d0f2      	beq.n	8001f28 <chIQGetTimeout+0x68>
 8001f42:	6999      	ldr	r1, [r3, #24]
 8001f44:	6892      	ldr	r2, [r2, #8]
 8001f46:	6889      	ldr	r1, [r1, #8]
 8001f48:	4291      	cmp	r1, r2
 8001f4a:	d2ed      	bcs.n	8001f28 <chIQGetTimeout+0x68>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001f4c:	b672      	cpsid	i
 8001f4e:	4a04      	ldr	r2, [pc, #16]	; (8001f60 <chIQGetTimeout+0xa0>)
 8001f50:	62da      	str	r2, [r3, #44]	; 0x2c
 8001f52:	e7fe      	b.n	8001f52 <chIQGetTimeout+0x92>
 8001f54:	b672      	cpsid	i
 8001f56:	4a02      	ldr	r2, [pc, #8]	; (8001f60 <chIQGetTimeout+0xa0>)
 8001f58:	62da      	str	r2, [r3, #44]	; 0x2c
 8001f5a:	e7fe      	b.n	8001f5a <chIQGetTimeout+0x9a>
 8001f5c:	20002740 	.word	0x20002740
 8001f60:	08005740 	.word	0x08005740
	...

08001f70 <gett.lto_priv.64>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001f70:	300c      	adds	r0, #12
 8001f72:	f7ff bfa5 	b.w	8001ec0 <chIQGetTimeout>
 8001f76:	bf00      	nop
	...

08001f80 <get.lto_priv.62>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001f80:	300c      	adds	r0, #12
 8001f82:	f04f 31ff 	mov.w	r1, #4294967295
 8001f86:	f7ff bf9b 	b.w	8001ec0 <chIQGetTimeout>
 8001f8a:	bf00      	nop
 8001f8c:	0000      	movs	r0, r0
	...

08001f90 <get.lto_priv.52>:

static msg_t get(void *ip) {
  uint8_t b;
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset <= 0)
 8001f90:	6903      	ldr	r3, [r0, #16]
 8001f92:	68c1      	ldr	r1, [r0, #12]
 8001f94:	4299      	cmp	r1, r3
  *(msp->buffer + msp->eos) = b;
  msp->eos += 1;
  return MSG_OK;
}

static msg_t get(void *ip) {
 8001f96:	4602      	mov	r2, r0
  uint8_t b;
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset <= 0)
 8001f98:	d004      	beq.n	8001fa4 <get.lto_priv.52+0x14>
    return MSG_RESET;
  b = *(msp->buffer + msp->offset);
 8001f9a:	6841      	ldr	r1, [r0, #4]
 8001f9c:	5cc8      	ldrb	r0, [r1, r3]
  msp->offset += 1;
 8001f9e:	3301      	adds	r3, #1
 8001fa0:	6113      	str	r3, [r2, #16]
 8001fa2:	4770      	bx	lr
static msg_t get(void *ip) {
  uint8_t b;
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset <= 0)
    return MSG_RESET;
 8001fa4:	f06f 0001 	mvn.w	r0, #1
  b = *(msp->buffer + msp->offset);
  msp->offset += 1;
  return b;
}
 8001fa8:	4770      	bx	lr
 8001faa:	bf00      	nop
 8001fac:	0000      	movs	r0, r0
	...

08001fb0 <put.lto_priv.51>:
}

static msg_t put(void *ip, uint8_t b) {
  MemoryStream *msp = ip;

  if (msp->size - msp->eos <= 0)
 8001fb0:	68c3      	ldr	r3, [r0, #12]
 8001fb2:	6882      	ldr	r2, [r0, #8]
 8001fb4:	429a      	cmp	r2, r3
 8001fb6:	d006      	beq.n	8001fc6 <put.lto_priv.51+0x16>
    return MSG_RESET;
  *(msp->buffer + msp->eos) = b;
 8001fb8:	6842      	ldr	r2, [r0, #4]
 8001fba:	54d1      	strb	r1, [r2, r3]
  msp->eos += 1;
 8001fbc:	68c3      	ldr	r3, [r0, #12]
 8001fbe:	3301      	adds	r3, #1
 8001fc0:	60c3      	str	r3, [r0, #12]
  return MSG_OK;
 8001fc2:	2000      	movs	r0, #0
 8001fc4:	4770      	bx	lr

static msg_t put(void *ip, uint8_t b) {
  MemoryStream *msp = ip;

  if (msp->size - msp->eos <= 0)
    return MSG_RESET;
 8001fc6:	f06f 0001 	mvn.w	r0, #1
  *(msp->buffer + msp->eos) = b;
  msp->eos += 1;
  return MSG_OK;
}
 8001fca:	4770      	bx	lr
 8001fcc:	0000      	movs	r0, r0
	...

08001fd0 <reads.lto_priv.50>:
  memcpy(msp->buffer + msp->eos, bp, n);
  msp->eos += n;
  return n;
}

static size_t reads(void *ip, uint8_t *bp, size_t n) {
 8001fd0:	b538      	push	{r3, r4, r5, lr}
 8001fd2:	4605      	mov	r5, r0
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset < n)
    n = msp->eos - msp->offset;
  memcpy(bp, msp->buffer + msp->offset, n);
 8001fd4:	4608      	mov	r0, r1
}

static size_t reads(void *ip, uint8_t *bp, size_t n) {
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset < n)
 8001fd6:	692b      	ldr	r3, [r5, #16]
 8001fd8:	68ec      	ldr	r4, [r5, #12]
    n = msp->eos - msp->offset;
  memcpy(bp, msp->buffer + msp->offset, n);
 8001fda:	6869      	ldr	r1, [r5, #4]
}

static size_t reads(void *ip, uint8_t *bp, size_t n) {
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset < n)
 8001fdc:	1ae4      	subs	r4, r4, r3
 8001fde:	4294      	cmp	r4, r2
 8001fe0:	bf28      	it	cs
 8001fe2:	4614      	movcs	r4, r2
    n = msp->eos - msp->offset;
  memcpy(bp, msp->buffer + msp->offset, n);
 8001fe4:	4419      	add	r1, r3
 8001fe6:	4622      	mov	r2, r4
 8001fe8:	f7fe f99a 	bl	8000320 <memcpy>
  msp->offset += n;
 8001fec:	692b      	ldr	r3, [r5, #16]
 8001fee:	4423      	add	r3, r4
 8001ff0:	612b      	str	r3, [r5, #16]
  return n;
}
 8001ff2:	4620      	mov	r0, r4
 8001ff4:	bd38      	pop	{r3, r4, r5, pc}
 8001ff6:	bf00      	nop
	...

08002000 <writes.lto_priv.49>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 8002000:	b538      	push	{r3, r4, r5, lr}
  MemoryStream *msp = ip;

  if (msp->size - msp->eos < n)
 8002002:	68c3      	ldr	r3, [r0, #12]
 8002004:	6884      	ldr	r4, [r0, #8]
 8002006:	1ae4      	subs	r4, r4, r3

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 8002008:	4605      	mov	r5, r0
 800200a:	4294      	cmp	r4, r2
  MemoryStream *msp = ip;

  if (msp->size - msp->eos < n)
    n = msp->size - msp->eos;
  memcpy(msp->buffer + msp->eos, bp, n);
 800200c:	6840      	ldr	r0, [r0, #4]
 800200e:	bf28      	it	cs
 8002010:	4614      	movcs	r4, r2
 8002012:	4418      	add	r0, r3
 8002014:	4622      	mov	r2, r4
 8002016:	f7fe f983 	bl	8000320 <memcpy>
  msp->eos += n;
 800201a:	68eb      	ldr	r3, [r5, #12]
 800201c:	4423      	add	r3, r4
 800201e:	60eb      	str	r3, [r5, #12]
  return n;
}
 8002020:	4620      	mov	r0, r4
 8002022:	bd38      	pop	{r3, r4, r5, pc}
	...

08002030 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8002030:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002034:	b087      	sub	sp, #28
 8002036:	4615      	mov	r5, r2
 8002038:	f10d 030d 	add.w	r3, sp, #13
 800203c:	aa03      	add	r2, sp, #12
 800203e:	1a9b      	subs	r3, r3, r2
 8002040:	4681      	mov	r9, r0
 8002042:	468a      	mov	sl, r1
 8002044:	9301      	str	r3, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8002046:	f04f 0800 	mov.w	r8, #0
 800204a:	468b      	mov	fp, r1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800204c:	f89b 1000 	ldrb.w	r1, [fp]
 8002050:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 8002054:	b179      	cbz	r1, 8002076 <chvprintf+0x46>
      return n;
    if (c != '%') {
 8002056:	2925      	cmp	r1, #37	; 0x25
 8002058:	d011      	beq.n	800207e <chvprintf+0x4e>
      streamPut(chp, (uint8_t)c);
 800205a:	f8d9 2000 	ldr.w	r2, [r9]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800205e:	469b      	mov	fp, r3
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 8002060:	6892      	ldr	r2, [r2, #8]
 8002062:	4648      	mov	r0, r9
 8002064:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8002066:	f89b 1000 	ldrb.w	r1, [fp]
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
 800206a:	f108 0801 	add.w	r8, r8, #1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800206e:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 8002072:	2900      	cmp	r1, #0
 8002074:	d1ef      	bne.n	8002056 <chvprintf+0x26>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 8002076:	4640      	mov	r0, r8
 8002078:	b007      	add	sp, #28
 800207a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 800207e:	f89b 2001 	ldrb.w	r2, [fp, #1]
 8002082:	2a2d      	cmp	r2, #45	; 0x2d
 8002084:	bf03      	ittte	eq
 8002086:	f89b 2002 	ldrbeq.w	r2, [fp, #2]
      fmt++;
 800208a:	f10b 0302 	addeq.w	r3, fp, #2
      left_align = TRUE;
 800208e:	f04f 0a01 	moveq.w	sl, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 8002092:	f04f 0a00 	movne.w	sl, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 8002096:	2a30      	cmp	r2, #48	; 0x30
 8002098:	bf03      	ittte	eq
 800209a:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 800209c:	3301      	addeq	r3, #1
      filler = '0';
 800209e:	2730      	moveq	r7, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 80020a0:	2720      	movne	r7, #32
 80020a2:	1c59      	adds	r1, r3, #1
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 80020a4:	2600      	movs	r6, #0
 80020a6:	e006      	b.n	80020b6 <chvprintf+0x86>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 80020a8:	782b      	ldrb	r3, [r5, #0]
 80020aa:	3504      	adds	r5, #4
 80020ac:	f89b 2000 	ldrb.w	r2, [fp]
      else
        break;
      width = width * 10 + c;
 80020b0:	eb03 0640 	add.w	r6, r3, r0, lsl #1
 80020b4:	3101      	adds	r1, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 80020b6:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 80020ba:	b2db      	uxtb	r3, r3
 80020bc:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 80020be:	468b      	mov	fp, r1
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 80020c0:	eb06 0086 	add.w	r0, r6, r6, lsl #2
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 80020c4:	d9f2      	bls.n	80020ac <chvprintf+0x7c>
        c -= '0';
      else if (c == '*')
 80020c6:	2a2a      	cmp	r2, #42	; 0x2a
 80020c8:	d0ee      	beq.n	80020a8 <chvprintf+0x78>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 80020ca:	2a2e      	cmp	r2, #46	; 0x2e
 80020cc:	f04f 0100 	mov.w	r1, #0
 80020d0:	d043      	beq.n	800215a <chvprintf+0x12a>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80020d2:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 80020d6:	2b4c      	cmp	r3, #76	; 0x4c
 80020d8:	d04e      	beq.n	8002178 <chvprintf+0x148>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80020da:	f1a2 0044 	sub.w	r0, r2, #68	; 0x44
 80020de:	2834      	cmp	r0, #52	; 0x34
 80020e0:	f200 80f7 	bhi.w	80022d2 <chvprintf+0x2a2>
 80020e4:	e8df f010 	tbh	[pc, r0, lsl #1]
 80020e8:	00f500ea 	.word	0x00f500ea
 80020ec:	00f500f5 	.word	0x00f500f5
 80020f0:	00ea00f5 	.word	0x00ea00f5
 80020f4:	00f500f5 	.word	0x00f500f5
 80020f8:	00f500f5 	.word	0x00f500f5
 80020fc:	00e800f5 	.word	0x00e800f5
 8002100:	00f500f5 	.word	0x00f500f5
 8002104:	00f500f5 	.word	0x00f500f5
 8002108:	00dd00f5 	.word	0x00dd00f5
 800210c:	00f500f5 	.word	0x00f500f5
 8002110:	00f500f2 	.word	0x00f500f2
 8002114:	00f500f5 	.word	0x00f500f5
 8002118:	00f500f5 	.word	0x00f500f5
 800211c:	00f500f5 	.word	0x00f500f5
 8002120:	00f500f5 	.word	0x00f500f5
 8002124:	00a100f5 	.word	0x00a100f5
 8002128:	00f500ea 	.word	0x00f500ea
 800212c:	00f500f5 	.word	0x00f500f5
 8002130:	00ea00f5 	.word	0x00ea00f5
 8002134:	00f500f5 	.word	0x00f500f5
 8002138:	00f500f5 	.word	0x00f500f5
 800213c:	00e800f5 	.word	0x00e800f5
 8002140:	00f500f5 	.word	0x00f500f5
 8002144:	007100f5 	.word	0x007100f5
 8002148:	00dd00f5 	.word	0x00dd00f5
 800214c:	00f500f5 	.word	0x00f500f5
 8002150:	00f2      	.short	0x00f2
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 8002152:	782b      	ldrb	r3, [r5, #0]
 8002154:	3504      	adds	r5, #4
        else
          break;
        precision *= 10;
        precision += c;
 8002156:	eb03 0140 	add.w	r1, r3, r0, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 800215a:	f81b 2b01 	ldrb.w	r2, [fp], #1
        if (c >= '0' && c <= '9')
 800215e:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8002162:	b2db      	uxtb	r3, r3
 8002164:	2b09      	cmp	r3, #9
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 8002166:	eb01 0081 	add.w	r0, r1, r1, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 800216a:	d9f4      	bls.n	8002156 <chvprintf+0x126>
          c -= '0';
        else if (c == '*')
 800216c:	2a2a      	cmp	r2, #42	; 0x2a
 800216e:	d0f0      	beq.n	8002152 <chvprintf+0x122>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8002170:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8002174:	2b4c      	cmp	r3, #76	; 0x4c
 8002176:	d1b0      	bne.n	80020da <chvprintf+0xaa>
      is_long = TRUE;
      if (*fmt)
 8002178:	f89b 3000 	ldrb.w	r3, [fp]
 800217c:	2b00      	cmp	r3, #0
 800217e:	f000 80a8 	beq.w	80022d2 <chvprintf+0x2a2>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8002182:	f1a3 0244 	sub.w	r2, r3, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 8002186:	f10b 0b01 	add.w	fp, fp, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800218a:	2a34      	cmp	r2, #52	; 0x34
 800218c:	f200 80a0 	bhi.w	80022d0 <chvprintf+0x2a0>
 8002190:	e8df f002 	tbb	[pc, r2]
 8002194:	9e9e9e94 	.word	0x9e9e9e94
 8002198:	9e9e949e 	.word	0x9e9e949e
 800219c:	929e9e9e 	.word	0x929e9e9e
 80021a0:	9e9e9e9e 	.word	0x9e9e9e9e
 80021a4:	9e9e879e 	.word	0x9e9e879e
 80021a8:	9e9e9e9c 	.word	0x9e9e9e9c
 80021ac:	9e9e9e9e 	.word	0x9e9e9e9e
 80021b0:	4b9e9e9e 	.word	0x4b9e9e9e
 80021b4:	9e9e9e94 	.word	0x9e9e9e94
 80021b8:	9e9e949e 	.word	0x9e9e949e
 80021bc:	929e9e9e 	.word	0x929e9e9e
 80021c0:	1b9e9e9e 	.word	0x1b9e9e9e
 80021c4:	9e9e879e 	.word	0x9e9e879e
 80021c8:	9c          	.byte	0x9c
 80021c9:	00          	.byte	0x00
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 80021ca:	682c      	ldr	r4, [r5, #0]
        s = "(null)";
 80021cc:	4b5a      	ldr	r3, [pc, #360]	; (8002338 <chvprintf+0x308>)
 80021ce:	2c00      	cmp	r4, #0
 80021d0:	bf08      	it	eq
 80021d2:	461c      	moveq	r4, r3
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 80021d4:	3504      	adds	r5, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 80021d6:	7823      	ldrb	r3, [r4, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
 80021d8:	2900      	cmp	r1, #0
 80021da:	f000 8094 	beq.w	8002306 <chvprintf+0x2d6>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 80021de:	2b00      	cmp	r3, #0
 80021e0:	f000 8096 	beq.w	8002310 <chvprintf+0x2e0>
 80021e4:	3901      	subs	r1, #1
 80021e6:	4620      	mov	r0, r4
 80021e8:	e001      	b.n	80021ee <chvprintf+0x1be>
 80021ea:	3901      	subs	r1, #1
 80021ec:	d403      	bmi.n	80021f6 <chvprintf+0x1c6>
 80021ee:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 80021f2:	2b00      	cmp	r3, #0
 80021f4:	d1f9      	bne.n	80021ea <chvprintf+0x1ba>
 80021f6:	1b00      	subs	r0, r0, r4
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 80021f8:	1a36      	subs	r6, r6, r0
 80021fa:	1e43      	subs	r3, r0, #1
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 80021fc:	2720      	movs	r7, #32
 80021fe:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8002202:	f1ba 0f00 	cmp.w	sl, #0
 8002206:	d01f      	beq.n	8002248 <chvprintf+0x218>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8002208:	2b00      	cmp	r3, #0
 800220a:	9300      	str	r3, [sp, #0]
 800220c:	da34      	bge.n	8002278 <chvprintf+0x248>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800220e:	2e00      	cmp	r6, #0
 8002210:	f43f af1c 	beq.w	800204c <chvprintf+0x1c>
 8002214:	4634      	mov	r4, r6
      streamPut(chp, (uint8_t)filler);
 8002216:	f8d9 3000 	ldr.w	r3, [r9]
 800221a:	4648      	mov	r0, r9
 800221c:	689b      	ldr	r3, [r3, #8]
 800221e:	4639      	mov	r1, r7
 8002220:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8002222:	3c01      	subs	r4, #1
 8002224:	d1f7      	bne.n	8002216 <chvprintf+0x1e6>
 8002226:	44b0      	add	r8, r6
 8002228:	e710      	b.n	800204c <chvprintf+0x1c>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 800222a:	682b      	ldr	r3, [r5, #0]
 800222c:	f88d 300c 	strb.w	r3, [sp, #12]
 8002230:	9b01      	ldr	r3, [sp, #4]
 8002232:	3504      	adds	r5, #4
 8002234:	4618      	mov	r0, r3
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 8002236:	2720      	movs	r7, #32
 8002238:	3b01      	subs	r3, #1
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 800223a:	ac03      	add	r4, sp, #12
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 800223c:	1a36      	subs	r6, r6, r0
 800223e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      width = 0;
    if (left_align == FALSE)
 8002242:	f1ba 0f00 	cmp.w	sl, #0
 8002246:	d1df      	bne.n	8002208 <chvprintf+0x1d8>
 8002248:	9300      	str	r3, [sp, #0]
      width = -width;
 800224a:	f1c6 0a00 	rsb	sl, r6, #0
    if (width < 0) {
 800224e:	f1ba 0f00 	cmp.w	sl, #0
 8002252:	d045      	beq.n	80022e0 <chvprintf+0x2b0>
      if (*s == '-' && filler == '0') {
 8002254:	7821      	ldrb	r1, [r4, #0]
 8002256:	292d      	cmp	r1, #45	; 0x2d
 8002258:	d047      	beq.n	80022ea <chvprintf+0x2ba>
        streamPut(chp, (uint8_t)*s++);
        n++;
 800225a:	4656      	mov	r6, sl
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 800225c:	f8d9 3000 	ldr.w	r3, [r9]
 8002260:	4648      	mov	r0, r9
 8002262:	689b      	ldr	r3, [r3, #8]
 8002264:	4639      	mov	r1, r7
 8002266:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8002268:	3601      	adds	r6, #1
 800226a:	d1f7      	bne.n	800225c <chvprintf+0x22c>
    }
    while (--i >= 0) {
 800226c:	9b00      	ldr	r3, [sp, #0]
 800226e:	2b00      	cmp	r3, #0
 8002270:	ebca 0808 	rsb	r8, sl, r8
 8002274:	f6ff aeea 	blt.w	800204c <chvprintf+0x1c>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8002278:	f8dd a000 	ldr.w	sl, [sp]
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 800227c:	f8d9 3000 	ldr.w	r3, [r9]
 8002280:	f814 1b01 	ldrb.w	r1, [r4], #1
 8002284:	689b      	ldr	r3, [r3, #8]
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8002286:	f10a 3aff 	add.w	sl, sl, #4294967295
      streamPut(chp, (uint8_t)*s++);
 800228a:	4648      	mov	r0, r9
 800228c:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800228e:	f1ba 3fff 	cmp.w	sl, #4294967295
 8002292:	d1f3      	bne.n	800227c <chvprintf+0x24c>
 8002294:	9b00      	ldr	r3, [sp, #0]
 8002296:	f108 0801 	add.w	r8, r8, #1
 800229a:	2b00      	cmp	r3, #0
 800229c:	bfa8      	it	ge
 800229e:	4498      	addge	r8, r3
 80022a0:	e7b5      	b.n	800220e <chvprintf+0x1de>
 80022a2:	220a      	movs	r2, #10
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 80022a4:	6829      	ldr	r1, [r5, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80022a6:	a803      	add	r0, sp, #12
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 80022a8:	3504      	adds	r5, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80022aa:	f001 fff1 	bl	8004290 <long_to_string_with_divisor.constprop.8>
 80022ae:	ab03      	add	r3, sp, #12
 80022b0:	1ac0      	subs	r0, r0, r3
 80022b2:	1e43      	subs	r3, r0, #1
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80022b4:	ac03      	add	r4, sp, #12
 80022b6:	e7c1      	b.n	800223c <chvprintf+0x20c>
 80022b8:	2208      	movs	r2, #8
 80022ba:	e7f3      	b.n	80022a4 <chvprintf+0x274>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 80022bc:	6829      	ldr	r1, [r5, #0]
      if (l < 0) {
 80022be:	2900      	cmp	r1, #0
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 80022c0:	f105 0504 	add.w	r5, r5, #4
      if (l < 0) {
 80022c4:	db2e      	blt.n	8002324 <chvprintf+0x2f4>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 80022c6:	a803      	add	r0, sp, #12
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80022c8:	220a      	movs	r2, #10
 80022ca:	e7ee      	b.n	80022aa <chvprintf+0x27a>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80022cc:	2210      	movs	r2, #16
 80022ce:	e7e9      	b.n	80022a4 <chvprintf+0x274>
 80022d0:	461a      	mov	r2, r3
 80022d2:	9b01      	ldr	r3, [sp, #4]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 80022d4:	f88d 200c 	strb.w	r2, [sp, #12]
 80022d8:	4618      	mov	r0, r3
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80022da:	ac03      	add	r4, sp, #12
 80022dc:	3b01      	subs	r3, #1
 80022de:	e7ad      	b.n	800223c <chvprintf+0x20c>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80022e0:	9b00      	ldr	r3, [sp, #0]
 80022e2:	2b00      	cmp	r3, #0
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
 80022e4:	4656      	mov	r6, sl
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80022e6:	dac7      	bge.n	8002278 <chvprintf+0x248>
 80022e8:	e6b0      	b.n	800204c <chvprintf+0x1c>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 80022ea:	2f30      	cmp	r7, #48	; 0x30
 80022ec:	d1b5      	bne.n	800225a <chvprintf+0x22a>
        streamPut(chp, (uint8_t)*s++);
 80022ee:	f8d9 3000 	ldr.w	r3, [r9]
 80022f2:	4648      	mov	r0, r9
 80022f4:	689b      	ldr	r3, [r3, #8]
 80022f6:	4798      	blx	r3
 80022f8:	9b00      	ldr	r3, [sp, #0]
 80022fa:	3b01      	subs	r3, #1
 80022fc:	3401      	adds	r4, #1
        n++;
 80022fe:	f108 0801 	add.w	r8, r8, #1
 8002302:	9300      	str	r3, [sp, #0]
 8002304:	e7a9      	b.n	800225a <chvprintf+0x22a>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8002306:	f647 71fe 	movw	r1, #32766	; 0x7ffe
 800230a:	2b00      	cmp	r3, #0
 800230c:	f47f af6b 	bne.w	80021e6 <chvprintf+0x1b6>
 8002310:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8002314:	f1ba 0f00 	cmp.w	sl, #0
 8002318:	d10b      	bne.n	8002332 <chvprintf+0x302>
 800231a:	f04f 33ff 	mov.w	r3, #4294967295
 800231e:	9300      	str	r3, [sp, #0]
 8002320:	2720      	movs	r7, #32
 8002322:	e792      	b.n	800224a <chvprintf+0x21a>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8002324:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8002326:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8002328:	f88d 300c 	strb.w	r3, [sp, #12]
 800232c:	f10d 000d 	add.w	r0, sp, #13
 8002330:	e7ca      	b.n	80022c8 <chvprintf+0x298>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8002332:	2720      	movs	r7, #32
 8002334:	e76b      	b.n	800220e <chvprintf+0x1de>
 8002336:	bf00      	nop
 8002338:	080067b0 	.word	0x080067b0
 800233c:	00000000 	.word	0x00000000

08002340 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8002340:	b40e      	push	{r1, r2, r3}
 8002342:	b500      	push	{lr}
 8002344:	b082      	sub	sp, #8
 8002346:	aa03      	add	r2, sp, #12
 8002348:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800234c:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800234e:	f7ff fe6f 	bl	8002030 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8002352:	b002      	add	sp, #8
 8002354:	f85d eb04 	ldr.w	lr, [sp], #4
 8002358:	b003      	add	sp, #12
 800235a:	4770      	bx	lr
 800235c:	0000      	movs	r0, r0
	...

08002360 <TFT_thread.lto_priv.53>:
*/
#include "main.h"

static THD_WORKING_AREA(TFT_thread_wa, 4096);
static THD_FUNCTION(TFT_thread, p)
{
 8002360:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8002364:	4e37      	ldr	r6, [pc, #220]	; (8002444 <TFT_thread.lto_priv.53+0xe4>)
}

void tft_init(uint8_t orientation, uint16_t in_bg_color,
  uint16_t in_text_color, uint16_t in_text_color_sp)
{
  palSetPad(GPIO_CS, GPIO_Pin_CS);
 8002366:	4b38      	ldr	r3, [pc, #224]	; (8002448 <TFT_thread.lto_priv.53+0xe8>)
 8002368:	69b2      	ldr	r2, [r6, #24]
 800236a:	4938      	ldr	r1, [pc, #224]	; (800244c <TFT_thread.lto_priv.53+0xec>)
 800236c:	6191      	str	r1, [r2, #24]
 800236e:	2210      	movs	r2, #16
 8002370:	831a      	strh	r2, [r3, #24]
 8002372:	b089      	sub	sp, #36	; 0x24

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002374:	2320      	movs	r3, #32
 8002376:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 800237a:	4c35      	ldr	r4, [pc, #212]	; (8002450 <TFT_thread.lto_priv.53+0xf0>)
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 800237c:	f000 fe50 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8002380:	f001 f8ce 	bl	8003520 <_dbg_check_lock>
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;

  chDbgCheckClassS();
 8002384:	f000 fe94 	bl	80030b0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8002388:	6960      	ldr	r0, [r4, #20]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 800238a:	69b5      	ldr	r5, [r6, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 800238c:	2800      	cmp	r0, #0
 800238e:	d032      	beq.n	80023f6 <TFT_thread.lto_priv.53+0x96>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8002390:	68aa      	ldr	r2, [r5, #8]
 8002392:	6883      	ldr	r3, [r0, #8]
 8002394:	429a      	cmp	r2, r3
 8002396:	d913      	bls.n	80023c0 <TFT_thread.lto_priv.53+0x60>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8002398:	f890 3020 	ldrb.w	r3, [r0, #32]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 800239c:	6082      	str	r2, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 800239e:	2b06      	cmp	r3, #6
 80023a0:	f000 828b 	beq.w	80028ba <TFT_thread.lto_priv.53+0x55a>
 80023a4:	2b07      	cmp	r3, #7
 80023a6:	f000 826d 	beq.w	8002884 <TFT_thread.lto_priv.53+0x524>
 80023aa:	b94b      	cbnz	r3, 80023c0 <TFT_thread.lto_priv.53+0x60>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80023ac:	e890 000c 	ldmia.w	r0, {r2, r3}
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
 80023b0:	2101      	movs	r1, #1
 80023b2:	f880 1020 	strb.w	r1, [r0, #32]
 80023b6:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80023b8:	6802      	ldr	r2, [r0, #0]
 80023ba:	6053      	str	r3, [r2, #4]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 80023bc:	f000 ffa0 	bl	8003300 <chSchReadyI>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80023c0:	4a24      	ldr	r2, [pc, #144]	; (8002454 <TFT_thread.lto_priv.53+0xf4>)
 80023c2:	4613      	mov	r3, r2
  do {
    cp = cp->p_next;
 80023c4:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80023c6:	4293      	cmp	r3, r2
 80023c8:	d003      	beq.n	80023d2 <TFT_thread.lto_priv.53+0x72>
 80023ca:	6898      	ldr	r0, [r3, #8]
 80023cc:	68a9      	ldr	r1, [r5, #8]
 80023ce:	4288      	cmp	r0, r1
 80023d0:	d2f8      	bcs.n	80023c4 <TFT_thread.lto_priv.53+0x64>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80023d2:	6859      	ldr	r1, [r3, #4]
 80023d4:	6069      	str	r1, [r5, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 80023d6:	602b      	str	r3, [r5, #0]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 80023d8:	2006      	movs	r0, #6
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80023da:	600d      	str	r5, [r1, #0]
  cp->p_prev = tp;
 80023dc:	605d      	str	r5, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
 80023de:	626a      	str	r2, [r5, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 80023e0:	f000 fe76 	bl	80030d0 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->m_owner == ctp, "not owner");
 80023e4:	6962      	ldr	r2, [r4, #20]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
 80023e6:	4b1b      	ldr	r3, [pc, #108]	; (8002454 <TFT_thread.lto_priv.53+0xf4>)
      chSchGoSleepS(CH_STATE_WTMTX);

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->m_owner == ctp, "not owner");
 80023e8:	4295      	cmp	r5, r2
 80023ea:	f000 825e 	beq.w	80028aa <TFT_thread.lto_priv.53+0x54a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80023ee:	b672      	cpsid	i
 80023f0:	4b19      	ldr	r3, [pc, #100]	; (8002458 <TFT_thread.lto_priv.53+0xf8>)
 80023f2:	62f3      	str	r3, [r6, #44]	; 0x2c
 80023f4:	e7fe      	b.n	80023f4 <TFT_thread.lto_priv.53+0x94>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 80023f6:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 80023f8:	6165      	str	r5, [r4, #20]
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
 80023fa:	f104 030c 	add.w	r3, r4, #12

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 80023fe:	61a2      	str	r2, [r4, #24]
    ctp->p_mtxlist = mp;
 8002400:	63eb      	str	r3, [r5, #60]	; 0x3c
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002402:	f001 f87d 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8002406:	f000 fdf3 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800240a:	6832      	ldr	r2, [r6, #0]
 800240c:	4b0d      	ldr	r3, [pc, #52]	; (8002444 <TFT_thread.lto_priv.53+0xe4>)
 800240e:	42b2      	cmp	r2, r6
 8002410:	d005      	beq.n	800241e <TFT_thread.lto_priv.53+0xbe>
 8002412:	6999      	ldr	r1, [r3, #24]
 8002414:	6892      	ldr	r2, [r2, #8]
 8002416:	6889      	ldr	r1, [r1, #8]
 8002418:	4291      	cmp	r1, r2
 800241a:	f0c0 8557 	bcc.w	8002ecc <TFT_thread.lto_priv.53+0xb6c>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800241e:	2300      	movs	r3, #0
 8002420:	f383 8811 	msr	BASEPRI, r3
 8002424:	2320      	movs	r3, #32
 8002426:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 800242a:	f000 fdf9 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800242e:	f001 f877 	bl	8003520 <_dbg_check_lock>
void spiStart(SPIDriver *spip, const SPIConfig *config) {

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 8002432:	7822      	ldrb	r2, [r4, #0]
 8002434:	4d06      	ldr	r5, [pc, #24]	; (8002450 <TFT_thread.lto_priv.53+0xf0>)
 8002436:	1e53      	subs	r3, r2, #1
 8002438:	2b01      	cmp	r3, #1
 800243a:	d911      	bls.n	8002460 <TFT_thread.lto_priv.53+0x100>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800243c:	b672      	cpsid	i
 800243e:	4b07      	ldr	r3, [pc, #28]	; (800245c <TFT_thread.lto_priv.53+0xfc>)
 8002440:	62f3      	str	r3, [r6, #44]	; 0x2c
 8002442:	e7fe      	b.n	8002442 <TFT_thread.lto_priv.53+0xe2>
 8002444:	20002740 	.word	0x20002740
 8002448:	40020800 	.word	0x40020800
 800244c:	080067b8 	.word	0x080067b8
 8002450:	20002194 	.word	0x20002194
 8002454:	200021a0 	.word	0x200021a0
 8002458:	080067e0 	.word	0x080067e0
 800245c:	080067f0 	.word	0x080067f0
                "invalid state");
  spip->config = config;
 8002460:	4be0      	ldr	r3, [pc, #896]	; (80027e4 <TFT_thread.lto_priv.53+0x484>)
 8002462:	606b      	str	r3, [r5, #4]
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 8002464:	2a01      	cmp	r2, #1
 8002466:	f000 81e6 	beq.w	8002836 <TFT_thread.lto_priv.53+0x4d6>
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 800246a:	8959      	ldrh	r1, [r3, #10]
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800246c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800246e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 8002470:	0508      	lsls	r0, r1, #20
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 8002472:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8002476:	bf48      	it	mi
 8002478:	f443 5320 	orrmi.w	r3, r3, #10240	; 0x2800

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800247c:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 8002480:	62e3      	str	r3, [r4, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 8002482:	bf48      	it	mi
 8002484:	f442 5220 	orrmi.w	r2, r2, #10240	; 0x2800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 8002488:	69e3      	ldr	r3, [r4, #28]
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800248a:	62a2      	str	r2, [r4, #40]	; 0x28
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 800248c:	f441 7141 	orr.w	r1, r1, #772	; 0x304
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 8002490:	2000      	movs	r0, #0
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
                    SPI_CR1_SSI;
  spip->spi->CR2  = SPI_CR2_SSOE | SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
 8002492:	2207      	movs	r2, #7
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 8002494:	6018      	str	r0, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 8002496:	6019      	str	r1, [r3, #0]
                    SPI_CR1_SSI;
  spip->spi->CR2  = SPI_CR2_SSOE | SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
 8002498:	605a      	str	r2, [r3, #4]
  spip->spi->CR1 |= SPI_CR1_SPE;
 800249a:	681a      	ldr	r2, [r3, #0]
 800249c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80024a0:	601a      	str	r2, [r3, #0]
  spi_lld_start(spip);
  spip->state = SPI_READY;
 80024a2:	2302      	movs	r3, #2
 80024a4:	7023      	strb	r3, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80024a6:	f001 f82b 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80024aa:	f000 fda1 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80024ae:	6832      	ldr	r2, [r6, #0]
 80024b0:	4bcd      	ldr	r3, [pc, #820]	; (80027e8 <TFT_thread.lto_priv.53+0x488>)
 80024b2:	42b2      	cmp	r2, r6
 80024b4:	d005      	beq.n	80024c2 <TFT_thread.lto_priv.53+0x162>
 80024b6:	6999      	ldr	r1, [r3, #24]
 80024b8:	6892      	ldr	r2, [r2, #8]
 80024ba:	6889      	ldr	r1, [r1, #8]
 80024bc:	4291      	cmp	r1, r2
 80024be:	f0c0 81d5 	bcc.w	800286c <TFT_thread.lto_priv.53+0x50c>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80024c2:	2400      	movs	r4, #0
 80024c4:	f384 8811 	msr	BASEPRI, r4
  * @param  None
  * @retval None
  */
void tft_reset(void)
{
 	palClearPad(TFT_RST_PORT, TFT_RST_PIN);
 80024c8:	4ec8      	ldr	r6, [pc, #800]	; (80027ec <TFT_thread.lto_priv.53+0x48c>)
 80024ca:	2501      	movs	r5, #1
	chThdSleepMilliseconds(1);
 80024cc:	200a      	movs	r0, #10
  * @param  None
  * @retval None
  */
void tft_reset(void)
{
 	palClearPad(TFT_RST_PORT, TFT_RST_PIN);
 80024ce:	8375      	strh	r5, [r6, #26]
	chThdSleepMilliseconds(1);
 80024d0:	f001 f846 	bl	8003560 <chThdSleep>
	palSetPad(TFT_RST_PORT, TFT_RST_PIN);
	chThdSleepMilliseconds(1);
 80024d4:	200a      	movs	r0, #10
  */
void tft_reset(void)
{
 	palClearPad(TFT_RST_PORT, TFT_RST_PIN);
	chThdSleepMilliseconds(1);
	palSetPad(TFT_RST_PORT, TFT_RST_PIN);
 80024d6:	8335      	strh	r5, [r6, #24]
	chThdSleepMilliseconds(1);
 80024d8:	f001 f842 	bl	8003560 <chThdSleep>
  * @param  None
  * @retval None
  */
void tft_config(void)
{
	tft_write_command(0x01);   //Sofeware setting
 80024dc:	4628      	mov	r0, r5
 80024de:	f002 f927 	bl	8004730 <tft_write_command>
	//chThdSleepMilliseconds(0);
	tft_write_command(0x11);//Sleep out
 80024e2:	2011      	movs	r0, #17
 80024e4:	f002 f924 	bl	8004730 <tft_write_command>
	chThdSleepMilliseconds(120);
 80024e8:	f44f 6096 	mov.w	r0, #1200	; 0x4b0
 80024ec:	f001 f838 	bl	8003560 <chThdSleep>

	//ST7735R Frame Rate
	tft_write_command(0xB1);
 80024f0:	20b1      	movs	r0, #177	; 0xb1
 80024f2:	f002 f91d 	bl	8004730 <tft_write_command>
	tft_write_data(0x01);
 80024f6:	4628      	mov	r0, r5
 80024f8:	f002 f902 	bl	8004700 <tft_write_data>
	tft_write_data(0x2C);
 80024fc:	202c      	movs	r0, #44	; 0x2c
 80024fe:	f002 f8ff 	bl	8004700 <tft_write_data>
	tft_write_data(0x2D);
 8002502:	202d      	movs	r0, #45	; 0x2d
 8002504:	f002 f8fc 	bl	8004700 <tft_write_data>
	tft_write_command(0xB2);
 8002508:	20b2      	movs	r0, #178	; 0xb2
 800250a:	f002 f911 	bl	8004730 <tft_write_command>
	tft_write_data(0x01);
 800250e:	4628      	mov	r0, r5
 8002510:	f002 f8f6 	bl	8004700 <tft_write_data>
	tft_write_data(0x2C);
 8002514:	202c      	movs	r0, #44	; 0x2c
 8002516:	f002 f8f3 	bl	8004700 <tft_write_data>
	tft_write_data(0x2D);
 800251a:	202d      	movs	r0, #45	; 0x2d
 800251c:	f002 f8f0 	bl	8004700 <tft_write_data>
	tft_write_command(0xB3);
 8002520:	20b3      	movs	r0, #179	; 0xb3
 8002522:	f002 f905 	bl	8004730 <tft_write_command>
	tft_write_data(0x01);
 8002526:	4628      	mov	r0, r5
 8002528:	f002 f8ea 	bl	8004700 <tft_write_data>
	tft_write_data(0x2C);
 800252c:	202c      	movs	r0, #44	; 0x2c
 800252e:	f002 f8e7 	bl	8004700 <tft_write_data>
	tft_write_data(0x2D);
 8002532:	202d      	movs	r0, #45	; 0x2d
 8002534:	f002 f8e4 	bl	8004700 <tft_write_data>
	tft_write_data(0x01);
 8002538:	4628      	mov	r0, r5
 800253a:	f002 f8e1 	bl	8004700 <tft_write_data>
	tft_write_data(0x2C);
 800253e:	202c      	movs	r0, #44	; 0x2c
 8002540:	f002 f8de 	bl	8004700 <tft_write_data>
	tft_write_data(0x2D);
 8002544:	202d      	movs	r0, #45	; 0x2d
 8002546:	f002 f8db 	bl	8004700 <tft_write_data>
	//------------------------------------End ST7735R Frame Rate-----------------------------------------//
	tft_write_command(0xB4);//Column inversion
 800254a:	20b4      	movs	r0, #180	; 0xb4
 800254c:	f002 f8f0 	bl	8004730 <tft_write_command>
	tft_write_data(0x07);
 8002550:	2007      	movs	r0, #7
 8002552:	f002 f8d5 	bl	8004700 <tft_write_data>
	//------------------------------------ST7735R Power Sequence-----------------------------------------//
	tft_write_command(0xC0);
 8002556:	20c0      	movs	r0, #192	; 0xc0
 8002558:	f002 f8ea 	bl	8004730 <tft_write_command>
	tft_write_data(0xA2);
 800255c:	20a2      	movs	r0, #162	; 0xa2
 800255e:	f002 f8cf 	bl	8004700 <tft_write_data>
	tft_write_data(0x02);
 8002562:	2002      	movs	r0, #2
 8002564:	f002 f8cc 	bl	8004700 <tft_write_data>
	tft_write_data(0x84);
 8002568:	2084      	movs	r0, #132	; 0x84
 800256a:	f002 f8c9 	bl	8004700 <tft_write_data>
	tft_write_command(0xC1);
 800256e:	20c1      	movs	r0, #193	; 0xc1
 8002570:	f002 f8de 	bl	8004730 <tft_write_command>
	tft_write_data(0xC5);
 8002574:	20c5      	movs	r0, #197	; 0xc5
 8002576:	f002 f8c3 	bl	8004700 <tft_write_data>
	tft_write_command(0xC2);
 800257a:	20c2      	movs	r0, #194	; 0xc2
 800257c:	f002 f8d8 	bl	8004730 <tft_write_command>
	tft_write_data(0x0A);
 8002580:	200a      	movs	r0, #10
 8002582:	f002 f8bd 	bl	8004700 <tft_write_data>
	tft_write_data(0x00);
 8002586:	4620      	mov	r0, r4
 8002588:	f002 f8ba 	bl	8004700 <tft_write_data>
	tft_write_command(0xC3);
 800258c:	20c3      	movs	r0, #195	; 0xc3
 800258e:	f002 f8cf 	bl	8004730 <tft_write_command>
	tft_write_data(0x8A);
 8002592:	208a      	movs	r0, #138	; 0x8a
 8002594:	f002 f8b4 	bl	8004700 <tft_write_data>
	tft_write_data(0x2A);
 8002598:	202a      	movs	r0, #42	; 0x2a
 800259a:	f002 f8b1 	bl	8004700 <tft_write_data>
	tft_write_command(0xC4);
 800259e:	20c4      	movs	r0, #196	; 0xc4
 80025a0:	f002 f8c6 	bl	8004730 <tft_write_command>
	tft_write_data(0x8A);
 80025a4:	208a      	movs	r0, #138	; 0x8a
 80025a6:	f002 f8ab 	bl	8004700 <tft_write_data>
	tft_write_data(0xEE);
 80025aa:	20ee      	movs	r0, #238	; 0xee
 80025ac:	f002 f8a8 	bl	8004700 <tft_write_data>
	//---------------------------------End ST7735R Power Sequence-------------------------------------//
	tft_write_command(0xC5);//VCOM
 80025b0:	20c5      	movs	r0, #197	; 0xc5
 80025b2:	f002 f8bd 	bl	8004730 <tft_write_command>
	tft_write_data(0x0E);
 80025b6:	200e      	movs	r0, #14
 80025b8:	f002 f8a2 	bl	8004700 <tft_write_data>
	tft_write_command(0x36);//MX, MY, RGB mode
 80025bc:	2036      	movs	r0, #54	; 0x36
 80025be:	f002 f8b7 	bl	8004730 <tft_write_command>
	tft_write_data(0xC8);
 80025c2:	20c8      	movs	r0, #200	; 0xc8
 80025c4:	f002 f89c 	bl	8004700 <tft_write_data>
	//------------------------------------ST7735R Gamma Sequence-----------------------------------------//
	tft_write_command(0xe0);
 80025c8:	20e0      	movs	r0, #224	; 0xe0
 80025ca:	f002 f8b1 	bl	8004730 <tft_write_command>
	tft_write_data(0x02);
 80025ce:	2002      	movs	r0, #2
 80025d0:	f002 f896 	bl	8004700 <tft_write_data>
	tft_write_data(0x1c);
 80025d4:	201c      	movs	r0, #28
 80025d6:	f002 f893 	bl	8004700 <tft_write_data>
	tft_write_data(0x07);
 80025da:	2007      	movs	r0, #7
 80025dc:	f002 f890 	bl	8004700 <tft_write_data>
	tft_write_data(0x12);
 80025e0:	2012      	movs	r0, #18
 80025e2:	f002 f88d 	bl	8004700 <tft_write_data>
	tft_write_data(0x37);
 80025e6:	2037      	movs	r0, #55	; 0x37
 80025e8:	f002 f88a 	bl	8004700 <tft_write_data>
	tft_write_data(0x32);
 80025ec:	2032      	movs	r0, #50	; 0x32
 80025ee:	f002 f887 	bl	8004700 <tft_write_data>
	tft_write_data(0x29);
 80025f2:	2029      	movs	r0, #41	; 0x29
 80025f4:	f002 f884 	bl	8004700 <tft_write_data>
	tft_write_data(0x2d);
 80025f8:	202d      	movs	r0, #45	; 0x2d
 80025fa:	f002 f881 	bl	8004700 <tft_write_data>
	tft_write_data(0x29);
 80025fe:	2029      	movs	r0, #41	; 0x29
 8002600:	f002 f87e 	bl	8004700 <tft_write_data>
	tft_write_data(0x25);
 8002604:	2025      	movs	r0, #37	; 0x25
 8002606:	f002 f87b 	bl	8004700 <tft_write_data>
	tft_write_data(0x2b);
 800260a:	202b      	movs	r0, #43	; 0x2b
 800260c:	f002 f878 	bl	8004700 <tft_write_data>
	tft_write_data(0x39);
 8002610:	2039      	movs	r0, #57	; 0x39
 8002612:	f002 f875 	bl	8004700 <tft_write_data>
	tft_write_data(0x00);
 8002616:	4620      	mov	r0, r4
 8002618:	f002 f872 	bl	8004700 <tft_write_data>
	tft_write_data(0x01);
 800261c:	4628      	mov	r0, r5
 800261e:	f002 f86f 	bl	8004700 <tft_write_data>
	tft_write_data(0x03);
 8002622:	2003      	movs	r0, #3
 8002624:	f002 f86c 	bl	8004700 <tft_write_data>
	tft_write_data(0x10);
 8002628:	2010      	movs	r0, #16
 800262a:	f002 f869 	bl	8004700 <tft_write_data>
	tft_write_command(0xe1);
 800262e:	20e1      	movs	r0, #225	; 0xe1
 8002630:	f002 f87e 	bl	8004730 <tft_write_command>
	tft_write_data(0x03);
 8002634:	2003      	movs	r0, #3
 8002636:	f002 f863 	bl	8004700 <tft_write_data>
	tft_write_data(0x1d);
 800263a:	201d      	movs	r0, #29
 800263c:	f002 f860 	bl	8004700 <tft_write_data>
	tft_write_data(0x07);
 8002640:	2007      	movs	r0, #7
 8002642:	f002 f85d 	bl	8004700 <tft_write_data>
	tft_write_data(0x06);
 8002646:	2006      	movs	r0, #6
 8002648:	f002 f85a 	bl	8004700 <tft_write_data>
	tft_write_data(0x2e);
 800264c:	202e      	movs	r0, #46	; 0x2e
 800264e:	f002 f857 	bl	8004700 <tft_write_data>
	tft_write_data(0x2c);
 8002652:	202c      	movs	r0, #44	; 0x2c
 8002654:	f002 f854 	bl	8004700 <tft_write_data>
	tft_write_data(0x29);
 8002658:	2029      	movs	r0, #41	; 0x29
 800265a:	f002 f851 	bl	8004700 <tft_write_data>
	tft_write_data(0x2d);
 800265e:	202d      	movs	r0, #45	; 0x2d
 8002660:	f002 f84e 	bl	8004700 <tft_write_data>
	tft_write_data(0x2e);
 8002664:	202e      	movs	r0, #46	; 0x2e
 8002666:	f002 f84b 	bl	8004700 <tft_write_data>
	tft_write_data(0x2e);
 800266a:	202e      	movs	r0, #46	; 0x2e
 800266c:	f002 f848 	bl	8004700 <tft_write_data>
	tft_write_data(0x37);
 8002670:	2037      	movs	r0, #55	; 0x37
 8002672:	f002 f845 	bl	8004700 <tft_write_data>
	tft_write_data(0x3f);
 8002676:	203f      	movs	r0, #63	; 0x3f
 8002678:	f002 f842 	bl	8004700 <tft_write_data>
	tft_write_data(0x00);
 800267c:	4620      	mov	r0, r4
 800267e:	f002 f83f 	bl	8004700 <tft_write_data>
	tft_write_data(0x00);
 8002682:	4620      	mov	r0, r4
 8002684:	f002 f83c 	bl	8004700 <tft_write_data>
	tft_write_data(0x02);
 8002688:	2002      	movs	r0, #2
 800268a:	f002 f839 	bl	8004700 <tft_write_data>
	tft_write_data(0x10);
 800268e:	2010      	movs	r0, #16
 8002690:	f002 f836 	bl	8004700 <tft_write_data>
	tft_write_command(0x2A);
 8002694:	202a      	movs	r0, #42	; 0x2a
 8002696:	f002 f84b 	bl	8004730 <tft_write_command>
	tft_write_data(0x00);
 800269a:	4620      	mov	r0, r4
 800269c:	f002 f830 	bl	8004700 <tft_write_data>
	tft_write_data(0x00);
 80026a0:	4620      	mov	r0, r4
 80026a2:	f002 f82d 	bl	8004700 <tft_write_data>
	tft_write_data(0x00);
 80026a6:	4620      	mov	r0, r4
 80026a8:	f002 f82a 	bl	8004700 <tft_write_data>
	tft_write_data(0x7f);
 80026ac:	207f      	movs	r0, #127	; 0x7f
 80026ae:	f002 f827 	bl	8004700 <tft_write_data>

	tft_write_command(0x2B);
 80026b2:	202b      	movs	r0, #43	; 0x2b
 80026b4:	f002 f83c 	bl	8004730 <tft_write_command>
	tft_write_data(0x00);
 80026b8:	4620      	mov	r0, r4
 80026ba:	f002 f821 	bl	8004700 <tft_write_data>
	tft_write_data(0x00);
 80026be:	4620      	mov	r0, r4
 80026c0:	f002 f81e 	bl	8004700 <tft_write_data>
	tft_write_data(0x00);
 80026c4:	4620      	mov	r0, r4
 80026c6:	f002 f81b 	bl	8004700 <tft_write_data>
	tft_write_data(0x9f);
 80026ca:	209f      	movs	r0, #159	; 0x9f
 80026cc:	f002 f818 	bl	8004700 <tft_write_data>
	//------------------------------------End ST7735R Gamma Sequence-----------------------------------------//

	tft_write_command(0x3A);
 80026d0:	203a      	movs	r0, #58	; 0x3a
 80026d2:	f002 f82d 	bl	8004730 <tft_write_command>
	tft_write_data(0x05);
 80026d6:	2005      	movs	r0, #5
 80026d8:	f002 f812 	bl	8004700 <tft_write_data>
	tft_write_command(0x29);//Display on
 80026dc:	2029      	movs	r0, #41	; 0x29
 80026de:	f002 f827 	bl	8004730 <tft_write_command>

	chThdSleepMilliseconds(10);
 80026e2:	2064      	movs	r0, #100	; 0x64
 80026e4:	f000 ff3c 	bl	8003560 <chThdSleep>
  spiAcquireBus(TFT_SPI);
  spiStart(TFT_SPI, &TFTSPI_cfg);

  tft_reset();
  tft_config();
  tft_write_command(0x2C);
 80026e8:	202c      	movs	r0, #44	; 0x2c
 80026ea:	f002 f821 	bl	8004730 <tft_write_command>
  * @param  None
  * @retval None
  */
void tft_set_text_color(uint16_t in_text_color)
{
	curr_text_color = in_text_color;
 80026ee:	4a40      	ldr	r2, [pc, #256]	; (80027f0 <TFT_thread.lto_priv.53+0x490>)
  * @param  None
  * @retval None
  */
void tft_set_special_color(uint16_t text_color_sp)
{
	curr_text_color_sp = text_color_sp;
 80026f0:	4940      	ldr	r1, [pc, #256]	; (80027f4 <TFT_thread.lto_priv.53+0x494>)
  * @param  None
  * @retval None
  */
void tft_set_bg_color(uint16_t in_bg_color)
{
	curr_bg_color = in_bg_color;
 80026f2:	4b41      	ldr	r3, [pc, #260]	; (80027f8 <TFT_thread.lto_priv.53+0x498>)
  * @param  None
  * @retval None
  */
void tft_set_text_color(uint16_t in_text_color)
{
	curr_text_color = in_text_color;
 80026f4:	8014      	strh	r4, [r2, #0]
  */
void tft_fill_color(uint16_t color)
{
	uint16_t i;					//160*128

	tft_write_command(0x2a);		// Column addr set
 80026f6:	202a      	movs	r0, #42	; 0x2a
  * @param  None
  * @retval None
  */
void tft_set_bg_color(uint16_t in_bg_color)
{
	curr_bg_color = in_bg_color;
 80026f8:	f64f 4251 	movw	r2, #64593	; 0xfc51
  * @param  None
  * @retval None
  */
void tft_set_special_color(uint16_t text_color_sp)
{
	curr_text_color_sp = text_color_sp;
 80026fc:	800c      	strh	r4, [r1, #0]
  * @param  None
  * @retval None
  */
void tft_set_bg_color(uint16_t in_bg_color)
{
	curr_bg_color = in_bg_color;
 80026fe:	801a      	strh	r2, [r3, #0]
  */
void tft_fill_color(uint16_t color)
{
	uint16_t i;					//160*128

	tft_write_command(0x2a);		// Column addr set
 8002700:	f002 f816 	bl	8004730 <tft_write_command>
	tft_write_data(0x00);
 8002704:	4620      	mov	r0, r4
 8002706:	f001 fffb 	bl	8004700 <tft_write_data>
	tft_write_data(0x00); 				// X START
 800270a:	4620      	mov	r0, r4
 800270c:	f001 fff8 	bl	8004700 <tft_write_data>
	tft_write_data(0x00);
 8002710:	4620      	mov	r0, r4
 8002712:	f001 fff5 	bl	8004700 <tft_write_data>
	tft_write_data(0x7f); 			// X END
 8002716:	207f      	movs	r0, #127	; 0x7f
 8002718:	f001 fff2 	bl	8004700 <tft_write_data>

	tft_write_command(0x2b);		// Row addr set
 800271c:	202b      	movs	r0, #43	; 0x2b
 800271e:	f002 f807 	bl	8004730 <tft_write_command>
	tft_write_data(0x00);
 8002722:	4620      	mov	r0, r4
 8002724:	f001 ffec 	bl	8004700 <tft_write_data>
	tft_write_data(0x00);				// Y START
 8002728:	4620      	mov	r0, r4
 800272a:	f001 ffe9 	bl	8004700 <tft_write_data>
	tft_write_data(0x00);
 800272e:	4620      	mov	r0, r4
 8002730:	f001 ffe6 	bl	8004700 <tft_write_data>
	tft_write_data(0x9f);			// Y END
 8002734:	209f      	movs	r0, #159	; 0x9f
 8002736:	f001 ffe3 	bl	8004700 <tft_write_data>

	tft_write_command(0x2c); 		// write to RAM
 800273a:	202c      	movs	r0, #44	; 0x2c
 800273c:	f001 fff8 	bl	8004730 <tft_write_command>
 8002740:	f44f 44a0 	mov.w	r4, #20480	; 0x5000

  //spiSelect(TFT_SPI);
	for (i = 0; i < MAX_WIDTH*MAX_HEIGHT; i++) {
		tft_write_data(color >> 8);
 8002744:	20fc      	movs	r0, #252	; 0xfc
 8002746:	3c01      	subs	r4, #1
 8002748:	f001 ffda 	bl	8004700 <tft_write_data>
 800274c:	b2a4      	uxth	r4, r4
		tft_write_data(color);
 800274e:	2051      	movs	r0, #81	; 0x51
 8002750:	f001 ffd6 	bl	8004700 <tft_write_data>
	tft_write_data(0x9f);			// Y END

	tft_write_command(0x2c); 		// write to RAM

  //spiSelect(TFT_SPI);
	for (i = 0; i < MAX_WIDTH*MAX_HEIGHT; i++) {
 8002754:	2c00      	cmp	r4, #0
 8002756:	d1f5      	bne.n	8002744 <TFT_thread.lto_priv.53+0x3e4>

  tft_set_bg_color(in_bg_color);
	tft_set_text_color(in_text_color);
	tft_set_special_color(in_text_color_sp);
	tft_fill_color(in_bg_color);
	tft_orientation = orientation;
 8002758:	4928      	ldr	r1, [pc, #160]	; (80027fc <TFT_thread.lto_priv.53+0x49c>)
 800275a:	4d29      	ldr	r5, [pc, #164]	; (8002800 <TFT_thread.lto_priv.53+0x4a0>)
 800275c:	f8df b0bc 	ldr.w	fp, [pc, #188]	; 800281c <TFT_thread.lto_priv.53+0x4bc>
 8002760:	2201      	movs	r2, #1
 8002762:	4623      	mov	r3, r4
 8002764:	4620      	mov	r0, r4
	tft_write_data(0x00);
	tft_write_data(0x00);				// Y START
	tft_write_data(0x00);
	tft_write_data(0x9f);			// Y END

	tft_write_command(0x2c); 		// write to RAM
 8002766:	4626      	mov	r6, r4

  tft_set_bg_color(in_bg_color);
	tft_set_text_color(in_text_color);
	tft_set_special_color(in_text_color_sp);
	tft_fill_color(in_bg_color);
	tft_orientation = orientation;
 8002768:	700a      	strb	r2, [r1, #0]

  uint16_t x,y;
	for (x = 0; x < CHAR_MAX_X; x++) {
		for (y = 0; y < CHAR_MAX_Y; y++) {
			text[x][y] = ' ';
 800276a:	f04f 0a20 	mov.w	sl, #32
			text_color[x][y] = in_text_color;
			bg_color[x][y] = in_bg_color;
 800276e:	f64f 4951 	movw	r9, #64593	; 0xfc51
 8002772:	4c24      	ldr	r4, [pc, #144]	; (8002804 <TFT_thread.lto_priv.53+0x4a4>)
 8002774:	1e41      	subs	r1, r0, #1
 8002776:	eb05 0c01 	add.w	ip, r5, r1
 800277a:	4421      	add	r1, r4
 800277c:	4c22      	ldr	r4, [pc, #136]	; (8002808 <TFT_thread.lto_priv.53+0x4a8>)
 800277e:	9101      	str	r1, [sp, #4]
 8002780:	1e9a      	subs	r2, r3, #2
 8002782:	eb04 0e02 	add.w	lr, r4, r2
 8002786:	4921      	ldr	r1, [pc, #132]	; (800280c <TFT_thread.lto_priv.53+0x4ac>)
 8002788:	4c21      	ldr	r4, [pc, #132]	; (8002810 <TFT_thread.lto_priv.53+0x4b0>)
 800278a:	18a7      	adds	r7, r4, r2
 800278c:	eb0b 0402 	add.w	r4, fp, r2
 8002790:	440a      	add	r2, r1
 8002792:	9901      	ldr	r1, [sp, #4]
	tft_write_data(0x00);
	tft_write_data(0x00);				// Y START
	tft_write_data(0x00);
	tft_write_data(0x9f);			// Y END

	tft_write_command(0x2c); 		// write to RAM
 8002794:	f04f 0800 	mov.w	r8, #0
 8002798:	f108 0801 	add.w	r8, r8, #1
	tft_fill_color(in_bg_color);
	tft_orientation = orientation;

  uint16_t x,y;
	for (x = 0; x < CHAR_MAX_X; x++) {
		for (y = 0; y < CHAR_MAX_Y; y++) {
 800279c:	f1b8 0f0a 	cmp.w	r8, #10
			text[x][y] = ' ';
 80027a0:	f80c af01 	strb.w	sl, [ip, #1]!
			text_color[x][y] = in_text_color;
 80027a4:	f82e 6f02 	strh.w	r6, [lr, #2]!
			bg_color[x][y] = in_bg_color;
 80027a8:	f827 9f02 	strh.w	r9, [r7, #2]!

			text_prev[x][y] = ' ';
 80027ac:	f801 af01 	strb.w	sl, [r1, #1]!
			text_color_prev[x][y] = in_text_color;
 80027b0:	f824 6f02 	strh.w	r6, [r4, #2]!
			bg_color_prev[x][y] = in_bg_color;
 80027b4:	f822 9f02 	strh.w	r9, [r2, #2]!
	tft_fill_color(in_bg_color);
	tft_orientation = orientation;

  uint16_t x,y;
	for (x = 0; x < CHAR_MAX_X; x++) {
		for (y = 0; y < CHAR_MAX_Y; y++) {
 80027b8:	d1ee      	bne.n	8002798 <TFT_thread.lto_priv.53+0x438>
 80027ba:	300a      	adds	r0, #10
	tft_set_special_color(in_text_color_sp);
	tft_fill_color(in_bg_color);
	tft_orientation = orientation;

  uint16_t x,y;
	for (x = 0; x < CHAR_MAX_X; x++) {
 80027bc:	28c8      	cmp	r0, #200	; 0xc8
 80027be:	f103 0314 	add.w	r3, r3, #20
 80027c2:	d1d6      	bne.n	8002772 <TFT_thread.lto_priv.53+0x412>
  (void)p;
  chRegSetThreadName("TFT Display");

  tft_init(TFT_HORIZONTAL, CYAN, BLACK, BLACK);

  tft_printf(3,1,"Robomaster 2018");
 80027c4:	2003      	movs	r0, #3
 80027c6:	2101      	movs	r1, #1
 80027c8:	4a12      	ldr	r2, [pc, #72]	; (8002814 <TFT_thread.lto_priv.53+0x4b4>)
 80027ca:	f8df a054 	ldr.w	sl, [pc, #84]	; 8002820 <TFT_thread.lto_priv.53+0x4c0>
 80027ce:	f001 fd87 	bl	80042e0 <tft_printf.constprop.3>
  tft_printf(3,2,"TFTLCD");
 80027d2:	2003      	movs	r0, #3
 80027d4:	2102      	movs	r1, #2
 80027d6:	4a10      	ldr	r2, [pc, #64]	; (8002818 <TFT_thread.lto_priv.53+0x4b8>)
 80027d8:	f001 fd82 	bl	80042e0 <tft_printf.constprop.3>
	uint16_t clr;

	if (!tft_enabled)
		return;

	switch (tft_orientation) {
 80027dc:	4b07      	ldr	r3, [pc, #28]	; (80027fc <TFT_thread.lto_priv.53+0x49c>)
 80027de:	781b      	ldrb	r3, [r3, #0]
 80027e0:	e020      	b.n	8002824 <TFT_thread.lto_priv.53+0x4c4>
 80027e2:	bf00      	nop
 80027e4:	080057a0 	.word	0x080057a0
 80027e8:	20002740 	.word	0x20002740
 80027ec:	40020400 	.word	0x40020400
 80027f0:	20002f32 	.word	0x20002f32
 80027f4:	2000314c 	.word	0x2000314c
 80027f8:	20002f30 	.word	0x20002f30
 80027fc:	20000804 	.word	0x20000804
 8002800:	2000223c 	.word	0x2000223c
 8002804:	20002304 	.word	0x20002304
 8002808:	20002f38 	.word	0x20002f38
 800280c:	20003150 	.word	0x20003150
 8002810:	20002004 	.word	0x20002004
 8002814:	080067c4 	.word	0x080067c4
 8002818:	080067d4 	.word	0x080067d4
 800281c:	20002da0 	.word	0x20002da0
 8002820:	080057b0 	.word	0x080057b0
 8002824:	2b03      	cmp	r3, #3
 8002826:	f200 82ce 	bhi.w	8002dc6 <TFT_thread.lto_priv.53+0xa66>
 800282a:	e8df f013 	tbh	[pc, r3, lsl #1]
 800282e:	0221      	.short	0x0221
 8002830:	00f10194 	.word	0x00f10194
 8002834:	005f      	.short	0x005f
  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
#if STM32_SPI_USE_SPI1
    if (&SPID1 == spip) {
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 8002836:	6a28      	ldr	r0, [r5, #32]
 8002838:	499e      	ldr	r1, [pc, #632]	; (8002ab4 <TFT_thread.lto_priv.53+0x754>)
 800283a:	f001 fca1 	bl	8004180 <dmaStreamAllocate.constprop.22>
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
 800283e:	b9e8      	cbnz	r0, 800287c <TFT_thread.lto_priv.53+0x51c>
      b = dmaStreamAllocate(spip->dmatx,
 8002840:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8002842:	499d      	ldr	r1, [pc, #628]	; (8002ab8 <TFT_thread.lto_priv.53+0x758>)
 8002844:	f001 fc9c 	bl	8004180 <dmaStreamAllocate.constprop.22>
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
 8002848:	b9a0      	cbnz	r0, 8002874 <TFT_thread.lto_priv.53+0x514>
      rccEnableSPI1(FALSE);
 800284a:	489c      	ldr	r0, [pc, #624]	; (8002abc <TFT_thread.lto_priv.53+0x75c>)
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800284c:	6a2f      	ldr	r7, [r5, #32]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800284e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      b = dmaStreamAllocate(spip->dmatx,
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI1(FALSE);
 8002850:	6c41      	ldr	r1, [r0, #68]	; 0x44
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8002852:	69ea      	ldr	r2, [r5, #28]
 8002854:	f8d7 e000 	ldr.w	lr, [r7]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8002858:	681f      	ldr	r7, [r3, #0]
 800285a:	686b      	ldr	r3, [r5, #4]
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800285c:	320c      	adds	r2, #12
      b = dmaStreamAllocate(spip->dmatx,
                            STM32_SPI_SPI1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI1(FALSE);
 800285e:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 8002862:	6441      	str	r1, [r0, #68]	; 0x44
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 8002864:	f8ce 2008 	str.w	r2, [lr, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 8002868:	60ba      	str	r2, [r7, #8]
 800286a:	e5fe      	b.n	800246a <TFT_thread.lto_priv.53+0x10a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800286c:	b672      	cpsid	i
 800286e:	4a94      	ldr	r2, [pc, #592]	; (8002ac0 <TFT_thread.lto_priv.53+0x760>)
 8002870:	62da      	str	r2, [r3, #44]	; 0x2c
 8002872:	e7fe      	b.n	8002872 <TFT_thread.lto_priv.53+0x512>
 8002874:	b672      	cpsid	i
 8002876:	4b93      	ldr	r3, [pc, #588]	; (8002ac4 <TFT_thread.lto_priv.53+0x764>)
 8002878:	62f3      	str	r3, [r6, #44]	; 0x2c
 800287a:	e7fe      	b.n	800287a <TFT_thread.lto_priv.53+0x51a>
 800287c:	b672      	cpsid	i
 800287e:	4b91      	ldr	r3, [pc, #580]	; (8002ac4 <TFT_thread.lto_priv.53+0x764>)
 8002880:	62f3      	str	r3, [r6, #44]	; 0x2c
 8002882:	e7fe      	b.n	8002882 <TFT_thread.lto_priv.53+0x522>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8002884:	e890 000a 	ldmia.w	r0, {r1, r3}
 8002888:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800288a:	6807      	ldr	r7, [r0, #0]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800288c:	6a41      	ldr	r1, [r0, #36]	; 0x24
 800288e:	607b      	str	r3, [r7, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8002890:	460b      	mov	r3, r1
  do {
    cp = cp->p_next;
 8002892:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8002894:	4299      	cmp	r1, r3
 8002896:	d002      	beq.n	800289e <TFT_thread.lto_priv.53+0x53e>
 8002898:	689f      	ldr	r7, [r3, #8]
 800289a:	4297      	cmp	r7, r2
 800289c:	d2f9      	bcs.n	8002892 <TFT_thread.lto_priv.53+0x532>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800289e:	685a      	ldr	r2, [r3, #4]
 80028a0:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 80028a2:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80028a4:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 80028a6:	6058      	str	r0, [r3, #4]
 80028a8:	e58a      	b.n	80023c0 <TFT_thread.lto_priv.53+0x60>
      chSchGoSleepS(CH_STATE_WTMTX);

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->m_owner == ctp, "not owner");
      chDbgAssert(ctp->p_mtxlist == mp, "not owned");
 80028aa:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 80028ac:	429a      	cmp	r2, r3
 80028ae:	f43f ada8 	beq.w	8002402 <TFT_thread.lto_priv.53+0xa2>
 80028b2:	b672      	cpsid	i
 80028b4:	4b84      	ldr	r3, [pc, #528]	; (8002ac8 <TFT_thread.lto_priv.53+0x768>)
 80028b6:	62f3      	str	r3, [r6, #44]	; 0x2c
 80028b8:	e7fe      	b.n	80028b8 <TFT_thread.lto_priv.53+0x558>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80028ba:	e890 000a 	ldmia.w	r0, {r1, r3}
 80028be:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80028c0:	6807      	ldr	r7, [r0, #0]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 80028c2:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80028c4:	607b      	str	r3, [r7, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80028c6:	460b      	mov	r3, r1
  do {
    cp = cp->p_next;
 80028c8:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80028ca:	4299      	cmp	r1, r3
 80028cc:	d002      	beq.n	80028d4 <TFT_thread.lto_priv.53+0x574>
 80028ce:	689f      	ldr	r7, [r3, #8]
 80028d0:	4297      	cmp	r7, r2
 80028d2:	d2f9      	bcs.n	80028c8 <TFT_thread.lto_priv.53+0x568>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80028d4:	685a      	ldr	r2, [r3, #4]
 80028d6:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 80028d8:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80028da:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 80028dc:	6058      	str	r0, [r3, #4]
          tp = tp->p_u.wtmtxp->m_owner;
 80028de:	6888      	ldr	r0, [r1, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 80028e0:	68aa      	ldr	r2, [r5, #8]
 80028e2:	6883      	ldr	r3, [r0, #8]
 80028e4:	429a      	cmp	r2, r3
 80028e6:	f63f ad57 	bhi.w	8002398 <TFT_thread.lto_priv.53+0x38>
 80028ea:	e569      	b.n	80023c0 <TFT_thread.lto_priv.53+0x60>
 80028ec:	2313      	movs	r3, #19
 80028ee:	9307      	str	r3, [sp, #28]
 80028f0:	2300      	movs	r3, #0
 80028f2:	9304      	str	r3, [sp, #16]
								break;
							} else {
								char_n++;
							}
						}
						tft_set_char_pos(y*CHAR_HEIGHT, (CHAR_MAX_X_HORIZONTAL-x-1)*CHAR_WIDTH, (y+char_n)*CHAR_HEIGHT-1, (CHAR_MAX_X_HORIZONTAL-x)*CHAR_WIDTH-1);
 80028f4:	9b04      	ldr	r3, [sp, #16]
						x2 = x;

            for (px = 0; px < CHAR_WIDTH; px++) {
							for (py = 0; py < char_n*CHAR_HEIGHT; py++) {
								y2 = y+py/CHAR_HEIGHT;
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + (py % CHAR_HEIGHT)] & (0x80 >> (CHAR_WIDTH-px-1)) ? text_color[x2][y2] : bg_color[x2][y2];
 80028f6:	9907      	ldr	r1, [sp, #28]
								break;
							} else {
								char_n++;
							}
						}
						tft_set_char_pos(y*CHAR_HEIGHT, (CHAR_MAX_X_HORIZONTAL-x-1)*CHAR_WIDTH, (y+char_n)*CHAR_HEIGHT-1, (CHAR_MAX_X_HORIZONTAL-x)*CHAR_WIDTH-1);
 80028f8:	3307      	adds	r3, #7
 80028fa:	b2db      	uxtb	r3, r3
 80028fc:	9306      	str	r3, [sp, #24]
 80028fe:	b2cb      	uxtb	r3, r1
						x2 = x;

            for (px = 0; px < CHAR_WIDTH; px++) {
							for (py = 0; py < char_n*CHAR_HEIGHT; py++) {
								y2 = y+py/CHAR_HEIGHT;
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + (py % CHAR_HEIGHT)] & (0x80 >> (CHAR_WIDTH-px-1)) ? text_color[x2][y2] : bg_color[x2][y2];
 8002900:	eb01 0c81 	add.w	ip, r1, r1, lsl #2
 8002904:	9303      	str	r3, [sp, #12]
								break;
							} else {
								char_n++;
							}
						}
						tft_set_char_pos(y*CHAR_HEIGHT, (CHAR_MAX_X_HORIZONTAL-x-1)*CHAR_WIDTH, (y+char_n)*CHAR_HEIGHT-1, (CHAR_MAX_X_HORIZONTAL-x)*CHAR_WIDTH-1);
 8002906:	2300      	movs	r3, #0
						x2 = x;

            for (px = 0; px < CHAR_WIDTH; px++) {
							for (py = 0; py < char_n*CHAR_HEIGHT; py++) {
								y2 = y+py/CHAR_HEIGHT;
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + (py % CHAR_HEIGHT)] & (0x80 >> (CHAR_WIDTH-px-1)) ? text_color[x2][y2] : bg_color[x2][y2];
 8002908:	ea4f 064c 	mov.w	r6, ip, lsl #1
								break;
							} else {
								char_n++;
							}
						}
						tft_set_char_pos(y*CHAR_HEIGHT, (CHAR_MAX_X_HORIZONTAL-x-1)*CHAR_WIDTH, (y+char_n)*CHAR_HEIGHT-1, (CHAR_MAX_X_HORIZONTAL-x)*CHAR_WIDTH-1);
 800290c:	9301      	str	r3, [sp, #4]
			}
			break;
		case 3:
			for (x = CHAR_MAX_X_HORIZONTAL-1; x >= 0; x--) {
				for (y = 0; y < CHAR_MAX_Y_HORIZONTAL; y++) {
					if (tft_char_is_changed(x, y)) {
 800290e:	f89d 7004 	ldrb.w	r7, [sp, #4]
 8002912:	9803      	ldr	r0, [sp, #12]
 8002914:	4639      	mov	r1, r7
 8002916:	f001 fd6b 	bl	80043f0 <tft_char_is_changed>
 800291a:	2800      	cmp	r0, #0
 800291c:	f000 82ab 	beq.w	8002e76 <TFT_thread.lto_priv.53+0xb16>
						char_n = 1;
						while (y+char_n < CHAR_MAX_Y_HORIZONTAL && tft_char_is_changed(x, y+char_n)) {
 8002920:	f9bd 9004 	ldrsh.w	r9, [sp, #4]
 8002924:	f109 0b01 	add.w	fp, r9, #1
 8002928:	f1bb 0f07 	cmp.w	fp, #7
 800292c:	f300 82bc 	bgt.w	8002ea8 <TFT_thread.lto_priv.53+0xb48>
 8002930:	2401      	movs	r4, #1
 8002932:	46a0      	mov	r8, r4
 8002934:	9602      	str	r6, [sp, #8]
 8002936:	465e      	mov	r6, fp
 8002938:	46a3      	mov	fp, r4
 800293a:	464c      	mov	r4, r9
 800293c:	f8dd 900c 	ldr.w	r9, [sp, #12]
 8002940:	e007      	b.n	8002952 <TFT_thread.lto_priv.53+0x5f2>
 8002942:	fa1f f883 	uxth.w	r8, r3
 8002946:	fa0f fb88 	sxth.w	fp, r8
 800294a:	eb0b 0604 	add.w	r6, fp, r4
 800294e:	2e07      	cmp	r6, #7
 8002950:	dc09      	bgt.n	8002966 <TFT_thread.lto_priv.53+0x606>
 8002952:	eb07 0108 	add.w	r1, r7, r8
 8002956:	b2c9      	uxtb	r1, r1
 8002958:	4648      	mov	r0, r9
 800295a:	f001 fd49 	bl	80043f0 <tft_char_is_changed>
 800295e:	f108 0301 	add.w	r3, r8, #1
 8002962:	2800      	cmp	r0, #0
 8002964:	d1ed      	bne.n	8002942 <TFT_thread.lto_priv.53+0x5e2>
 8002966:	465c      	mov	r4, fp
 8002968:	fa1f f388 	uxth.w	r3, r8
 800296c:	46b3      	mov	fp, r6
 800296e:	9e02      	ldr	r6, [sp, #8]
 8002970:	9305      	str	r3, [sp, #20]
 8002972:	0124      	lsls	r4, r4, #4
								break;
							} else {
								char_n++;
							}
						}
						tft_set_char_pos(y*CHAR_HEIGHT, (CHAR_MAX_X_HORIZONTAL-x-1)*CHAR_WIDTH, (y+char_n)*CHAR_HEIGHT-1, (CHAR_MAX_X_HORIZONTAL-x)*CHAR_WIDTH-1);
 8002974:	9f01      	ldr	r7, [sp, #4]
 8002976:	9b06      	ldr	r3, [sp, #24]
 8002978:	9904      	ldr	r1, [sp, #16]
 800297a:	ea4f 120b 	mov.w	r2, fp, lsl #4
 800297e:	0138      	lsls	r0, r7, #4
 8002980:	3a01      	subs	r2, #1
 8002982:	b2d2      	uxtb	r2, r2
 8002984:	f000 00f0 	and.w	r0, r0, #240	; 0xf0
 8002988:	b2bf      	uxth	r7, r7
 800298a:	9701      	str	r7, [sp, #4]
 800298c:	f001 fee8 	bl	8004760 <tft_set_char_pos>
 8002990:	2307      	movs	r3, #7
 8002992:	9302      	str	r3, [sp, #8]
 8002994:	46b3      	mov	fp, r6
						x2 = x;

            for (px = 0; px < CHAR_WIDTH; px++) {
							for (py = 0; py < char_n*CHAR_HEIGHT; py++) {
 8002996:	2c00      	cmp	r4, #0
 8002998:	f340 825f 	ble.w	8002e5a <TFT_thread.lto_priv.53+0xafa>
 800299c:	9b02      	ldr	r3, [sp, #8]
 800299e:	2780      	movs	r7, #128	; 0x80
 80029a0:	2600      	movs	r6, #0
 80029a2:	411f      	asrs	r7, r3
 80029a4:	4630      	mov	r0, r6
								y2 = y+py/CHAR_HEIGHT;
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + (py % CHAR_HEIGHT)] & (0x80 >> (CHAR_WIDTH-px-1)) ? text_color[x2][y2] : bg_color[x2][y2];
 80029a6:	f04f 0810 	mov.w	r8, #16
 80029aa:	e01a      	b.n	80029e2 <TFT_thread.lto_priv.53+0x682>
 80029ac:	b21b      	sxth	r3, r3
 80029ae:	fb18 3300 	smlabb	r3, r8, r0, r3
 80029b2:	3601      	adds	r6, #1
 80029b4:	f81a 3003 	ldrb.w	r3, [sl, r3]
 80029b8:	423b      	tst	r3, r7
 80029ba:	bf15      	itete	ne
 80029bc:	4b43      	ldrne	r3, [pc, #268]	; (8002acc <TFT_thread.lto_priv.53+0x76c>)
 80029be:	4b44      	ldreq	r3, [pc, #272]	; (8002ad0 <TFT_thread.lto_priv.53+0x770>)
 80029c0:	f833 9011 	ldrhne.w	r9, [r3, r1, lsl #1]
 80029c4:	f833 9012 	ldrheq.w	r9, [r3, r2, lsl #1]
								tft_write_data(clr >> 8);
 80029c8:	ea4f 2019 	mov.w	r0, r9, lsr #8
 80029cc:	f001 fe98 	bl	8004700 <tft_write_data>
 80029d0:	b2b6      	uxth	r6, r6
								tft_write_data(clr);
 80029d2:	fa5f f089 	uxtb.w	r0, r9
 80029d6:	f001 fe93 	bl	8004700 <tft_write_data>
						}
						tft_set_char_pos(y*CHAR_HEIGHT, (CHAR_MAX_X_HORIZONTAL-x-1)*CHAR_WIDTH, (y+char_n)*CHAR_HEIGHT-1, (CHAR_MAX_X_HORIZONTAL-x)*CHAR_WIDTH-1);
						x2 = x;

            for (px = 0; px < CHAR_WIDTH; px++) {
							for (py = 0; py < char_n*CHAR_HEIGHT; py++) {
 80029da:	b230      	sxth	r0, r6
 80029dc:	42a0      	cmp	r0, r4
 80029de:	f280 823c 	bge.w	8002e5a <TFT_thread.lto_priv.53+0xafa>
								y2 = y+py/CHAR_HEIGHT;
 80029e2:	2800      	cmp	r0, #0
 80029e4:	9901      	ldr	r1, [sp, #4]
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + (py % CHAR_HEIGHT)] & (0x80 >> (CHAR_WIDTH-px-1)) ? text_color[x2][y2] : bg_color[x2][y2];
 80029e6:	4b3b      	ldr	r3, [pc, #236]	; (8002ad4 <TFT_thread.lto_priv.53+0x774>)
						tft_set_char_pos(y*CHAR_HEIGHT, (CHAR_MAX_X_HORIZONTAL-x-1)*CHAR_WIDTH, (y+char_n)*CHAR_HEIGHT-1, (CHAR_MAX_X_HORIZONTAL-x)*CHAR_WIDTH-1);
						x2 = x;

            for (px = 0; px < CHAR_WIDTH; px++) {
							for (py = 0; py < char_n*CHAR_HEIGHT; py++) {
								y2 = y+py/CHAR_HEIGHT;
 80029e8:	4602      	mov	r2, r0
 80029ea:	bfb8      	it	lt
 80029ec:	f100 020f 	addlt.w	r2, r0, #15
 80029f0:	eb01 1222 	add.w	r2, r1, r2, asr #4
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + (py % CHAR_HEIGHT)] & (0x80 >> (CHAR_WIDTH-px-1)) ? text_color[x2][y2] : bg_color[x2][y2];
 80029f4:	b212      	sxth	r2, r2
 80029f6:	4003      	ands	r3, r0
 80029f8:	eb0b 0002 	add.w	r0, fp, r2
 80029fc:	4601      	mov	r1, r0
 80029fe:	2b00      	cmp	r3, #0
 8002a00:	5c28      	ldrb	r0, [r5, r0]
 8002a02:	460a      	mov	r2, r1
 8002a04:	dad2      	bge.n	80029ac <TFT_thread.lto_priv.53+0x64c>
 8002a06:	3b01      	subs	r3, #1
 8002a08:	f063 030f 	orn	r3, r3, #15
 8002a0c:	3301      	adds	r3, #1
 8002a0e:	e7cd      	b.n	80029ac <TFT_thread.lto_priv.53+0x64c>
	uint16_t clr;

	if (!tft_enabled)
		return;

	switch (tft_orientation) {
 8002a10:	2300      	movs	r3, #0
 8002a12:	f04f 0b09 	mov.w	fp, #9
 8002a16:	9303      	str	r3, [sp, #12]
								break;
							} else {
								char_n++;
							}
						}
						tft_set_char_pos((CHAR_MAX_X_VERTICAL-x-1)*CHAR_WIDTH, (CHAR_MAX_Y_VERTICAL-y-1)*CHAR_HEIGHT, (CHAR_MAX_X_VERTICAL-x-1+char_n)*CHAR_WIDTH-1, (CHAR_MAX_Y_VERTICAL-y)*CHAR_HEIGHT-1);
 8002a18:	9b03      	ldr	r3, [sp, #12]
 8002a1a:	330f      	adds	r3, #15
 8002a1c:	b2db      	uxtb	r3, r3
 8002a1e:	9305      	str	r3, [sp, #20]
 8002a20:	fa5f f38b 	uxtb.w	r3, fp
 8002a24:	9302      	str	r3, [sp, #8]
 8002a26:	260f      	movs	r6, #15
			}
			break;
		case 2:
			for (y = CHAR_MAX_Y_VERTICAL-1; y >= 0; y--) {
				for (x = CHAR_MAX_X_VERTICAL-1; x >= 0; x--) {
					if (tft_char_is_changed(x, y)) {
 8002a28:	b2f7      	uxtb	r7, r6
 8002a2a:	4638      	mov	r0, r7
 8002a2c:	9902      	ldr	r1, [sp, #8]
 8002a2e:	f001 fcdf 	bl	80043f0 <tft_char_is_changed>
 8002a32:	2800      	cmp	r0, #0
 8002a34:	f000 81df 	beq.w	8002df6 <TFT_thread.lto_priv.53+0xa96>
						char_n = 1;
						while (x-char_n > -1 && tft_char_is_changed(x-char_n, y)) {
 8002a38:	b234      	sxth	r4, r6
 8002a3a:	2c00      	cmp	r4, #0
 8002a3c:	f340 8241 	ble.w	8002ec2 <TFT_thread.lto_priv.53+0xb62>
 8002a40:	f04f 0901 	mov.w	r9, #1
 8002a44:	9601      	str	r6, [sp, #4]
 8002a46:	46c8      	mov	r8, r9
 8002a48:	4626      	mov	r6, r4
 8002a4a:	9c02      	ldr	r4, [sp, #8]
 8002a4c:	e007      	b.n	8002a5e <TFT_thread.lto_priv.53+0x6fe>
 8002a4e:	fa1f f883 	uxth.w	r8, r3
 8002a52:	fa0f f988 	sxth.w	r9, r8
 8002a56:	ebc9 0306 	rsb	r3, r9, r6
 8002a5a:	2b00      	cmp	r3, #0
 8002a5c:	db09      	blt.n	8002a72 <TFT_thread.lto_priv.53+0x712>
 8002a5e:	ebc8 0007 	rsb	r0, r8, r7
 8002a62:	b2c0      	uxtb	r0, r0
 8002a64:	4621      	mov	r1, r4
 8002a66:	f001 fcc3 	bl	80043f0 <tft_char_is_changed>
 8002a6a:	f108 0301 	add.w	r3, r8, #1
 8002a6e:	2800      	cmp	r0, #0
 8002a70:	d1ed      	bne.n	8002a4e <TFT_thread.lto_priv.53+0x6ee>
 8002a72:	4634      	mov	r4, r6
 8002a74:	fa1f f388 	uxth.w	r3, r8
 8002a78:	9e01      	ldr	r6, [sp, #4]
 8002a7a:	9304      	str	r3, [sp, #16]
 8002a7c:	ea4f 07c9 	mov.w	r7, r9, lsl #3
								break;
							} else {
								char_n++;
							}
						}
						tft_set_char_pos((CHAR_MAX_X_VERTICAL-x-1)*CHAR_WIDTH, (CHAR_MAX_Y_VERTICAL-y-1)*CHAR_HEIGHT, (CHAR_MAX_X_VERTICAL-x-1+char_n)*CHAR_WIDTH-1, (CHAR_MAX_Y_VERTICAL-y)*CHAR_HEIGHT-1);
 8002a80:	f1c4 040f 	rsb	r4, r4, #15
 8002a84:	eb04 0209 	add.w	r2, r4, r9
 8002a88:	00d2      	lsls	r2, r2, #3
 8002a8a:	00e0      	lsls	r0, r4, #3
 8002a8c:	3a01      	subs	r2, #1
 8002a8e:	b2b4      	uxth	r4, r6
 8002a90:	b2d2      	uxtb	r2, r2
 8002a92:	f000 00f8 	and.w	r0, r0, #248	; 0xf8
 8002a96:	9903      	ldr	r1, [sp, #12]
 8002a98:	9b05      	ldr	r3, [sp, #20]
 8002a9a:	9401      	str	r4, [sp, #4]
 8002a9c:	f001 fe60 	bl	8004760 <tft_set_char_pos>
 8002aa0:	240f      	movs	r4, #15
						y2 = y;

            for (py = 0; py < CHAR_HEIGHT; py++) {
							for (px = 0; px < char_n*CHAR_WIDTH; px++) {
 8002aa2:	2f00      	cmp	r7, #0
 8002aa4:	f340 819e 	ble.w	8002de4 <TFT_thread.lto_priv.53+0xa84>
 8002aa8:	f04f 0900 	mov.w	r9, #0
								x2 = x-px/CHAR_WIDTH;
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + (CHAR_HEIGHT-py-1)] & (0x80 >> (CHAR_WIDTH-(px % CHAR_WIDTH)-1)) ? text_color[x2][y2] : bg_color[x2][y2];
 8002aac:	2680      	movs	r6, #128	; 0x80
 8002aae:	4649      	mov	r1, r9
 8002ab0:	e032      	b.n	8002b18 <TFT_thread.lto_priv.53+0x7b8>
 8002ab2:	bf00      	nop
 8002ab4:	08000bb1 	.word	0x08000bb1
 8002ab8:	08000751 	.word	0x08000751
 8002abc:	40023800 	.word	0x40023800
 8002ac0:	08006bc0 	.word	0x08006bc0
 8002ac4:	08005780 	.word	0x08005780
 8002ac8:	080067e0 	.word	0x080067e0
 8002acc:	20002f38 	.word	0x20002f38
 8002ad0:	20002004 	.word	0x20002004
 8002ad4:	8000000f 	.word	0x8000000f
 8002ad8:	b212      	sxth	r2, r2
 8002ada:	f81a 0000 	ldrb.w	r0, [sl, r0]
 8002ade:	f1c2 0207 	rsb	r2, r2, #7
 8002ae2:	fa46 f202 	asr.w	r2, r6, r2
 8002ae6:	4202      	tst	r2, r0
 8002ae8:	bf15      	itete	ne
 8002aea:	4bb9      	ldrne	r3, [pc, #740]	; (8002dd0 <TFT_thread.lto_priv.53+0xa70>)
 8002aec:	4ab9      	ldreq	r2, [pc, #740]	; (8002dd4 <TFT_thread.lto_priv.53+0xa74>)
 8002aee:	f833 8011 	ldrhne.w	r8, [r3, r1, lsl #1]
 8002af2:	f832 8013 	ldrheq.w	r8, [r2, r3, lsl #1]
 8002af6:	f109 0901 	add.w	r9, r9, #1
								tft_write_data(clr >> 8);
 8002afa:	ea4f 2018 	mov.w	r0, r8, lsr #8
 8002afe:	f001 fdff 	bl	8004700 <tft_write_data>
 8002b02:	fa1f f989 	uxth.w	r9, r9
								tft_write_data(clr);
 8002b06:	fa5f f088 	uxtb.w	r0, r8
 8002b0a:	f001 fdf9 	bl	8004700 <tft_write_data>
						}
						tft_set_char_pos((CHAR_MAX_X_VERTICAL-x-1)*CHAR_WIDTH, (CHAR_MAX_Y_VERTICAL-y-1)*CHAR_HEIGHT, (CHAR_MAX_X_VERTICAL-x-1+char_n)*CHAR_WIDTH-1, (CHAR_MAX_Y_VERTICAL-y)*CHAR_HEIGHT-1);
						y2 = y;

            for (py = 0; py < CHAR_HEIGHT; py++) {
							for (px = 0; px < char_n*CHAR_WIDTH; px++) {
 8002b0e:	fa0f f189 	sxth.w	r1, r9
 8002b12:	42b9      	cmp	r1, r7
 8002b14:	f280 8166 	bge.w	8002de4 <TFT_thread.lto_priv.53+0xa84>
								x2 = x-px/CHAR_WIDTH;
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + (CHAR_HEIGHT-py-1)] & (0x80 >> (CHAR_WIDTH-(px % CHAR_WIDTH)-1)) ? text_color[x2][y2] : bg_color[x2][y2];
 8002b18:	4aaf      	ldr	r2, [pc, #700]	; (8002dd8 <TFT_thread.lto_priv.53+0xa78>)
						tft_set_char_pos((CHAR_MAX_X_VERTICAL-x-1)*CHAR_WIDTH, (CHAR_MAX_Y_VERTICAL-y-1)*CHAR_HEIGHT, (CHAR_MAX_X_VERTICAL-x-1+char_n)*CHAR_WIDTH-1, (CHAR_MAX_Y_VERTICAL-y)*CHAR_HEIGHT-1);
						y2 = y;

            for (py = 0; py < CHAR_HEIGHT; py++) {
							for (px = 0; px < char_n*CHAR_WIDTH; px++) {
								x2 = x-px/CHAR_WIDTH;
 8002b1a:	2900      	cmp	r1, #0
 8002b1c:	460b      	mov	r3, r1
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + (CHAR_HEIGHT-py-1)] & (0x80 >> (CHAR_WIDTH-(px % CHAR_WIDTH)-1)) ? text_color[x2][y2] : bg_color[x2][y2];
 8002b1e:	ea02 0201 	and.w	r2, r2, r1
						tft_set_char_pos((CHAR_MAX_X_VERTICAL-x-1)*CHAR_WIDTH, (CHAR_MAX_Y_VERTICAL-y-1)*CHAR_HEIGHT, (CHAR_MAX_X_VERTICAL-x-1+char_n)*CHAR_WIDTH-1, (CHAR_MAX_Y_VERTICAL-y)*CHAR_HEIGHT-1);
						y2 = y;

            for (py = 0; py < CHAR_HEIGHT; py++) {
							for (px = 0; px < char_n*CHAR_WIDTH; px++) {
								x2 = x-px/CHAR_WIDTH;
 8002b22:	bfb8      	it	lt
 8002b24:	1dcb      	addlt	r3, r1, #7
 8002b26:	9901      	ldr	r1, [sp, #4]
 8002b28:	eba1 03e3 	sub.w	r3, r1, r3, asr #3
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + (CHAR_HEIGHT-py-1)] & (0x80 >> (CHAR_WIDTH-(px % CHAR_WIDTH)-1)) ? text_color[x2][y2] : bg_color[x2][y2];
 8002b2c:	b21b      	sxth	r3, r3
 8002b2e:	ea4f 0e83 	mov.w	lr, r3, lsl #2
 8002b32:	eb0e 0003 	add.w	r0, lr, r3
 8002b36:	eb0b 0040 	add.w	r0, fp, r0, lsl #1
 8002b3a:	4601      	mov	r1, r0
 8002b3c:	5c28      	ldrb	r0, [r5, r0]
 8002b3e:	f04f 0e10 	mov.w	lr, #16
 8002b42:	2a00      	cmp	r2, #0
 8002b44:	fb1e 4000 	smlabb	r0, lr, r0, r4
 8002b48:	460b      	mov	r3, r1
 8002b4a:	dac5      	bge.n	8002ad8 <TFT_thread.lto_priv.53+0x778>
 8002b4c:	3a01      	subs	r2, #1
 8002b4e:	f062 0207 	orn	r2, r2, #7
 8002b52:	3201      	adds	r2, #1
 8002b54:	e7c0      	b.n	8002ad8 <TFT_thread.lto_priv.53+0x778>
	uint16_t clr;

	if (!tft_enabled)
		return;

	switch (tft_orientation) {
 8002b56:	2307      	movs	r3, #7
 8002b58:	9305      	str	r3, [sp, #20]
 8002b5a:	2300      	movs	r3, #0
 8002b5c:	9303      	str	r3, [sp, #12]
 8002b5e:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8002b62:	9302      	str	r3, [sp, #8]
 8002b64:	00db      	lsls	r3, r3, #3
 8002b66:	b2db      	uxtb	r3, r3
 8002b68:	9306      	str	r3, [sp, #24]
								break;
							} else {
								char_n++;
							}
						}
						tft_set_char_pos((CHAR_MAX_Y_HORIZONTAL-y-1)*CHAR_HEIGHT, x*CHAR_WIDTH, (CHAR_MAX_Y_HORIZONTAL-y-1+char_n)*CHAR_HEIGHT-1, (x+1)*CHAR_WIDTH-1);
 8002b6a:	2407      	movs	r4, #7
			}
			break;
		case 1:
			for (x = 0; x < CHAR_MAX_X_HORIZONTAL; x++) {
				for (y = CHAR_MAX_Y_HORIZONTAL-1; y >= 0; y--) {
					if (tft_char_is_changed(x, y)) {
 8002b6c:	b2e6      	uxtb	r6, r4
 8002b6e:	4631      	mov	r1, r6
 8002b70:	9802      	ldr	r0, [sp, #8]
 8002b72:	f001 fc3d 	bl	80043f0 <tft_char_is_changed>
 8002b76:	2800      	cmp	r0, #0
 8002b78:	f000 815b 	beq.w	8002e32 <TFT_thread.lto_priv.53+0xad2>
						char_n = 1;
						while (y-char_n > -1 && tft_char_is_changed(x, y-char_n)) {
 8002b7c:	b227      	sxth	r7, r4
 8002b7e:	2f00      	cmp	r7, #0
 8002b80:	f340 8196 	ble.w	8002eb0 <TFT_thread.lto_priv.53+0xb50>
 8002b84:	f04f 0b01 	mov.w	fp, #1
 8002b88:	46d8      	mov	r8, fp
 8002b8a:	f8dd 9008 	ldr.w	r9, [sp, #8]
 8002b8e:	e007      	b.n	8002ba0 <TFT_thread.lto_priv.53+0x840>
 8002b90:	fa1f f883 	uxth.w	r8, r3
 8002b94:	fa0f fb88 	sxth.w	fp, r8
 8002b98:	ebcb 0307 	rsb	r3, fp, r7
 8002b9c:	2b00      	cmp	r3, #0
 8002b9e:	db09      	blt.n	8002bb4 <TFT_thread.lto_priv.53+0x854>
 8002ba0:	ebc8 0106 	rsb	r1, r8, r6
 8002ba4:	b2c9      	uxtb	r1, r1
 8002ba6:	4648      	mov	r0, r9
 8002ba8:	f001 fc22 	bl	80043f0 <tft_char_is_changed>
 8002bac:	f108 0301 	add.w	r3, r8, #1
 8002bb0:	2800      	cmp	r0, #0
 8002bb2:	d1ed      	bne.n	8002b90 <TFT_thread.lto_priv.53+0x830>
 8002bb4:	fa1f f388 	uxth.w	r3, r8
 8002bb8:	9304      	str	r3, [sp, #16]
 8002bba:	ea4f 160b 	mov.w	r6, fp, lsl #4
								break;
							} else {
								char_n++;
							}
						}
						tft_set_char_pos((CHAR_MAX_Y_HORIZONTAL-y-1)*CHAR_HEIGHT, x*CHAR_WIDTH, (CHAR_MAX_Y_HORIZONTAL-y-1+char_n)*CHAR_HEIGHT-1, (x+1)*CHAR_WIDTH-1);
 8002bbe:	f1c7 0707 	rsb	r7, r7, #7
 8002bc2:	eb07 020b 	add.w	r2, r7, fp
 8002bc6:	0112      	lsls	r2, r2, #4
 8002bc8:	3a01      	subs	r2, #1
 8002bca:	0138      	lsls	r0, r7, #4
 8002bcc:	9906      	ldr	r1, [sp, #24]
 8002bce:	9b05      	ldr	r3, [sp, #20]
 8002bd0:	b2d2      	uxtb	r2, r2
 8002bd2:	f000 00f0 	and.w	r0, r0, #240	; 0xf0
 8002bd6:	f001 fdc3 	bl	8004760 <tft_set_char_pos>
						x2 = x;

            for (px = 0; px < CHAR_WIDTH; px++) {
							for (py = 0; py < char_n*CHAR_HEIGHT; py++) {
								y2 = y-py/CHAR_HEIGHT;
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + CHAR_HEIGHT-(py % CHAR_HEIGHT)-1] & (0x80 >> px) ? text_color[x2][y2] : bg_color[x2][y2];
 8002bda:	9b03      	ldr	r3, [sp, #12]
 8002bdc:	eb03 0183 	add.w	r1, r3, r3, lsl #2
								break;
							} else {
								char_n++;
							}
						}
						tft_set_char_pos((CHAR_MAX_Y_HORIZONTAL-y-1)*CHAR_HEIGHT, x*CHAR_WIDTH, (CHAR_MAX_Y_HORIZONTAL-y-1+char_n)*CHAR_HEIGHT-1, (x+1)*CHAR_WIDTH-1);
 8002be0:	2300      	movs	r3, #0
 8002be2:	b2a4      	uxth	r4, r4
						x2 = x;

            for (px = 0; px < CHAR_WIDTH; px++) {
							for (py = 0; py < char_n*CHAR_HEIGHT; py++) {
								y2 = y-py/CHAR_HEIGHT;
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + CHAR_HEIGHT-(py % CHAR_HEIGHT)-1] & (0x80 >> px) ? text_color[x2][y2] : bg_color[x2][y2];
 8002be4:	ea4f 0b41 	mov.w	fp, r1, lsl #1
								break;
							} else {
								char_n++;
							}
						}
						tft_set_char_pos((CHAR_MAX_Y_HORIZONTAL-y-1)*CHAR_HEIGHT, x*CHAR_WIDTH, (CHAR_MAX_Y_HORIZONTAL-y-1+char_n)*CHAR_HEIGHT-1, (x+1)*CHAR_WIDTH-1);
 8002be8:	9301      	str	r3, [sp, #4]
						x2 = x;

            for (px = 0; px < CHAR_WIDTH; px++) {
							for (py = 0; py < char_n*CHAR_HEIGHT; py++) {
 8002bea:	2e00      	cmp	r6, #0
 8002bec:	f340 8117 	ble.w	8002e1e <TFT_thread.lto_priv.53+0xabe>
 8002bf0:	9b01      	ldr	r3, [sp, #4]
 8002bf2:	f04f 0900 	mov.w	r9, #0
 8002bf6:	2280      	movs	r2, #128	; 0x80
 8002bf8:	4649      	mov	r1, r9
 8002bfa:	fa42 f703 	asr.w	r7, r2, r3
 8002bfe:	e01f      	b.n	8002c40 <TFT_thread.lto_priv.53+0x8e0>
								y2 = y-py/CHAR_HEIGHT;
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + CHAR_HEIGHT-(py % CHAR_HEIGHT)-1] & (0x80 >> px) ? text_color[x2][y2] : bg_color[x2][y2];
 8002c00:	b21b      	sxth	r3, r3
 8002c02:	ebc3 1300 	rsb	r3, r3, r0, lsl #4
 8002c06:	4875      	ldr	r0, [pc, #468]	; (8002ddc <TFT_thread.lto_priv.53+0xa7c>)
 8002c08:	4403      	add	r3, r0
 8002c0a:	f109 0901 	add.w	r9, r9, #1
 8002c0e:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 8002c12:	423b      	tst	r3, r7
 8002c14:	bf15      	itete	ne
 8002c16:	4b6e      	ldrne	r3, [pc, #440]	; (8002dd0 <TFT_thread.lto_priv.53+0xa70>)
 8002c18:	4b6e      	ldreq	r3, [pc, #440]	; (8002dd4 <TFT_thread.lto_priv.53+0xa74>)
 8002c1a:	f833 8011 	ldrhne.w	r8, [r3, r1, lsl #1]
 8002c1e:	f833 8012 	ldrheq.w	r8, [r3, r2, lsl #1]
								tft_write_data(clr >> 8);
 8002c22:	ea4f 2018 	mov.w	r0, r8, lsr #8
 8002c26:	f001 fd6b 	bl	8004700 <tft_write_data>
 8002c2a:	fa1f f989 	uxth.w	r9, r9
								tft_write_data(clr);
 8002c2e:	fa5f f088 	uxtb.w	r0, r8
 8002c32:	f001 fd65 	bl	8004700 <tft_write_data>
						}
						tft_set_char_pos((CHAR_MAX_Y_HORIZONTAL-y-1)*CHAR_HEIGHT, x*CHAR_WIDTH, (CHAR_MAX_Y_HORIZONTAL-y-1+char_n)*CHAR_HEIGHT-1, (x+1)*CHAR_WIDTH-1);
						x2 = x;

            for (px = 0; px < CHAR_WIDTH; px++) {
							for (py = 0; py < char_n*CHAR_HEIGHT; py++) {
 8002c36:	fa0f f189 	sxth.w	r1, r9
 8002c3a:	42b1      	cmp	r1, r6
 8002c3c:	f280 80ef 	bge.w	8002e1e <TFT_thread.lto_priv.53+0xabe>
								y2 = y-py/CHAR_HEIGHT;
 8002c40:	2900      	cmp	r1, #0
 8002c42:	460a      	mov	r2, r1
 8002c44:	bfb8      	it	lt
 8002c46:	f101 020f 	addlt.w	r2, r1, #15
 8002c4a:	eba4 1222 	sub.w	r2, r4, r2, asr #4
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + CHAR_HEIGHT-(py % CHAR_HEIGHT)-1] & (0x80 >> px) ? text_color[x2][y2] : bg_color[x2][y2];
 8002c4e:	b212      	sxth	r2, r2
 8002c50:	eb0b 0002 	add.w	r0, fp, r2
 8002c54:	4b62      	ldr	r3, [pc, #392]	; (8002de0 <TFT_thread.lto_priv.53+0xa80>)
 8002c56:	400b      	ands	r3, r1
 8002c58:	4601      	mov	r1, r0
 8002c5a:	5c28      	ldrb	r0, [r5, r0]
 8002c5c:	2b00      	cmp	r3, #0
 8002c5e:	f100 0001 	add.w	r0, r0, #1
 8002c62:	460a      	mov	r2, r1
 8002c64:	dacc      	bge.n	8002c00 <TFT_thread.lto_priv.53+0x8a0>
 8002c66:	3b01      	subs	r3, #1
 8002c68:	f063 030f 	orn	r3, r3, #15
 8002c6c:	3301      	adds	r3, #1
 8002c6e:	e7c7      	b.n	8002c00 <TFT_thread.lto_priv.53+0x8a0>
	uint16_t clr;

	if (!tft_enabled)
		return;

	switch (tft_orientation) {
 8002c70:	230f      	movs	r3, #15
 8002c72:	9303      	str	r3, [sp, #12]
 8002c74:	f04f 0b00 	mov.w	fp, #0
 8002c78:	fa5f f38b 	uxtb.w	r3, fp
 8002c7c:	9302      	str	r3, [sp, #8]
 8002c7e:	011b      	lsls	r3, r3, #4
 8002c80:	b2db      	uxtb	r3, r3
 8002c82:	9305      	str	r3, [sp, #20]
								break;
							} else {
								char_n++;
							}
						}
						tft_set_char_pos(x*CHAR_WIDTH, y*CHAR_HEIGHT, (x+char_n)*CHAR_WIDTH-1, (y+1)*CHAR_HEIGHT-1);
 8002c84:	2300      	movs	r3, #0
 8002c86:	9301      	str	r3, [sp, #4]

	switch (tft_orientation) {
		case 0:
			for (y = 0; y < CHAR_MAX_Y_VERTICAL; y++) {
				for (x = 0; x < CHAR_MAX_X_VERTICAL; x++) {
					if (tft_char_is_changed(x, y)) {
 8002c88:	f89d 4004 	ldrb.w	r4, [sp, #4]
 8002c8c:	9902      	ldr	r1, [sp, #8]
 8002c8e:	4620      	mov	r0, r4
 8002c90:	f001 fbae 	bl	80043f0 <tft_char_is_changed>
 8002c94:	2800      	cmp	r0, #0
 8002c96:	f000 8084 	beq.w	8002da2 <TFT_thread.lto_priv.53+0xa42>
						char_n = 1;
						while (x+char_n < CHAR_MAX_X_VERTICAL && tft_char_is_changed(x+char_n, y)) {
 8002c9a:	f9bd 8004 	ldrsh.w	r8, [sp, #4]
 8002c9e:	f108 0901 	add.w	r9, r8, #1
 8002ca2:	f1b9 0f0f 	cmp.w	r9, #15
 8002ca6:	f300 8108 	bgt.w	8002eba <TFT_thread.lto_priv.53+0xb5a>
 8002caa:	2601      	movs	r6, #1
 8002cac:	4637      	mov	r7, r6
 8002cae:	f8cd b010 	str.w	fp, [sp, #16]
 8002cb2:	46cb      	mov	fp, r9
 8002cb4:	46b1      	mov	r9, r6
 8002cb6:	4646      	mov	r6, r8
 8002cb8:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8002cbc:	e007      	b.n	8002cce <TFT_thread.lto_priv.53+0x96e>
 8002cbe:	b29f      	uxth	r7, r3
 8002cc0:	fa0f f987 	sxth.w	r9, r7
 8002cc4:	eb09 0b06 	add.w	fp, r9, r6
 8002cc8:	f1bb 0f0f 	cmp.w	fp, #15
 8002ccc:	dc07      	bgt.n	8002cde <TFT_thread.lto_priv.53+0x97e>
 8002cce:	19e0      	adds	r0, r4, r7
 8002cd0:	b2c0      	uxtb	r0, r0
 8002cd2:	4641      	mov	r1, r8
 8002cd4:	f001 fb8c 	bl	80043f0 <tft_char_is_changed>
 8002cd8:	1c7b      	adds	r3, r7, #1
 8002cda:	2800      	cmp	r0, #0
 8002cdc:	d1ef      	bne.n	8002cbe <TFT_thread.lto_priv.53+0x95e>
 8002cde:	464e      	mov	r6, r9
 8002ce0:	b2bb      	uxth	r3, r7
 8002ce2:	46d9      	mov	r9, fp
 8002ce4:	00f6      	lsls	r6, r6, #3
 8002ce6:	f8dd b010 	ldr.w	fp, [sp, #16]
 8002cea:	9304      	str	r3, [sp, #16]
								break;
							} else {
								char_n++;
							}
						}
						tft_set_char_pos(x*CHAR_WIDTH, y*CHAR_HEIGHT, (x+char_n)*CHAR_WIDTH-1, (y+1)*CHAR_HEIGHT-1);
 8002cec:	9c01      	ldr	r4, [sp, #4]
 8002cee:	9905      	ldr	r1, [sp, #20]
 8002cf0:	9b03      	ldr	r3, [sp, #12]
 8002cf2:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 8002cf6:	00e0      	lsls	r0, r4, #3
 8002cf8:	3a01      	subs	r2, #1
 8002cfa:	b2a4      	uxth	r4, r4
 8002cfc:	b2d2      	uxtb	r2, r2
 8002cfe:	f000 00f8 	and.w	r0, r0, #248	; 0xf8
 8002d02:	9401      	str	r4, [sp, #4]
 8002d04:	f001 fd2c 	bl	8004760 <tft_set_char_pos>
 8002d08:	2400      	movs	r4, #0
						y2 = y;

            for (py = 0; py < CHAR_HEIGHT; py++) {
							for (px = 0; px < char_n*CHAR_WIDTH; px++) {
 8002d0a:	2e00      	cmp	r6, #0
 8002d0c:	dd40      	ble.n	8002d90 <TFT_thread.lto_priv.53+0xa30>
 8002d0e:	f04f 0900 	mov.w	r9, #0
								x2 = x+px/CHAR_WIDTH;
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + py] & (0x80 >> (px % CHAR_WIDTH)) ? text_color[x2][y2] : bg_color[x2][y2];
 8002d12:	2780      	movs	r7, #128	; 0x80
 8002d14:	4649      	mov	r1, r9
 8002d16:	e01c      	b.n	8002d52 <TFT_thread.lto_priv.53+0x9f2>
 8002d18:	f81a 0000 	ldrb.w	r0, [sl, r0]
 8002d1c:	b212      	sxth	r2, r2
 8002d1e:	fa47 f202 	asr.w	r2, r7, r2
 8002d22:	4202      	tst	r2, r0
 8002d24:	bf15      	itete	ne
 8002d26:	4b2a      	ldrne	r3, [pc, #168]	; (8002dd0 <TFT_thread.lto_priv.53+0xa70>)
 8002d28:	4a2a      	ldreq	r2, [pc, #168]	; (8002dd4 <TFT_thread.lto_priv.53+0xa74>)
 8002d2a:	f833 8011 	ldrhne.w	r8, [r3, r1, lsl #1]
 8002d2e:	f832 8013 	ldrheq.w	r8, [r2, r3, lsl #1]
 8002d32:	f109 0901 	add.w	r9, r9, #1
								tft_write_data(clr >> 8);
 8002d36:	ea4f 2018 	mov.w	r0, r8, lsr #8
 8002d3a:	f001 fce1 	bl	8004700 <tft_write_data>
 8002d3e:	fa1f f989 	uxth.w	r9, r9
								tft_write_data(clr);
 8002d42:	fa5f f088 	uxtb.w	r0, r8
 8002d46:	f001 fcdb 	bl	8004700 <tft_write_data>
						}
						tft_set_char_pos(x*CHAR_WIDTH, y*CHAR_HEIGHT, (x+char_n)*CHAR_WIDTH-1, (y+1)*CHAR_HEIGHT-1);
						y2 = y;

            for (py = 0; py < CHAR_HEIGHT; py++) {
							for (px = 0; px < char_n*CHAR_WIDTH; px++) {
 8002d4a:	fa0f f189 	sxth.w	r1, r9
 8002d4e:	42b1      	cmp	r1, r6
 8002d50:	da1e      	bge.n	8002d90 <TFT_thread.lto_priv.53+0xa30>
								x2 = x+px/CHAR_WIDTH;
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + py] & (0x80 >> (px % CHAR_WIDTH)) ? text_color[x2][y2] : bg_color[x2][y2];
 8002d52:	4a21      	ldr	r2, [pc, #132]	; (8002dd8 <TFT_thread.lto_priv.53+0xa78>)
						tft_set_char_pos(x*CHAR_WIDTH, y*CHAR_HEIGHT, (x+char_n)*CHAR_WIDTH-1, (y+1)*CHAR_HEIGHT-1);
						y2 = y;

            for (py = 0; py < CHAR_HEIGHT; py++) {
							for (px = 0; px < char_n*CHAR_WIDTH; px++) {
								x2 = x+px/CHAR_WIDTH;
 8002d54:	2900      	cmp	r1, #0
 8002d56:	460b      	mov	r3, r1
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + py] & (0x80 >> (px % CHAR_WIDTH)) ? text_color[x2][y2] : bg_color[x2][y2];
 8002d58:	ea02 0201 	and.w	r2, r2, r1
						tft_set_char_pos(x*CHAR_WIDTH, y*CHAR_HEIGHT, (x+char_n)*CHAR_WIDTH-1, (y+1)*CHAR_HEIGHT-1);
						y2 = y;

            for (py = 0; py < CHAR_HEIGHT; py++) {
							for (px = 0; px < char_n*CHAR_WIDTH; px++) {
								x2 = x+px/CHAR_WIDTH;
 8002d5c:	bfb8      	it	lt
 8002d5e:	1dcb      	addlt	r3, r1, #7
 8002d60:	9901      	ldr	r1, [sp, #4]
 8002d62:	eb01 03e3 	add.w	r3, r1, r3, asr #3
								clr = ascii_8x16[((text[x2][y2] - STARTING_ASCII) * CHAR_HEIGHT) + py] & (0x80 >> (px % CHAR_WIDTH)) ? text_color[x2][y2] : bg_color[x2][y2];
 8002d66:	b21b      	sxth	r3, r3
 8002d68:	ea4f 0e83 	mov.w	lr, r3, lsl #2
 8002d6c:	eb0e 0003 	add.w	r0, lr, r3
 8002d70:	eb0b 0040 	add.w	r0, fp, r0, lsl #1
 8002d74:	4601      	mov	r1, r0
 8002d76:	5c28      	ldrb	r0, [r5, r0]
 8002d78:	f04f 0e10 	mov.w	lr, #16
 8002d7c:	2a00      	cmp	r2, #0
 8002d7e:	fb1e 4000 	smlabb	r0, lr, r0, r4
 8002d82:	460b      	mov	r3, r1
 8002d84:	dac8      	bge.n	8002d18 <TFT_thread.lto_priv.53+0x9b8>
 8002d86:	3a01      	subs	r2, #1
 8002d88:	f062 0207 	orn	r2, r2, #7
 8002d8c:	3201      	adds	r2, #1
 8002d8e:	e7c3      	b.n	8002d18 <TFT_thread.lto_priv.53+0x9b8>
 8002d90:	3401      	adds	r4, #1
							}
						}
						tft_set_char_pos(x*CHAR_WIDTH, y*CHAR_HEIGHT, (x+char_n)*CHAR_WIDTH-1, (y+1)*CHAR_HEIGHT-1);
						y2 = y;

            for (py = 0; py < CHAR_HEIGHT; py++) {
 8002d92:	2c10      	cmp	r4, #16
 8002d94:	d1b9      	bne.n	8002d0a <TFT_thread.lto_priv.53+0x9aa>
 8002d96:	9b01      	ldr	r3, [sp, #4]
 8002d98:	1e5f      	subs	r7, r3, #1
								tft_write_data(clr >> 8);
								tft_write_data(clr);
							}
						}

						x += char_n-1;
 8002d9a:	9b04      	ldr	r3, [sp, #16]
 8002d9c:	443b      	add	r3, r7
 8002d9e:	b29b      	uxth	r3, r3
 8002da0:	9301      	str	r3, [sp, #4]
		return;

	switch (tft_orientation) {
		case 0:
			for (y = 0; y < CHAR_MAX_Y_VERTICAL; y++) {
				for (x = 0; x < CHAR_MAX_X_VERTICAL; x++) {
 8002da2:	9f01      	ldr	r7, [sp, #4]
 8002da4:	3701      	adds	r7, #1
 8002da6:	b2bb      	uxth	r3, r7
 8002da8:	9301      	str	r3, [sp, #4]
 8002daa:	b21b      	sxth	r3, r3
 8002dac:	2b0f      	cmp	r3, #15
 8002dae:	f77f af6b 	ble.w	8002c88 <TFT_thread.lto_priv.53+0x928>
 8002db2:	9b03      	ldr	r3, [sp, #12]
 8002db4:	f10b 0b01 	add.w	fp, fp, #1
 8002db8:	3310      	adds	r3, #16
 8002dba:	b2db      	uxtb	r3, r3
	if (!tft_enabled)
		return;

	switch (tft_orientation) {
		case 0:
			for (y = 0; y < CHAR_MAX_Y_VERTICAL; y++) {
 8002dbc:	f1bb 0f0a 	cmp.w	fp, #10
 8002dc0:	9303      	str	r3, [sp, #12]
 8002dc2:	f47f af59 	bne.w	8002c78 <TFT_thread.lto_priv.53+0x918>

  while(true)
  {
    tft_update();
    chThdSleepMilliseconds(100);
 8002dc6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002dca:	f000 fbc9 	bl	8003560 <chThdSleep>
 8002dce:	e505      	b.n	80027dc <TFT_thread.lto_priv.53+0x47c>
 8002dd0:	20002f38 	.word	0x20002f38
 8002dd4:	20002004 	.word	0x20002004
 8002dd8:	80000007 	.word	0x80000007
 8002ddc:	080057b0 	.word	0x080057b0
 8002de0:	8000000f 	.word	0x8000000f
							}
						}
						tft_set_char_pos((CHAR_MAX_X_VERTICAL-x-1)*CHAR_WIDTH, (CHAR_MAX_Y_VERTICAL-y-1)*CHAR_HEIGHT, (CHAR_MAX_X_VERTICAL-x-1+char_n)*CHAR_WIDTH-1, (CHAR_MAX_Y_VERTICAL-y)*CHAR_HEIGHT-1);
						y2 = y;

            for (py = 0; py < CHAR_HEIGHT; py++) {
 8002de4:	f114 34ff 	adds.w	r4, r4, #4294967295
 8002de8:	f4bf ae5b 	bcs.w	8002aa2 <TFT_thread.lto_priv.53+0x742>
 8002dec:	9e01      	ldr	r6, [sp, #4]
								tft_write_data(clr >> 8);
								tft_write_data(clr);
							}
						}

						x -= char_n-1;
 8002dee:	9b04      	ldr	r3, [sp, #16]
 8002df0:	3601      	adds	r6, #1
 8002df2:	1af6      	subs	r6, r6, r3
 8002df4:	b2b6      	uxth	r6, r6
				}
			}
			break;
		case 2:
			for (y = CHAR_MAX_Y_VERTICAL-1; y >= 0; y--) {
				for (x = CHAR_MAX_X_VERTICAL-1; x >= 0; x--) {
 8002df6:	3e01      	subs	r6, #1
 8002df8:	b2b6      	uxth	r6, r6
 8002dfa:	0433      	lsls	r3, r6, #16
 8002dfc:	f57f ae14 	bpl.w	8002a28 <TFT_thread.lto_priv.53+0x6c8>
 8002e00:	9b03      	ldr	r3, [sp, #12]
 8002e02:	f10b 3bff 	add.w	fp, fp, #4294967295
 8002e06:	3310      	adds	r3, #16
 8002e08:	b2db      	uxtb	r3, r3
					}
				}
			}
			break;
		case 2:
			for (y = CHAR_MAX_Y_VERTICAL-1; y >= 0; y--) {
 8002e0a:	f1bb 3fff 	cmp.w	fp, #4294967295
 8002e0e:	9303      	str	r3, [sp, #12]
 8002e10:	f47f ae02 	bne.w	8002a18 <TFT_thread.lto_priv.53+0x6b8>
 8002e14:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002e18:	f000 fba2 	bl	8003560 <chThdSleep>
 8002e1c:	e4de      	b.n	80027dc <TFT_thread.lto_priv.53+0x47c>
 8002e1e:	9b01      	ldr	r3, [sp, #4]
 8002e20:	3301      	adds	r3, #1
							}
						}
						tft_set_char_pos((CHAR_MAX_Y_HORIZONTAL-y-1)*CHAR_HEIGHT, x*CHAR_WIDTH, (CHAR_MAX_Y_HORIZONTAL-y-1+char_n)*CHAR_HEIGHT-1, (x+1)*CHAR_WIDTH-1);
						x2 = x;

            for (px = 0; px < CHAR_WIDTH; px++) {
 8002e22:	2b08      	cmp	r3, #8
 8002e24:	9301      	str	r3, [sp, #4]
 8002e26:	f47f aee0 	bne.w	8002bea <TFT_thread.lto_priv.53+0x88a>
								tft_write_data(clr >> 8);
								tft_write_data(clr);
							}
						}

						y -= char_n-1;
 8002e2a:	9b04      	ldr	r3, [sp, #16]
 8002e2c:	3401      	adds	r4, #1
 8002e2e:	1ae4      	subs	r4, r4, r3
 8002e30:	b2a4      	uxth	r4, r4
				}
			}
			break;
		case 1:
			for (x = 0; x < CHAR_MAX_X_HORIZONTAL; x++) {
				for (y = CHAR_MAX_Y_HORIZONTAL-1; y >= 0; y--) {
 8002e32:	3c01      	subs	r4, #1
 8002e34:	b2a4      	uxth	r4, r4
 8002e36:	0422      	lsls	r2, r4, #16
 8002e38:	f57f ae98 	bpl.w	8002b6c <TFT_thread.lto_priv.53+0x80c>
 8002e3c:	9b05      	ldr	r3, [sp, #20]
 8002e3e:	9a03      	ldr	r2, [sp, #12]
 8002e40:	3308      	adds	r3, #8
 8002e42:	3201      	adds	r2, #1
 8002e44:	b2db      	uxtb	r3, r3
					}
				}
			}
			break;
		case 1:
			for (x = 0; x < CHAR_MAX_X_HORIZONTAL; x++) {
 8002e46:	2a14      	cmp	r2, #20
 8002e48:	9203      	str	r2, [sp, #12]
 8002e4a:	9305      	str	r3, [sp, #20]
 8002e4c:	f47f ae87 	bne.w	8002b5e <TFT_thread.lto_priv.53+0x7fe>
 8002e50:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002e54:	f000 fb84 	bl	8003560 <chThdSleep>
 8002e58:	e4c0      	b.n	80027dc <TFT_thread.lto_priv.53+0x47c>
 8002e5a:	9b02      	ldr	r3, [sp, #8]
 8002e5c:	3b01      	subs	r3, #1
 8002e5e:	9302      	str	r3, [sp, #8]
							}
						}
						tft_set_char_pos(y*CHAR_HEIGHT, (CHAR_MAX_X_HORIZONTAL-x-1)*CHAR_WIDTH, (y+char_n)*CHAR_HEIGHT-1, (CHAR_MAX_X_HORIZONTAL-x)*CHAR_WIDTH-1);
						x2 = x;

            for (px = 0; px < CHAR_WIDTH; px++) {
 8002e60:	3301      	adds	r3, #1
 8002e62:	f47f ad98 	bne.w	8002996 <TFT_thread.lto_priv.53+0x636>
 8002e66:	9b01      	ldr	r3, [sp, #4]
 8002e68:	f103 38ff 	add.w	r8, r3, #4294967295
								tft_write_data(clr >> 8);
								tft_write_data(clr);
							}
						}

						y += char_n-1;
 8002e6c:	9b05      	ldr	r3, [sp, #20]
 8002e6e:	4443      	add	r3, r8
 8002e70:	b29b      	uxth	r3, r3
 8002e72:	465e      	mov	r6, fp
 8002e74:	9301      	str	r3, [sp, #4]
				}
			}
			break;
		case 3:
			for (x = CHAR_MAX_X_HORIZONTAL-1; x >= 0; x--) {
				for (y = 0; y < CHAR_MAX_Y_HORIZONTAL; y++) {
 8002e76:	9b01      	ldr	r3, [sp, #4]
 8002e78:	f103 0801 	add.w	r8, r3, #1
 8002e7c:	fa1f f388 	uxth.w	r3, r8
 8002e80:	9301      	str	r3, [sp, #4]
 8002e82:	b21b      	sxth	r3, r3
 8002e84:	2b07      	cmp	r3, #7
 8002e86:	f77f ad42 	ble.w	800290e <TFT_thread.lto_priv.53+0x5ae>
 8002e8a:	9b04      	ldr	r3, [sp, #16]
 8002e8c:	9a07      	ldr	r2, [sp, #28]
 8002e8e:	3308      	adds	r3, #8
 8002e90:	3a01      	subs	r2, #1
 8002e92:	9207      	str	r2, [sp, #28]
 8002e94:	b2db      	uxtb	r3, r3
					}
				}
			}
			break;
		case 3:
			for (x = CHAR_MAX_X_HORIZONTAL-1; x >= 0; x--) {
 8002e96:	3201      	adds	r2, #1
 8002e98:	9304      	str	r3, [sp, #16]
 8002e9a:	f47f ad2b 	bne.w	80028f4 <TFT_thread.lto_priv.53+0x594>
 8002e9e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002ea2:	f000 fb5d 	bl	8003560 <chThdSleep>
 8002ea6:	e499      	b.n	80027dc <TFT_thread.lto_priv.53+0x47c>
				for (y = 0; y < CHAR_MAX_Y_HORIZONTAL; y++) {
					if (tft_char_is_changed(x, y)) {
						char_n = 1;
						while (y+char_n < CHAR_MAX_Y_HORIZONTAL && tft_char_is_changed(x, y+char_n)) {
 8002ea8:	2301      	movs	r3, #1
 8002eaa:	2410      	movs	r4, #16
 8002eac:	9305      	str	r3, [sp, #20]
 8002eae:	e561      	b.n	8002974 <TFT_thread.lto_priv.53+0x614>
		case 1:
			for (x = 0; x < CHAR_MAX_X_HORIZONTAL; x++) {
				for (y = CHAR_MAX_Y_HORIZONTAL-1; y >= 0; y--) {
					if (tft_char_is_changed(x, y)) {
						char_n = 1;
						while (y-char_n > -1 && tft_char_is_changed(x, y-char_n)) {
 8002eb0:	2301      	movs	r3, #1
 8002eb2:	9304      	str	r3, [sp, #16]
 8002eb4:	469b      	mov	fp, r3
 8002eb6:	2610      	movs	r6, #16
 8002eb8:	e681      	b.n	8002bbe <TFT_thread.lto_priv.53+0x85e>
		case 0:
			for (y = 0; y < CHAR_MAX_Y_VERTICAL; y++) {
				for (x = 0; x < CHAR_MAX_X_VERTICAL; x++) {
					if (tft_char_is_changed(x, y)) {
						char_n = 1;
						while (x+char_n < CHAR_MAX_X_VERTICAL && tft_char_is_changed(x+char_n, y)) {
 8002eba:	2301      	movs	r3, #1
 8002ebc:	2608      	movs	r6, #8
 8002ebe:	9304      	str	r3, [sp, #16]
 8002ec0:	e714      	b.n	8002cec <TFT_thread.lto_priv.53+0x98c>
		case 2:
			for (y = CHAR_MAX_Y_VERTICAL-1; y >= 0; y--) {
				for (x = CHAR_MAX_X_VERTICAL-1; x >= 0; x--) {
					if (tft_char_is_changed(x, y)) {
						char_n = 1;
						while (x-char_n > -1 && tft_char_is_changed(x-char_n, y)) {
 8002ec2:	2301      	movs	r3, #1
 8002ec4:	9304      	str	r3, [sp, #16]
 8002ec6:	4699      	mov	r9, r3
 8002ec8:	2708      	movs	r7, #8
 8002eca:	e5d9      	b.n	8002a80 <TFT_thread.lto_priv.53+0x720>
 8002ecc:	b672      	cpsid	i
 8002ece:	4a01      	ldr	r2, [pc, #4]	; (8002ed4 <TFT_thread.lto_priv.53+0xb74>)
 8002ed0:	62da      	str	r2, [r3, #44]	; 0x2c
 8002ed2:	e7fe      	b.n	8002ed2 <TFT_thread.lto_priv.53+0xb72>
 8002ed4:	08005790 	.word	0x08005790
	...

08002ee0 <chTMChainMeasurementToX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8002ee0:	4b0d      	ldr	r3, [pc, #52]	; (8002f18 <chTMChainMeasurementToX+0x38>)
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8002ee2:	6842      	ldr	r2, [r0, #4]
 8002ee4:	685b      	ldr	r3, [r3, #4]
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
 8002ee6:	b470      	push	{r4, r5, r6}

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
 8002ee8:	608b      	str	r3, [r1, #8]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8002eea:	6886      	ldr	r6, [r0, #8]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8002eec:	68c1      	ldr	r1, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8002eee:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8002ef2:	1b9b      	subs	r3, r3, r6
  tmp->cumulative += (rttime_t)tmp->last;
 8002ef4:	18e4      	adds	r4, r4, r3
 8002ef6:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8002efa:	4293      	cmp	r3, r2
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 8002efc:	6802      	ldr	r2, [r0, #0]

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8002efe:	bf88      	it	hi
 8002f00:	6043      	strhi	r3, [r0, #4]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8002f02:	3101      	adds	r1, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 8002f04:	4293      	cmp	r3, r2
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8002f06:	e9c0 4504 	strd	r4, r5, [r0, #16]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8002f0a:	60c1      	str	r1, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8002f0c:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 8002f0e:	bf38      	it	cc
 8002f10:	6003      	strcc	r3, [r0, #0]
  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
}
 8002f12:	bc70      	pop	{r4, r5, r6}
 8002f14:	4770      	bx	lr
 8002f16:	bf00      	nop
 8002f18:	e0001000 	.word	0xe0001000
 8002f1c:	00000000 	.word	0x00000000

08002f20 <_dbg_trace>:
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
 8002f20:	4a0c      	ldr	r2, [pc, #48]	; (8002f54 <_dbg_trace+0x34>)
 8002f22:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8002f26:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 *
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {
 8002f28:	b410      	push	{r4}
 8002f2a:	6a4c      	ldr	r4, [r1, #36]	; 0x24

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
 8002f2c:	6991      	ldr	r1, [r2, #24]
 8002f2e:	6059      	str	r1, [r3, #4]
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
 8002f30:	601c      	str	r4, [r3, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
 8002f32:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8002f34:	6099      	str	r1, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 8002f36:	f890 1020 	ldrb.w	r1, [r0, #32]
 8002f3a:	7319      	strb	r1, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 8002f3c:	3310      	adds	r3, #16
 8002f3e:	f502 6188 	add.w	r1, r2, #1088	; 0x440
 8002f42:	428b      	cmp	r3, r1
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8002f44:	bf28      	it	cs
 8002f46:	f102 0340 	addcs.w	r3, r2, #64	; 0x40
 8002f4a:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 8002f4c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002f50:	4770      	bx	lr
 8002f52:	bf00      	nop
 8002f54:	20002740 	.word	0x20002740
	...

08002f60 <_idle_thread.lto_priv.55>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8002f60:	e7fe      	b.n	8002f60 <_idle_thread.lto_priv.55>
 8002f62:	bf00      	nop
	...

08002f70 <_stats_increase_irq>:

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002f70:	2320      	movs	r3, #32
 8002f72:	f383 8811 	msr	BASEPRI, r3
 * @brief   Increases the IRQ counter.
 */
void _stats_increase_irq(void) {

  port_lock_from_isr();
  ch.kernel_stats.n_irq++;
 8002f76:	4a05      	ldr	r2, [pc, #20]	; (8002f8c <_stats_increase_irq+0x1c>)
 8002f78:	f8d2 34a8 	ldr.w	r3, [r2, #1192]	; 0x4a8
 8002f7c:	3301      	adds	r3, #1
 8002f7e:	f8c2 34a8 	str.w	r3, [r2, #1192]	; 0x4a8
 8002f82:	2300      	movs	r3, #0
 8002f84:	f383 8811 	msr	BASEPRI, r3
 8002f88:	4770      	bx	lr
 8002f8a:	bf00      	nop
 8002f8c:	20002740 	.word	0x20002740

08002f90 <chTMStopMeasurementX>:
 8002f90:	4b0f      	ldr	r3, [pc, #60]	; (8002fd0 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8002f92:	4910      	ldr	r1, [pc, #64]	; (8002fd4 <chTMStopMeasurementX+0x44>)
 8002f94:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8002f96:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8002f98:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8002f9a:	f8d1 74a0 	ldr.w	r7, [r1, #1184]	; 0x4a0
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8002f9e:	6841      	ldr	r1, [r0, #4]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8002fa0:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8002fa2:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8002fa6:	1ad3      	subs	r3, r2, r3
 8002fa8:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 8002faa:	18e4      	adds	r4, r4, r3
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 8002fac:	6802      	ldr	r2, [r0, #0]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8002fae:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8002fb0:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8002fb4:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8002fb6:	f106 0601 	add.w	r6, r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8002fba:	bf88      	it	hi
 8002fbc:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 8002fbe:	4293      	cmp	r3, r2

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8002fc0:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8002fc2:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 8002fc6:	bf38      	it	cc
 8002fc8:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8002fca:	bcf0      	pop	{r4, r5, r6, r7}
 8002fcc:	4770      	bx	lr
 8002fce:	bf00      	nop
 8002fd0:	e0001000 	.word	0xe0001000
 8002fd4:	20002740 	.word	0x20002740
	...

08002fe0 <_stats_stop_measure_crit_isr>:
/**
 * @brief   Stops the measurement of an ISR critical zone.
 */
void _stats_stop_measure_crit_isr(void) {

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_isr);
 8002fe0:	4801      	ldr	r0, [pc, #4]	; (8002fe8 <_stats_stop_measure_crit_isr+0x8>)
 8002fe2:	f7ff bfd5 	b.w	8002f90 <chTMStopMeasurementX>
 8002fe6:	bf00      	nop
 8002fe8:	20002c08 	.word	0x20002c08
 8002fec:	00000000 	.word	0x00000000

08002ff0 <_stats_stop_measure_crit_thd>:
/**
 * @brief   Stops the measurement of a thread critical zone.
 */
void _stats_stop_measure_crit_thd(void) {

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_thd);
 8002ff0:	4801      	ldr	r0, [pc, #4]	; (8002ff8 <_stats_stop_measure_crit_thd+0x8>)
 8002ff2:	f7ff bfcd 	b.w	8002f90 <chTMStopMeasurementX>
 8002ff6:	bf00      	nop
 8002ff8:	20002bf0 	.word	0x20002bf0
 8002ffc:	00000000 	.word	0x00000000

08003000 <chTMStartMeasurementX>:
 8003000:	4b01      	ldr	r3, [pc, #4]	; (8003008 <chTMStartMeasurementX+0x8>)
 8003002:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8003004:	6083      	str	r3, [r0, #8]
 8003006:	4770      	bx	lr
 8003008:	e0001000 	.word	0xe0001000
 800300c:	00000000 	.word	0x00000000

08003010 <_stats_start_measure_crit_isr>:
/**
 * @brief   Starts the measurement of an ISR critical zone.
 */
void _stats_start_measure_crit_isr(void) {

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_isr);
 8003010:	4801      	ldr	r0, [pc, #4]	; (8003018 <_stats_start_measure_crit_isr+0x8>)
 8003012:	f7ff bff5 	b.w	8003000 <chTMStartMeasurementX>
 8003016:	bf00      	nop
 8003018:	20002c08 	.word	0x20002c08
 800301c:	00000000 	.word	0x00000000

08003020 <_stats_start_measure_crit_thd>:
/**
 * @brief   Starts the measurement of a thread critical zone.
 */
void _stats_start_measure_crit_thd(void) {

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_thd);
 8003020:	4801      	ldr	r0, [pc, #4]	; (8003028 <_stats_start_measure_crit_thd+0x8>)
 8003022:	f7ff bfed 	b.w	8003000 <chTMStartMeasurementX>
 8003026:	bf00      	nop
 8003028:	20002bf0 	.word	0x20002bf0
 800302c:	00000000 	.word	0x00000000

08003030 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8003030:	b570      	push	{r4, r5, r6, lr}
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8003032:	4d1b      	ldr	r5, [pc, #108]	; (80030a0 <chSchDoReschedule+0x70>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8003034:	682a      	ldr	r2, [r5, #0]
 8003036:	69ac      	ldr	r4, [r5, #24]

  tqp->p_next = tp->p_next;
 8003038:	6813      	ldr	r3, [r2, #0]
 800303a:	68a1      	ldr	r1, [r4, #8]
 800303c:	602b      	str	r3, [r5, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800303e:	2601      	movs	r6, #1

  otp->p_state = CH_STATE_READY;
 8003040:	2000      	movs	r0, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003042:	605d      	str	r5, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8003044:	f882 6020 	strb.w	r6, [r2, #32]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8003048:	61aa      	str	r2, [r5, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 800304a:	f884 0020 	strb.w	r0, [r4, #32]
 800304e:	e000      	b.n	8003052 <chSchDoReschedule+0x22>
 8003050:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 8003052:	689a      	ldr	r2, [r3, #8]
 8003054:	428a      	cmp	r2, r1
 8003056:	d8fb      	bhi.n	8003050 <chSchDoReschedule+0x20>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8003058:	685a      	ldr	r2, [r3, #4]
 800305a:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 800305c:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 800305e:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
 8003060:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 8003062:	605c      	str	r4, [r3, #4]

  chSysSwitch(currp, otp);
 8003064:	f7ff ff5c 	bl	8002f20 <_dbg_trace>
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {

  ch.kernel_stats.n_ctxswc++;
 8003068:	f8d5 34ac 	ldr.w	r3, [r5, #1196]	; 0x4ac
 800306c:	69a9      	ldr	r1, [r5, #24]
 800306e:	4e0c      	ldr	r6, [pc, #48]	; (80030a0 <chSchDoReschedule+0x70>)
 8003070:	3301      	adds	r3, #1
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 8003072:	3148      	adds	r1, #72	; 0x48
 8003074:	f104 0048 	add.w	r0, r4, #72	; 0x48
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {

  ch.kernel_stats.n_ctxswc++;
 8003078:	f8c5 34ac 	str.w	r3, [r5, #1196]	; 0x4ac
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 800307c:	f7ff ff30 	bl	8002ee0 <chTMChainMeasurementToX>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003080:	f3ef 8309 	mrs	r3, PSP
 8003084:	69e2      	ldr	r2, [r4, #28]
 8003086:	3b64      	subs	r3, #100	; 0x64
 8003088:	429a      	cmp	r2, r3
 800308a:	d805      	bhi.n	8003098 <chSchDoReschedule+0x68>
 800308c:	69b0      	ldr	r0, [r6, #24]
 800308e:	4621      	mov	r1, r4
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8003090:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8003094:	f7fd b91c 	b.w	80002d0 <_port_switch>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003098:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800309a:	4b02      	ldr	r3, [pc, #8]	; (80030a4 <chSchDoReschedule+0x74>)
 800309c:	62f3      	str	r3, [r6, #44]	; 0x2c
 800309e:	e7fe      	b.n	800309e <chSchDoReschedule+0x6e>
 80030a0:	20002740 	.word	0x20002740
 80030a4:	08006830 	.word	0x08006830
	...

080030b0 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80030b0:	4b05      	ldr	r3, [pc, #20]	; (80030c8 <chDbgCheckClassS+0x18>)
 80030b2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80030b4:	b91a      	cbnz	r2, 80030be <chDbgCheckClassS+0xe>
 80030b6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80030b8:	2a00      	cmp	r2, #0
 80030ba:	dd00      	ble.n	80030be <chDbgCheckClassS+0xe>
 80030bc:	4770      	bx	lr
 80030be:	b672      	cpsid	i
 80030c0:	4a02      	ldr	r2, [pc, #8]	; (80030cc <chDbgCheckClassS+0x1c>)
 80030c2:	62da      	str	r2, [r3, #44]	; 0x2c
 80030c4:	e7fe      	b.n	80030c4 <chDbgCheckClassS+0x14>
 80030c6:	bf00      	nop
 80030c8:	20002740 	.word	0x20002740
 80030cc:	08006840 	.word	0x08006840

080030d0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80030d0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 80030d2:	4c16      	ldr	r4, [pc, #88]	; (800312c <chSchGoSleepS+0x5c>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80030d4:	4606      	mov	r6, r0
  thread_t *otp;

  chDbgCheckClassS();
 80030d6:	f7ff ffeb 	bl	80030b0 <chDbgCheckClassS>
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80030da:	6823      	ldr	r3, [r4, #0]

  otp = currp;
 80030dc:	69a5      	ldr	r5, [r4, #24]

  tqp->p_next = tp->p_next;
 80030de:	681a      	ldr	r2, [r3, #0]
  otp->p_state = newstate;
 80030e0:	f885 6020 	strb.w	r6, [r5, #32]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80030e4:	2101      	movs	r1, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 80030e6:	6054      	str	r4, [r2, #4]
  chSysSwitch(currp, otp);
 80030e8:	4628      	mov	r0, r5
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80030ea:	f883 1020 	strb.w	r1, [r3, #32]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80030ee:	6022      	str	r2, [r4, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80030f0:	61a3      	str	r3, [r4, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 80030f2:	f7ff ff15 	bl	8002f20 <_dbg_trace>
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {

  ch.kernel_stats.n_ctxswc++;
 80030f6:	f8d4 34ac 	ldr.w	r3, [r4, #1196]	; 0x4ac
 80030fa:	69a1      	ldr	r1, [r4, #24]
 80030fc:	3301      	adds	r3, #1
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 80030fe:	f105 0048 	add.w	r0, r5, #72	; 0x48
 8003102:	3148      	adds	r1, #72	; 0x48
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {

  ch.kernel_stats.n_ctxswc++;
 8003104:	f8c4 34ac 	str.w	r3, [r4, #1196]	; 0x4ac
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 8003108:	f7ff feea 	bl	8002ee0 <chTMChainMeasurementToX>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800310c:	f3ef 8309 	mrs	r3, PSP
 8003110:	69ea      	ldr	r2, [r5, #28]
 8003112:	3b64      	subs	r3, #100	; 0x64
 8003114:	429a      	cmp	r2, r3
 8003116:	d805      	bhi.n	8003124 <chSchGoSleepS+0x54>
 8003118:	69a0      	ldr	r0, [r4, #24]
 800311a:	4629      	mov	r1, r5
}
 800311c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8003120:	f7fd b8d6 	b.w	80002d0 <_port_switch>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003124:	b672      	cpsid	i
 8003126:	4b02      	ldr	r3, [pc, #8]	; (8003130 <chSchGoSleepS+0x60>)
 8003128:	62e3      	str	r3, [r4, #44]	; 0x2c
 800312a:	e7fe      	b.n	800312a <chSchGoSleepS+0x5a>
 800312c:	20002740 	.word	0x20002740
 8003130:	08006830 	.word	0x08006830
	...

08003140 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003140:	4b05      	ldr	r3, [pc, #20]	; (8003158 <chDbgCheckClassI+0x18>)
 8003142:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003144:	2a00      	cmp	r2, #0
 8003146:	db03      	blt.n	8003150 <chDbgCheckClassI+0x10>
 8003148:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800314a:	2a00      	cmp	r2, #0
 800314c:	dd00      	ble.n	8003150 <chDbgCheckClassI+0x10>
 800314e:	4770      	bx	lr
 8003150:	b672      	cpsid	i
 8003152:	4a02      	ldr	r2, [pc, #8]	; (800315c <chDbgCheckClassI+0x1c>)
 8003154:	62da      	str	r2, [r3, #44]	; 0x2c
 8003156:	e7fe      	b.n	8003156 <chDbgCheckClassI+0x16>
 8003158:	20002740 	.word	0x20002740
 800315c:	08006848 	.word	0x08006848

08003160 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8003160:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003164:	460c      	mov	r4, r1
 8003166:	b087      	sub	sp, #28
 8003168:	4607      	mov	r7, r0

  chDbgCheckClassS();
 800316a:	f7ff ffa1 	bl	80030b0 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 800316e:	1c63      	adds	r3, r4, #1
 8003170:	d056      	beq.n	8003220 <chSchGoSleepTimeoutS+0xc0>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8003172:	4e53      	ldr	r6, [pc, #332]	; (80032c0 <chSchGoSleepTimeoutS+0x160>)
 8003174:	f8d6 9018 	ldr.w	r9, [r6, #24]
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 8003178:	f7ff ffe2 	bl	8003140 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800317c:	b91c      	cbnz	r4, 8003186 <chSchGoSleepTimeoutS+0x26>
 800317e:	b672      	cpsid	i
 8003180:	4b50      	ldr	r3, [pc, #320]	; (80032c4 <chSchGoSleepTimeoutS+0x164>)
 8003182:	62f3      	str	r3, [r6, #44]	; 0x2c
 8003184:	e7fe      	b.n	8003184 <chSchGoSleepTimeoutS+0x24>
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8003186:	46b0      	mov	r8, r6
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8003188:	2c01      	cmp	r4, #1
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800318a:	f858 5f1c 	ldr.w	r5, [r8, #28]!

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 800318e:	494e      	ldr	r1, [pc, #312]	; (80032c8 <chSchGoSleepTimeoutS+0x168>)
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8003190:	f8cd 9014 	str.w	r9, [sp, #20]
 8003194:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8003198:	bf08      	it	eq
 800319a:	2402      	moveq	r4, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800319c:	4545      	cmp	r5, r8
 800319e:	6a53      	ldr	r3, [r2, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 80031a0:	9104      	str	r1, [sp, #16]
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80031a2:	d046      	beq.n	8003232 <chSchGoSleepTimeoutS+0xd2>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.vt_next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.vt_lasttime + delay;
 80031a4:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 80031a6:	1a1b      	subs	r3, r3, r0

    if (delta < now - ch.vtlist.vt_lasttime) {
 80031a8:	18e4      	adds	r4, r4, r3
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->vt_delta;
 80031aa:	68ab      	ldr	r3, [r5, #8]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.vt_lasttime + delay;

    if (delta < now - ch.vtlist.vt_lasttime) {
 80031ac:	d355      	bcc.n	800325a <chSchGoSleepTimeoutS+0xfa>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->vt_delta;
      p = p->vt_next;
 80031ae:	682d      	ldr	r5, [r5, #0]

    if (delta < now - ch.vtlist.vt_lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->vt_delta;
 80031b0:	1ae4      	subs	r4, r4, r3
 80031b2:	68ab      	ldr	r3, [r5, #8]
  p = ch.vtlist.vt_next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 80031b4:	429c      	cmp	r4, r3
 80031b6:	d904      	bls.n	80031c2 <chSchGoSleepTimeoutS+0x62>
    delta -= p->vt_delta;
    p = p->vt_next;
 80031b8:	682d      	ldr	r5, [r5, #0]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 80031ba:	1ae4      	subs	r4, r4, r3
  p = ch.vtlist.vt_next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 80031bc:	68ab      	ldr	r3, [r5, #8]
 80031be:	42a3      	cmp	r3, r4
 80031c0:	d3fa      	bcc.n	80031b8 <chSchGoSleepTimeoutS+0x58>
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80031c2:	686b      	ldr	r3, [r5, #4]
 80031c4:	9302      	str	r3, [sp, #8]
  vtp->vt_prev->vt_next = vtp;
 80031c6:	f10d 0904 	add.w	r9, sp, #4
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 80031ca:	9501      	str	r5, [sp, #4]
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 80031cc:	f8c3 9000 	str.w	r9, [r3]
  p->vt_prev = vtp;
 80031d0:	f8c5 9004 	str.w	r9, [r5, #4]
  vtp->vt_delta = delta
 80031d4:	9403      	str	r4, [sp, #12]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80031d6:	68ab      	ldr	r3, [r5, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80031d8:	f04f 32ff 	mov.w	r2, #4294967295
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80031dc:	1b1b      	subs	r3, r3, r4
 80031de:	60ab      	str	r3, [r5, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80031e0:	6272      	str	r2, [r6, #36]	; 0x24
    chSchGoSleepS(newstate);
 80031e2:	4638      	mov	r0, r7
 80031e4:	f7ff ff74 	bl	80030d0 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 80031e8:	f7ff ffaa 	bl	8003140 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
 80031ec:	9b04      	ldr	r3, [sp, #16]
 80031ee:	b1db      	cbz	r3, 8003228 <chSchGoSleepTimeoutS+0xc8>
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 80031f0:	f7ff ffa6 	bl	8003140 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 80031f4:	69f3      	ldr	r3, [r6, #28]
 80031f6:	4932      	ldr	r1, [pc, #200]	; (80032c0 <chSchGoSleepTimeoutS+0x160>)
 80031f8:	454b      	cmp	r3, r9
 80031fa:	d035      	beq.n	8003268 <chSchGoSleepTimeoutS+0x108>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 80031fc:	9a02      	ldr	r2, [sp, #8]
 80031fe:	9b01      	ldr	r3, [sp, #4]
 8003200:	6013      	str	r3, [r2, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8003202:	9b01      	ldr	r3, [sp, #4]
    vtp->vt_func = NULL;
 8003204:	2100      	movs	r1, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8003206:	4543      	cmp	r3, r8
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8003208:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 800320a:	9104      	str	r1, [sp, #16]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 800320c:	d00c      	beq.n	8003228 <chSchGoSleepTimeoutS+0xc8>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 800320e:	6899      	ldr	r1, [r3, #8]
 8003210:	9a03      	ldr	r2, [sp, #12]
 8003212:	440a      	add	r2, r1
 8003214:	609a      	str	r2, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8003216:	69b3      	ldr	r3, [r6, #24]
 8003218:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 800321a:	b007      	add	sp, #28
 800321c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8003220:	4638      	mov	r0, r7
 8003222:	f7ff ff55 	bl	80030d0 <chSchGoSleepS>
 8003226:	4e26      	ldr	r6, [pc, #152]	; (80032c0 <chSchGoSleepTimeoutS+0x160>)
  }

  return currp->p_u.rdymsg;
 8003228:	69b3      	ldr	r3, [r6, #24]
 800322a:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 800322c:	b007      	add	sp, #28
 800322e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_delta = delay;
 8003232:	9403      	str	r4, [sp, #12]
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 8003234:	62b3      	str	r3, [r6, #40]	; 0x28
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8003236:	68d1      	ldr	r1, [r2, #12]
      ch.vtlist.vt_next = vtp;
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8003238:	9501      	str	r5, [sp, #4]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
 800323a:	f10d 0904 	add.w	r9, sp, #4
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 800323e:	f011 0102 	ands.w	r1, r1, #2
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8003242:	9502      	str	r5, [sp, #8]
      vtp->vt_delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8003244:	441c      	add	r4, r3
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
 8003246:	f8c6 901c 	str.w	r9, [r6, #28]
      ch.vtlist.vt_prev = vtp;
 800324a:	f8c6 9020 	str.w	r9, [r6, #32]
 800324e:	d12a      	bne.n	80032a6 <chSchGoSleepTimeoutS+0x146>
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  STM32_ST_TIM->SR     = 0;
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003250:	2302      	movs	r3, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003252:	6354      	str	r4, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8003254:	6111      	str	r1, [r2, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003256:	60d3      	str	r3, [r2, #12]
 8003258:	e7c3      	b.n	80031e2 <chSchGoSleepTimeoutS+0x82>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->vt_delta;
      p = p->vt_next;
    }
    else if (delta < p->vt_delta) {
 800325a:	429c      	cmp	r4, r3
 800325c:	d2aa      	bcs.n	80031b4 <chSchGoSleepTimeoutS+0x54>
 800325e:	4420      	add	r0, r4
 8003260:	f7fe f86e 	bl	8001340 <stSetAlarm>
 8003264:	68ab      	ldr	r3, [r5, #8]
 8003266:	e7a5      	b.n	80031b4 <chSchGoSleepTimeoutS+0x54>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 8003268:	9a01      	ldr	r2, [sp, #4]
 800326a:	61ca      	str	r2, [r1, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
  vtp->vt_func = NULL;
 800326c:	2300      	movs	r3, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800326e:	4542      	cmp	r2, r8
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8003270:	f8c2 8004 	str.w	r8, [r2, #4]
  vtp->vt_func = NULL;
 8003274:	9304      	str	r3, [sp, #16]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8003276:	d01a      	beq.n	80032ae <chSchGoSleepTimeoutS+0x14e>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 8003278:	9803      	ldr	r0, [sp, #12]
 800327a:	6893      	ldr	r3, [r2, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 800327c:	6a89      	ldr	r1, [r1, #40]	; 0x28

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 800327e:	4403      	add	r3, r0
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003280:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8003284:	6093      	str	r3, [r2, #8]
 8003286:	6a40      	ldr	r0, [r0, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8003288:	1a42      	subs	r2, r0, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 800328a:	4293      	cmp	r3, r2
 800328c:	d9cc      	bls.n	8003228 <chSchGoSleepTimeoutS+0xc8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 800328e:	1a9b      	subs	r3, r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8003290:	2b01      	cmp	r3, #1
 8003292:	bf98      	it	ls
 8003294:	2302      	movls	r3, #2
 8003296:	4418      	add	r0, r3
 8003298:	f7fe f852 	bl	8001340 <stSetAlarm>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 800329c:	69b3      	ldr	r3, [r6, #24]
 800329e:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 80032a0:	b007      	add	sp, #28
 80032a2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80032a6:	b672      	cpsid	i
 80032a8:	4b08      	ldr	r3, [pc, #32]	; (80032cc <chSchGoSleepTimeoutS+0x16c>)
 80032aa:	62f3      	str	r3, [r6, #44]	; 0x2c
 80032ac:	e7fe      	b.n	80032ac <chSchGoSleepTimeoutS+0x14c>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80032ae:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80032b2:	60d3      	str	r3, [r2, #12]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 80032b4:	69b3      	ldr	r3, [r6, #24]
 80032b6:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 80032b8:	b007      	add	sp, #28
 80032ba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80032be:	bf00      	nop
 80032c0:	20002740 	.word	0x20002740
 80032c4:	08006900 	.word	0x08006900
 80032c8:	08003491 	.word	0x08003491
 80032cc:	08006910 	.word	0x08006910

080032d0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 80032d0:	b169      	cbz	r1, 80032ee <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80032d2:	4b08      	ldr	r3, [pc, #32]	; (80032f4 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 80032d4:	b410      	push	{r4}
 80032d6:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 80032d8:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80032da:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80032dc:	2004      	movs	r0, #4
 80032de:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tp;
 80032e2:	6023      	str	r3, [r4, #0]
  tqp->p_prev = tp;
 80032e4:	6053      	str	r3, [r2, #4]
}
 80032e6:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80032ea:	f7ff bf39 	b.w	8003160 <chSchGoSleepTimeoutS>
}
 80032ee:	f04f 30ff 	mov.w	r0, #4294967295
 80032f2:	4770      	bx	lr
 80032f4:	20002740 	.word	0x20002740
	...

08003300 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8003300:	b510      	push	{r4, lr}
 8003302:	4604      	mov	r4, r0
  thread_t *cp;

  chDbgCheckClassI();
 8003304:	f7ff ff1c 	bl	8003140 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8003308:	b1cc      	cbz	r4, 800333e <chSchReadyI+0x3e>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
 800330a:	f894 3020 	ldrb.w	r3, [r4, #32]
 800330e:	b18b      	cbz	r3, 8003334 <chSchReadyI+0x34>
 8003310:	2b0f      	cmp	r3, #15
 8003312:	d00f      	beq.n	8003334 <chSchReadyI+0x34>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8003314:	2200      	movs	r2, #0
 8003316:	68a1      	ldr	r1, [r4, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8003318:	4b0b      	ldr	r3, [pc, #44]	; (8003348 <chSchReadyI+0x48>)
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800331a:	f884 2020 	strb.w	r2, [r4, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800331e:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8003320:	689a      	ldr	r2, [r3, #8]
 8003322:	428a      	cmp	r2, r1
 8003324:	d2fb      	bcs.n	800331e <chSchReadyI+0x1e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8003326:	685a      	ldr	r2, [r3, #4]
 8003328:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800332a:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;

  return tp;
}
 800332c:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800332e:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8003330:	605c      	str	r4, [r3, #4]

  return tp;
}
 8003332:	bd10      	pop	{r4, pc}
 8003334:	b672      	cpsid	i
 8003336:	4b04      	ldr	r3, [pc, #16]	; (8003348 <chSchReadyI+0x48>)
 8003338:	4a04      	ldr	r2, [pc, #16]	; (800334c <chSchReadyI+0x4c>)
 800333a:	62da      	str	r2, [r3, #44]	; 0x2c
 800333c:	e7fe      	b.n	800333c <chSchReadyI+0x3c>
 800333e:	b672      	cpsid	i
 8003340:	4b01      	ldr	r3, [pc, #4]	; (8003348 <chSchReadyI+0x48>)
 8003342:	4a02      	ldr	r2, [pc, #8]	; (800334c <chSchReadyI+0x4c>)
 8003344:	62da      	str	r2, [r3, #44]	; 0x2c
 8003346:	e7fe      	b.n	8003346 <chSchReadyI+0x46>
 8003348:	20002740 	.word	0x20002740
 800334c:	08006920 	.word	0x08006920

08003350 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8003350:	6803      	ldr	r3, [r0, #0]
 8003352:	b173      	cbz	r3, 8003372 <chThdResumeI+0x22>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
 8003354:	f893 2020 	ldrb.w	r2, [r3, #32]
 8003358:	2a03      	cmp	r2, #3
 800335a:	d004      	beq.n	8003366 <chThdResumeI+0x16>
 800335c:	b672      	cpsid	i
 800335e:	4b05      	ldr	r3, [pc, #20]	; (8003374 <chThdResumeI+0x24>)
 8003360:	4a05      	ldr	r2, [pc, #20]	; (8003378 <chThdResumeI+0x28>)
 8003362:	62da      	str	r2, [r3, #44]	; 0x2c
 8003364:	e7fe      	b.n	8003364 <chThdResumeI+0x14>
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8003366:	2200      	movs	r2, #0
 8003368:	6002      	str	r2, [r0, #0]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 800336a:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 800336c:	6259      	str	r1, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800336e:	f7ff bfc7 	b.w	8003300 <chSchReadyI>
 8003372:	4770      	bx	lr
 8003374:	20002740 	.word	0x20002740
 8003378:	08006810 	.word	0x08006810
 800337c:	00000000 	.word	0x00000000

08003380 <chThdExitS>:
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8003380:	4d10      	ldr	r5, [pc, #64]	; (80033c4 <chThdExitS+0x44>)
 8003382:	69ac      	ldr	r4, [r5, #24]
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8003384:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8003386:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  thread_t *tp = currp;

  tp->p_u.exitcode = msg;
 8003388:	6260      	str	r0, [r4, #36]	; 0x24
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800338a:	f104 0628 	add.w	r6, r4, #40	; 0x28
 800338e:	429e      	cmp	r6, r3
 8003390:	d007      	beq.n	80033a2 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8003392:	681a      	ldr	r2, [r3, #0]
 8003394:	62a2      	str	r2, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8003396:	4618      	mov	r0, r3
 8003398:	f7ff ffb2 	bl	8003300 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800339c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800339e:	42b3      	cmp	r3, r6
 80033a0:	d1f7      	bne.n	8003392 <chThdExitS+0x12>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 80033a2:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 80033a6:	079b      	lsls	r3, r3, #30
 80033a8:	d104      	bne.n	80033b4 <chThdExitS+0x34>
    REG_REMOVE(tp);
 80033aa:	6963      	ldr	r3, [r4, #20]
 80033ac:	6922      	ldr	r2, [r4, #16]
 80033ae:	611a      	str	r2, [r3, #16]
 80033b0:	6922      	ldr	r2, [r4, #16]
 80033b2:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 80033b4:	200f      	movs	r0, #15
 80033b6:	f7ff fe8b 	bl	80030d0 <chSchGoSleepS>
 80033ba:	b672      	cpsid	i
 80033bc:	4b02      	ldr	r3, [pc, #8]	; (80033c8 <chThdExitS+0x48>)
 80033be:	62eb      	str	r3, [r5, #44]	; 0x2c
 80033c0:	e7fe      	b.n	80033c0 <chThdExitS+0x40>
 80033c2:	bf00      	nop
 80033c4:	20002740 	.word	0x20002740
 80033c8:	08006930 	.word	0x08006930
 80033cc:	00000000 	.word	0x00000000

080033d0 <_dbg_check_leave_isr>:

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80033d0:	2320      	movs	r3, #32
 80033d2:	f383 8811 	msr	BASEPRI, r3
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80033d6:	4b07      	ldr	r3, [pc, #28]	; (80033f4 <_dbg_check_leave_isr+0x24>)
 80033d8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80033da:	2a00      	cmp	r2, #0
 80033dc:	dd01      	ble.n	80033e2 <_dbg_check_leave_isr+0x12>
 80033de:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80033e0:	b119      	cbz	r1, 80033ea <_dbg_check_leave_isr+0x1a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80033e2:	b672      	cpsid	i
 80033e4:	4a04      	ldr	r2, [pc, #16]	; (80033f8 <_dbg_check_leave_isr+0x28>)
 80033e6:	62da      	str	r2, [r3, #44]	; 0x2c
 80033e8:	e7fe      	b.n	80033e8 <_dbg_check_leave_isr+0x18>
    chSysHalt("SV#9");
  }
  ch.dbg.isr_cnt--;
 80033ea:	3a01      	subs	r2, #1
 80033ec:	631a      	str	r2, [r3, #48]	; 0x30

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80033ee:	f381 8811 	msr	BASEPRI, r1
 80033f2:	4770      	bx	lr
 80033f4:	20002740 	.word	0x20002740
 80033f8:	08006850 	.word	0x08006850
 80033fc:	00000000 	.word	0x00000000

08003400 <_dbg_check_enter_isr>:
 8003400:	2320      	movs	r3, #32
 8003402:	f383 8811 	msr	BASEPRI, r3
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003406:	4b07      	ldr	r3, [pc, #28]	; (8003424 <_dbg_check_enter_isr+0x24>)
 8003408:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800340a:	2a00      	cmp	r2, #0
 800340c:	db01      	blt.n	8003412 <_dbg_check_enter_isr+0x12>
 800340e:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8003410:	b119      	cbz	r1, 800341a <_dbg_check_enter_isr+0x1a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003412:	b672      	cpsid	i
 8003414:	4a04      	ldr	r2, [pc, #16]	; (8003428 <_dbg_check_enter_isr+0x28>)
 8003416:	62da      	str	r2, [r3, #44]	; 0x2c
 8003418:	e7fe      	b.n	8003418 <_dbg_check_enter_isr+0x18>
    chSysHalt("SV#8");
  }
  ch.dbg.isr_cnt++;
 800341a:	3201      	adds	r2, #1
 800341c:	631a      	str	r2, [r3, #48]	; 0x30

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800341e:	f381 8811 	msr	BASEPRI, r1
 8003422:	4770      	bx	lr
 8003424:	20002740 	.word	0x20002740
 8003428:	08006858 	.word	0x08006858
 800342c:	00000000 	.word	0x00000000

08003430 <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003430:	4b06      	ldr	r3, [pc, #24]	; (800344c <_dbg_check_unlock_from_isr+0x1c>)
 8003432:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003434:	2a00      	cmp	r2, #0
 8003436:	dd05      	ble.n	8003444 <_dbg_check_unlock_from_isr+0x14>
 8003438:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800343a:	2a00      	cmp	r2, #0
 800343c:	dd02      	ble.n	8003444 <_dbg_check_unlock_from_isr+0x14>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 800343e:	2200      	movs	r2, #0
 8003440:	635a      	str	r2, [r3, #52]	; 0x34
 8003442:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003444:	b672      	cpsid	i
 8003446:	4a02      	ldr	r2, [pc, #8]	; (8003450 <_dbg_check_unlock_from_isr+0x20>)
 8003448:	62da      	str	r2, [r3, #44]	; 0x2c
 800344a:	e7fe      	b.n	800344a <_dbg_check_unlock_from_isr+0x1a>
 800344c:	20002740 	.word	0x20002740
 8003450:	08006860 	.word	0x08006860
	...

08003460 <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003460:	4b06      	ldr	r3, [pc, #24]	; (800347c <_dbg_check_lock_from_isr+0x1c>)
 8003462:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003464:	2a00      	cmp	r2, #0
 8003466:	dd01      	ble.n	800346c <_dbg_check_lock_from_isr+0xc>
 8003468:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800346a:	b11a      	cbz	r2, 8003474 <_dbg_check_lock_from_isr+0x14>
 800346c:	b672      	cpsid	i
 800346e:	4a04      	ldr	r2, [pc, #16]	; (8003480 <_dbg_check_lock_from_isr+0x20>)
 8003470:	62da      	str	r2, [r3, #44]	; 0x2c
 8003472:	e7fe      	b.n	8003472 <_dbg_check_lock_from_isr+0x12>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8003474:	2201      	movs	r2, #1
 8003476:	635a      	str	r2, [r3, #52]	; 0x34
 8003478:	4770      	bx	lr
 800347a:	bf00      	nop
 800347c:	20002740 	.word	0x20002740
 8003480:	08006868 	.word	0x08006868
	...

08003490 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8003490:	b538      	push	{r3, r4, r5, lr}
 8003492:	4604      	mov	r4, r0

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003494:	2320      	movs	r3, #32
 8003496:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
 800349a:	f7ff fdb9 	bl	8003010 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800349e:	f7ff ffdf 	bl	8003460 <_dbg_check_lock_from_isr>
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 80034a2:	f894 3020 	ldrb.w	r3, [r4, #32]
 80034a6:	2b07      	cmp	r3, #7
 80034a8:	d810      	bhi.n	80034cc <wakeup+0x3c>
 80034aa:	e8df f003 	tbb	[pc, r3]
 80034ae:	0f15      	.short	0x0f15
 80034b0:	040a1d0f 	.word	0x040a1d0f
 80034b4:	0a0f      	.short	0x0a0f
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 80034b6:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 80034b8:	f7ff fe42 	bl	8003140 <chDbgCheckClassI>

  sp->s_cnt++;
 80034bc:	68ab      	ldr	r3, [r5, #8]
 80034be:	3301      	adds	r3, #1
 80034c0:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80034c2:	e894 000c 	ldmia.w	r4, {r2, r3}
 80034c6:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80034c8:	6822      	ldr	r2, [r4, #0]
 80034ca:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80034cc:	f04f 33ff 	mov.w	r3, #4294967295
 80034d0:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 80034d2:	4620      	mov	r0, r4
 80034d4:	f7ff ff14 	bl	8003300 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80034d8:	f7ff ffaa 	bl	8003430 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80034dc:	f7ff fd80 	bl	8002fe0 <_stats_stop_measure_crit_isr>
 80034e0:	2300      	movs	r3, #0
 80034e2:	f383 8811 	msr	BASEPRI, r3
 80034e6:	bd38      	pop	{r3, r4, r5, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 80034e8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80034ea:	2200      	movs	r2, #0
 80034ec:	601a      	str	r2, [r3, #0]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80034ee:	f04f 33ff 	mov.w	r3, #4294967295
 80034f2:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 80034f4:	4620      	mov	r0, r4
 80034f6:	f7ff ff03 	bl	8003300 <chSchReadyI>
 80034fa:	e7ed      	b.n	80034d8 <wakeup+0x48>
 80034fc:	0000      	movs	r0, r0
	...

08003500 <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003500:	4b05      	ldr	r3, [pc, #20]	; (8003518 <_dbg_check_unlock+0x18>)
 8003502:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003504:	b922      	cbnz	r2, 8003510 <_dbg_check_unlock+0x10>
 8003506:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8003508:	2900      	cmp	r1, #0
 800350a:	dd01      	ble.n	8003510 <_dbg_check_unlock+0x10>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800350c:	635a      	str	r2, [r3, #52]	; 0x34
 800350e:	4770      	bx	lr
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003510:	b672      	cpsid	i
 8003512:	4a02      	ldr	r2, [pc, #8]	; (800351c <_dbg_check_unlock+0x1c>)
 8003514:	62da      	str	r2, [r3, #44]	; 0x2c
 8003516:	e7fe      	b.n	8003516 <_dbg_check_unlock+0x16>
 8003518:	20002740 	.word	0x20002740
 800351c:	08006870 	.word	0x08006870

08003520 <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003520:	4b05      	ldr	r3, [pc, #20]	; (8003538 <_dbg_check_lock+0x18>)
 8003522:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003524:	b90a      	cbnz	r2, 800352a <_dbg_check_lock+0xa>
 8003526:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003528:	b11a      	cbz	r2, 8003532 <_dbg_check_lock+0x12>
 800352a:	b672      	cpsid	i
 800352c:	4a03      	ldr	r2, [pc, #12]	; (800353c <_dbg_check_lock+0x1c>)
 800352e:	62da      	str	r2, [r3, #44]	; 0x2c
 8003530:	e7fe      	b.n	8003530 <_dbg_check_lock+0x10>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8003532:	2201      	movs	r2, #1
 8003534:	635a      	str	r2, [r3, #52]	; 0x34
 8003536:	4770      	bx	lr
 8003538:	20002740 	.word	0x20002740
 800353c:	08006878 	.word	0x08006878

08003540 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8003540:	b508      	push	{r3, lr}
 8003542:	4604      	mov	r4, r0

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003544:	2320      	movs	r3, #32
 8003546:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 800354a:	f7ff fd69 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800354e:	f7ff ffe7 	bl	8003520 <_dbg_check_lock>

  chSysLock();
  chThdExitS(msg);
 8003552:	4620      	mov	r0, r4
 8003554:	f7ff ff14 	bl	8003380 <chThdExitS>
	...

08003560 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8003560:	b510      	push	{r4, lr}
 8003562:	2320      	movs	r3, #32
 8003564:	4604      	mov	r4, r0
 8003566:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 800356a:	f7ff fd59 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800356e:	f7ff ffd7 	bl	8003520 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 8003572:	b1a4      	cbz	r4, 800359e <chThdSleep+0x3e>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8003574:	4621      	mov	r1, r4
 8003576:	2008      	movs	r0, #8
 8003578:	f7ff fdf2 	bl	8003160 <chSchGoSleepTimeoutS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800357c:	f7ff ffc0 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8003580:	f7ff fd36 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003584:	4b0a      	ldr	r3, [pc, #40]	; (80035b0 <chThdSleep+0x50>)
 8003586:	681a      	ldr	r2, [r3, #0]
 8003588:	429a      	cmp	r2, r3
 800358a:	d004      	beq.n	8003596 <chThdSleep+0x36>
 800358c:	6999      	ldr	r1, [r3, #24]
 800358e:	6892      	ldr	r2, [r2, #8]
 8003590:	6889      	ldr	r1, [r1, #8]
 8003592:	4291      	cmp	r1, r2
 8003594:	d308      	bcc.n	80035a8 <chThdSleep+0x48>
 8003596:	2300      	movs	r3, #0
 8003598:	f383 8811 	msr	BASEPRI, r3
 800359c:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800359e:	b672      	cpsid	i
 80035a0:	4b03      	ldr	r3, [pc, #12]	; (80035b0 <chThdSleep+0x50>)
 80035a2:	4a04      	ldr	r2, [pc, #16]	; (80035b4 <chThdSleep+0x54>)
 80035a4:	62da      	str	r2, [r3, #44]	; 0x2c
 80035a6:	e7fe      	b.n	80035a6 <chThdSleep+0x46>
 80035a8:	b672      	cpsid	i
 80035aa:	4a03      	ldr	r2, [pc, #12]	; (80035b8 <chThdSleep+0x58>)
 80035ac:	62da      	str	r2, [r3, #44]	; 0x2c
 80035ae:	e7fe      	b.n	80035ae <chThdSleep+0x4e>
 80035b0:	20002740 	.word	0x20002740
 80035b4:	08006940 	.word	0x08006940
 80035b8:	08006a00 	.word	0x08006a00
 80035bc:	00000000 	.word	0x00000000

080035c0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 80035c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80035c4:	4617      	mov	r7, r2
 80035c6:	4698      	mov	r8, r3
 80035c8:	b083      	sub	sp, #12
 80035ca:	4604      	mov	r4, r0
 80035cc:	468a      	mov	sl, r1
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 80035ce:	f100 0560 	add.w	r5, r0, #96	; 0x60
 80035d2:	4603      	mov	r3, r0
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 80035d4:	22ff      	movs	r2, #255	; 0xff
 80035d6:	f803 2b01 	strb.w	r2, [r3], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80035da:	429d      	cmp	r5, r3
 80035dc:	d1fb      	bne.n	80035d6 <chThdCreateStatic+0x16>
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 80035de:	eb04 020a 	add.w	r2, r4, sl
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80035e2:	4295      	cmp	r5, r2
 80035e4:	d205      	bcs.n	80035f2 <chThdCreateStatic+0x32>
 80035e6:	462b      	mov	r3, r5
    *startp++ = v;
 80035e8:	2155      	movs	r1, #85	; 0x55
 80035ea:	f803 1b01 	strb.w	r1, [r3], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80035ee:	4293      	cmp	r3, r2
 80035f0:	d1fb      	bne.n	80035ea <chThdCreateStatic+0x2a>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80035f2:	2320      	movs	r3, #32
 80035f4:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 80035f8:	f7ff fd12 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80035fc:	f7ff ff90 	bl	8003520 <_dbg_check_lock>
                       tprio_t prio, tfunc_t pf, void *arg) {
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;

  chDbgCheckClassI();
 8003600:	f7ff fd9e 	bl	8003140 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
 8003604:	2c00      	cmp	r4, #0
 8003606:	f000 8083 	beq.w	8003710 <chThdCreateStatic+0x150>
 800360a:	f5ba 7fb8 	cmp.w	sl, #368	; 0x170
 800360e:	d37f      	bcc.n	8003710 <chThdCreateStatic+0x150>
 8003610:	2f7f      	cmp	r7, #127	; 0x7f
 8003612:	d87d      	bhi.n	8003710 <chThdCreateStatic+0x150>
 8003614:	f1b8 0f00 	cmp.w	r8, #0
 8003618:	d07a      	beq.n	8003710 <chThdCreateStatic+0x150>
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800361a:	4e49      	ldr	r6, [pc, #292]	; (8003740 <chThdCreateStatic+0x180>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800361c:	f8df 9134 	ldr.w	r9, [pc, #308]	; 8003754 <chThdCreateStatic+0x194>
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8003620:	6973      	ldr	r3, [r6, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8003622:	f1aa 0164 	sub.w	r1, sl, #100	; 0x64
 8003626:	4421      	add	r1, r4
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8003628:	f104 022c 	add.w	r2, r4, #44	; 0x2c
 800362c:	9201      	str	r2, [sp, #4]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800362e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8003630:	60e1      	str	r1, [r4, #12]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8003632:	2000      	movs	r0, #0

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8003634:	f8c1 8040 	str.w	r8, [r1, #64]	; 0x40
 8003638:	644a      	str	r2, [r1, #68]	; 0x44
 800363a:	f8c1 9060 	str.w	r9, [r1, #96]	; 0x60
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800363e:	9a01      	ldr	r2, [sp, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8003640:	6163      	str	r3, [r4, #20]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8003642:	f04f 0c01 	mov.w	ip, #1
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8003646:	f104 0e28 	add.w	lr, r4, #40	; 0x28
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800364a:	f04f 0a02 	mov.w	sl, #2
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 800364e:	f04f 3bff 	mov.w	fp, #4294967295
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8003652:	f04f 0800 	mov.w	r8, #0
 8003656:	f04f 0900 	mov.w	r9, #0
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800365a:	60a7      	str	r7, [r4, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800365c:	6126      	str	r6, [r4, #16]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800365e:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8003662:	63e0      	str	r0, [r4, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8003664:	63a0      	str	r0, [r4, #56]	; 0x38
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8003666:	61a0      	str	r0, [r4, #24]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8003668:	6427      	str	r7, [r4, #64]	; 0x40
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800366a:	f884 a020 	strb.w	sl, [r4, #32]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800366e:	f884 c022 	strb.w	ip, [r4, #34]	; 0x22
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8003672:	611c      	str	r4, [r3, #16]
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8003674:	64e0      	str	r0, [r4, #76]	; 0x4c
  tmp->last       = (rtcnt_t)0;
 8003676:	6520      	str	r0, [r4, #80]	; 0x50
  tmp->n          = (ucnt_t)0;
 8003678:	6560      	str	r0, [r4, #84]	; 0x54
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 800367a:	61e5      	str	r5, [r4, #28]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800367c:	f8c4 e028 	str.w	lr, [r4, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003680:	62e2      	str	r2, [r4, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
 8003682:	6322      	str	r2, [r4, #48]	; 0x30
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8003684:	f8c4 b048 	str.w	fp, [r4, #72]	; 0x48
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8003688:	e9c4 8916 	strd	r8, r9, [r4, #88]	; 0x58
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800368c:	6174      	str	r4, [r6, #20]
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {

  chDbgCheckClassS();
 800368e:	f7ff fd0f 	bl	80030b0 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003692:	6833      	ldr	r3, [r6, #0]
 8003694:	69b0      	ldr	r0, [r6, #24]
 8003696:	42b3      	cmp	r3, r6
 8003698:	d04f      	beq.n	800373a <chThdCreateStatic+0x17a>
 800369a:	689a      	ldr	r2, [r3, #8]
 800369c:	6883      	ldr	r3, [r0, #8]
 800369e:	4293      	cmp	r3, r2
 80036a0:	d347      	bcc.n	8003732 <chThdCreateStatic+0x172>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 80036a2:	2200      	movs	r2, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80036a4:	429f      	cmp	r7, r3
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 80036a6:	6262      	str	r2, [r4, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80036a8:	d93f      	bls.n	800372a <chThdCreateStatic+0x16a>
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 80036aa:	f7ff fe29 	bl	8003300 <chSchReadyI>
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 80036ae:	2301      	movs	r3, #1
 80036b0:	f884 3020 	strb.w	r3, [r4, #32]
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 80036b4:	4605      	mov	r5, r0
    setcurrp(ntp);
 80036b6:	61b4      	str	r4, [r6, #24]
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 80036b8:	f7ff fc32 	bl	8002f20 <_dbg_trace>
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {

  ch.kernel_stats.n_ctxswc++;
 80036bc:	f8d6 34ac 	ldr.w	r3, [r6, #1196]	; 0x4ac
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 80036c0:	4f1f      	ldr	r7, [pc, #124]	; (8003740 <chThdCreateStatic+0x180>)
 80036c2:	3301      	adds	r3, #1
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 80036c4:	f105 0048 	add.w	r0, r5, #72	; 0x48
 80036c8:	f104 0148 	add.w	r1, r4, #72	; 0x48
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {

  ch.kernel_stats.n_ctxswc++;
 80036cc:	f8c6 34ac 	str.w	r3, [r6, #1196]	; 0x4ac
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 80036d0:	f7ff fc06 	bl	8002ee0 <chTMChainMeasurementToX>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80036d4:	f3ef 8309 	mrs	r3, PSP
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 80036d8:	69ea      	ldr	r2, [r5, #28]
 80036da:	3b64      	subs	r3, #100	; 0x64
 80036dc:	429a      	cmp	r2, r3
 80036de:	d820      	bhi.n	8003722 <chThdCreateStatic+0x162>
 80036e0:	4629      	mov	r1, r5
 80036e2:	4620      	mov	r0, r4
 80036e4:	f7fc fdf4 	bl	80002d0 <_port_switch>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80036e8:	f7ff ff0a 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80036ec:	f7ff fc80 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80036f0:	6832      	ldr	r2, [r6, #0]
 80036f2:	4b13      	ldr	r3, [pc, #76]	; (8003740 <chThdCreateStatic+0x180>)
 80036f4:	42b2      	cmp	r2, r6
 80036f6:	d004      	beq.n	8003702 <chThdCreateStatic+0x142>
 80036f8:	6999      	ldr	r1, [r3, #24]
 80036fa:	6892      	ldr	r2, [r2, #8]
 80036fc:	6889      	ldr	r1, [r1, #8]
 80036fe:	4291      	cmp	r1, r2
 8003700:	d30b      	bcc.n	800371a <chThdCreateStatic+0x15a>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003702:	2300      	movs	r3, #0
 8003704:	f383 8811 	msr	BASEPRI, r3
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
  chSysUnlock();

  return tp;
}
 8003708:	4620      	mov	r0, r4
 800370a:	b003      	add	sp, #12
 800370c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003710:	b672      	cpsid	i
 8003712:	4b0b      	ldr	r3, [pc, #44]	; (8003740 <chThdCreateStatic+0x180>)
 8003714:	4a0b      	ldr	r2, [pc, #44]	; (8003744 <chThdCreateStatic+0x184>)
 8003716:	62da      	str	r2, [r3, #44]	; 0x2c
 8003718:	e7fe      	b.n	8003718 <chThdCreateStatic+0x158>
 800371a:	b672      	cpsid	i
 800371c:	4a0a      	ldr	r2, [pc, #40]	; (8003748 <chThdCreateStatic+0x188>)
 800371e:	62da      	str	r2, [r3, #44]	; 0x2c
 8003720:	e7fe      	b.n	8003720 <chThdCreateStatic+0x160>
 8003722:	b672      	cpsid	i
 8003724:	4b09      	ldr	r3, [pc, #36]	; (800374c <chThdCreateStatic+0x18c>)
 8003726:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003728:	e7fe      	b.n	8003728 <chThdCreateStatic+0x168>
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
 800372a:	4620      	mov	r0, r4
 800372c:	f7ff fde8 	bl	8003300 <chSchReadyI>
 8003730:	e7da      	b.n	80036e8 <chThdCreateStatic+0x128>
 8003732:	b672      	cpsid	i
 8003734:	4b06      	ldr	r3, [pc, #24]	; (8003750 <chThdCreateStatic+0x190>)
 8003736:	62f3      	str	r3, [r6, #44]	; 0x2c
 8003738:	e7fe      	b.n	8003738 <chThdCreateStatic+0x178>
 800373a:	6883      	ldr	r3, [r0, #8]
 800373c:	e7b1      	b.n	80036a2 <chThdCreateStatic+0xe2>
 800373e:	bf00      	nop
 8003740:	20002740 	.word	0x20002740
 8003744:	08006800 	.word	0x08006800
 8003748:	08006a00 	.word	0x08006a00
 800374c:	08006830 	.word	0x08006830
 8003750:	08006820 	.word	0x08006820
 8003754:	080002e9 	.word	0x080002e9
	...

08003760 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8003760:	e7fe      	b.n	8003760 <BusFault_Handler>
 8003762:	bf00      	nop
	...

08003770 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8003770:	b4f0      	push	{r4, r5, r6, r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8003772:	4e11      	ldr	r6, [pc, #68]	; (80037b8 <__init_ram_areas+0x48>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8003774:	2500      	movs	r5, #0
 8003776:	f106 0780 	add.w	r7, r6, #128	; 0x80
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 800377a:	e896 001a 	ldmia.w	r6, {r1, r3, r4}
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800377e:	42a3      	cmp	r3, r4
 8003780:	d20d      	bcs.n	800379e <__init_ram_areas+0x2e>
 8003782:	3904      	subs	r1, #4
 8003784:	461a      	mov	r2, r3
      *p = *tp;
 8003786:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800378a:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800378e:	42a2      	cmp	r2, r4
 8003790:	d3f9      	bcc.n	8003786 <__init_ram_areas+0x16>
 8003792:	43da      	mvns	r2, r3
 8003794:	4414      	add	r4, r2
 8003796:	f024 0403 	bic.w	r4, r4, #3
 800379a:	3404      	adds	r4, #4
 800379c:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800379e:	68f2      	ldr	r2, [r6, #12]
 80037a0:	4293      	cmp	r3, r2
 80037a2:	d203      	bcs.n	80037ac <__init_ram_areas+0x3c>
      *p = 0;
 80037a4:	f843 5b04 	str.w	r5, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80037a8:	4293      	cmp	r3, r2
 80037aa:	d3fb      	bcc.n	80037a4 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 80037ac:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80037ae:	42be      	cmp	r6, r7
 80037b0:	d3e3      	bcc.n	800377a <__init_ram_areas+0xa>
#endif
}
 80037b2:	bcf0      	pop	{r4, r5, r6, r7}
 80037b4:	4770      	bx	lr
 80037b6:	bf00      	nop
 80037b8:	08006880 	.word	0x08006880
 80037bc:	00000000 	.word	0x00000000

080037c0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 80037c0:	e7fe      	b.n	80037c0 <__default_exit>
 80037c2:	bf00      	nop
	...

080037d0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80037d0:	4770      	bx	lr
 80037d2:	bf00      	nop
	...

080037e0 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 80037e0:	4770      	bx	lr
 80037e2:	bf00      	nop
	...

080037f0 <main>:
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 80037f0:	4bdd      	ldr	r3, [pc, #884]	; (8003b68 <main+0x378>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80037f2:	4cde      	ldr	r4, [pc, #888]	; (8003b6c <main+0x37c>)
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 80037f4:	691a      	ldr	r2, [r3, #16]
 80037f6:	f04f 31ff 	mov.w	r1, #4294967295
 80037fa:	2200      	movs	r2, #0
}

/*
 * Application entry point.
 */
int main(void) {
 80037fc:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8003800:	6119      	str	r1, [r3, #16]
 8003802:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8003804:	6958      	ldr	r0, [r3, #20]
 8003806:	6159      	str	r1, [r3, #20]
 8003808:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800380a:	6a18      	ldr	r0, [r3, #32]
 800380c:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 8003810:	6218      	str	r0, [r3, #32]
 8003812:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8003814:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8003816:	6259      	str	r1, [r3, #36]	; 0x24
 8003818:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800381a:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800381c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8003820:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8003822:	6821      	ldr	r1, [r4, #0]
 8003824:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8003828:	6021      	str	r1, [r4, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800382a:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800382c:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8003830:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8003834:	b08b      	sub	sp, #44	; 0x2c
 8003836:	d003      	beq.n	8003840 <main+0x50>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8003838:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 800383c:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 800383e:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8003840:	48ca      	ldr	r0, [pc, #808]	; (8003b6c <main+0x37c>)
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
 8003842:	4ccb      	ldr	r4, [pc, #812]	; (8003b70 <main+0x380>)
 8003844:	6843      	ldr	r3, [r0, #4]
 8003846:	4fcb      	ldr	r7, [pc, #812]	; (8003b74 <main+0x384>)
 8003848:	4ecb      	ldr	r6, [pc, #812]	; (8003b78 <main+0x388>)
 800384a:	2100      	movs	r1, #0
 800384c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8003850:	6043      	str	r3, [r0, #4]
 8003852:	460a      	mov	r2, r1
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8003854:	460b      	mov	r3, r1
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
 8003856:	6021      	str	r1, [r4, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0U;
 8003858:	58bc      	ldr	r4, [r7, r2]
 800385a:	48c6      	ldr	r0, [pc, #792]	; (8003b74 <main+0x384>)
 800385c:	6021      	str	r1, [r4, #0]
    dma_isr_redir[i].dma_func = NULL;
 800385e:	f846 1033 	str.w	r1, [r6, r3, lsl #3]
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8003862:	3301      	adds	r3, #1
 8003864:	2b10      	cmp	r3, #16
 8003866:	f102 020c 	add.w	r2, r2, #12
    _stm32_dma_streams[i].stream->CR = 0U;
 800386a:	f04f 0500 	mov.w	r5, #0
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 800386e:	d1f3      	bne.n	8003858 <main+0x68>
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8003870:	f8df b31c 	ldr.w	fp, [pc, #796]	; 8003b90 <main+0x3a0>
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
 8003874:	4fc1      	ldr	r7, [pc, #772]	; (8003b7c <main+0x38c>)
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8003876:	49bc      	ldr	r1, [pc, #752]	; (8003b68 <main+0x378>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003878:	f8df a318 	ldr.w	sl, [pc, #792]	; 8003b94 <main+0x3a4>
 800387c:	4cc0      	ldr	r4, [pc, #768]	; (8003b80 <main+0x390>)
 800387e:	f8df 9318 	ldr.w	r9, [pc, #792]	; 8003b98 <main+0x3a8>
 8003882:	4ac0      	ldr	r2, [pc, #768]	; (8003b84 <main+0x394>)
 8003884:	f8df 8314 	ldr.w	r8, [pc, #788]	; 8003b9c <main+0x3ac>
 8003888:	f8df c314 	ldr.w	ip, [pc, #788]	; 8003ba0 <main+0x3b0>
 800388c:	f8df e314 	ldr.w	lr, [pc, #788]	; 8003ba4 <main+0x3b4>
  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8003890:	f04f 36ff 	mov.w	r6, #4294967295
 8003894:	f8cb 6008 	str.w	r6, [fp, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 8003898:	f8cb 600c 	str.w	r6, [fp, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 800389c:	60be      	str	r6, [r7, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 800389e:	60fe      	str	r6, [r7, #12]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80038a0:	6b0f      	ldr	r7, [r1, #48]	; 0x30

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80038a2:	f8df b304 	ldr.w	fp, [pc, #772]	; 8003ba8 <main+0x3b8>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80038a6:	ea6f 2757 	mvn.w	r7, r7, lsr #9
 80038aa:	ea6f 2747 	mvn.w	r7, r7, lsl #9
 80038ae:	630f      	str	r7, [r1, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 80038b0:	6d0f      	ldr	r7, [r1, #80]	; 0x50
 80038b2:	ea6f 2757 	mvn.w	r7, r7, lsr #9
 80038b6:	ea6f 2747 	mvn.w	r7, r7, lsl #9
 80038ba:	650f      	str	r7, [r1, #80]	; 0x50
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80038bc:	f8ca 5004 	str.w	r5, [sl, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80038c0:	f64f 77ff 	movw	r7, #65535	; 0xffff
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80038c4:	f8ca 6008 	str.w	r6, [sl, #8]
  gpiop->PUPDR   = config->pupdr;
 80038c8:	f8ca b00c 	str.w	fp, [sl, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80038cc:	f8df b2dc 	ldr.w	fp, [pc, #732]	; 8003bac <main+0x3bc>
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80038d0:	f8ca 7014 	str.w	r7, [sl, #20]
  gpiop->AFRL    = config->afrl;
 80038d4:	f8ca b020 	str.w	fp, [sl, #32]
  gpiop->AFRH    = config->afrh;
 80038d8:	f44f 2b19 	mov.w	fp, #626688	; 0x99000
 80038dc:	f8ca b024 	str.w	fp, [sl, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80038e0:	f8df b2cc 	ldr.w	fp, [pc, #716]	; 8003bb0 <main+0x3c0>
 80038e4:	f8ca b000 	str.w	fp, [sl]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80038e8:	f44f 7a40 	mov.w	sl, #768	; 0x300
 80038ec:	f8c4 a004 	str.w	sl, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80038f0:	f8df a2c0 	ldr.w	sl, [pc, #704]	; 8003bb4 <main+0x3c4>
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80038f4:	60a6      	str	r6, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 80038f6:	f8c4 a00c 	str.w	sl, [r4, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 80038fa:	f8df a2bc 	ldr.w	sl, [pc, #700]	; 8003bb8 <main+0x3c8>
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80038fe:	6167      	str	r7, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8003900:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8003902:	f8c4 a024 	str.w	sl, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8003906:	f8df a2b4 	ldr.w	sl, [pc, #692]	; 8003bbc <main+0x3cc>
 800390a:	f8c4 a000 	str.w	sl, [r4]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 800390e:	f640 2a28 	movw	sl, #2600	; 0xa28
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003912:	f8c9 5004 	str.w	r5, [r9, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8003916:	f8c9 6008 	str.w	r6, [r9, #8]
  gpiop->PUPDR   = config->pupdr;
 800391a:	f8c9 a00c 	str.w	sl, [r9, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800391e:	f44f 6aa0 	mov.w	sl, #1280	; 0x500
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8003922:	f8c9 7014 	str.w	r7, [r9, #20]
  gpiop->AFRL    = config->afrl;
 8003926:	f8c9 5020 	str.w	r5, [r9, #32]
  gpiop->AFRH    = config->afrh;
 800392a:	f8c9 5024 	str.w	r5, [r9, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800392e:	f8c9 a000 	str.w	sl, [r9]
 8003932:	f44f 7a80 	mov.w	sl, #256	; 0x100
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003936:	f8df b288 	ldr.w	fp, [pc, #648]	; 8003bc0 <main+0x3d0>
 800393a:	f8c8 5004 	str.w	r5, [r8, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800393e:	f8c8 6008 	str.w	r6, [r8, #8]
  gpiop->PUPDR   = config->pupdr;
 8003942:	f8c8 500c 	str.w	r5, [r8, #12]
  gpiop->ODR     = config->odr;
 8003946:	f8c8 7014 	str.w	r7, [r8, #20]
  gpiop->AFRL    = config->afrl;
 800394a:	f8c8 5020 	str.w	r5, [r8, #32]
  gpiop->AFRH    = config->afrh;
 800394e:	f8c8 5024 	str.w	r5, [r8, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8003952:	f8c8 a000 	str.w	sl, [r8]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003956:	6055      	str	r5, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8003958:	6096      	str	r6, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 800395a:	60d5      	str	r5, [r2, #12]
  gpiop->ODR     = config->odr;
 800395c:	6157      	str	r7, [r2, #20]
  gpiop->AFRL    = config->afrl;
 800395e:	6215      	str	r5, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8003960:	6255      	str	r5, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8003962:	6015      	str	r5, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003964:	f8cc 5004 	str.w	r5, [ip, #4]
 8003968:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
  gpiop->OSPEEDR = config->ospeedr;
 800396c:	f8cc 6008 	str.w	r6, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
 8003970:	f8cc 500c 	str.w	r5, [ip, #12]
  gpiop->ODR     = config->odr;
 8003974:	f8cc 7014 	str.w	r7, [ip, #20]
  gpiop->AFRL    = config->afrl;
 8003978:	f8cc 5020 	str.w	r5, [ip, #32]
  gpiop->AFRH    = config->afrh;
 800397c:	f8cc 5024 	str.w	r5, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8003980:	f8cc 5000 	str.w	r5, [ip]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003984:	f8ce 5004 	str.w	r5, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8003988:	f8ce 6008 	str.w	r6, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 800398c:	f8ce 500c 	str.w	r5, [lr, #12]
  gpiop->ODR     = config->odr;
 8003990:	f8ce 7014 	str.w	r7, [lr, #20]
  gpiop->AFRL    = config->afrl;
 8003994:	f8ce 5020 	str.w	r5, [lr, #32]
  gpiop->AFRH    = config->afrh;
 8003998:	f8ce 5024 	str.w	r5, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800399c:	f8ce 5000 	str.w	r5, [lr]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80039a0:	6055      	str	r5, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80039a2:	6096      	str	r6, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80039a4:	60d5      	str	r5, [r2, #12]
  gpiop->ODR     = config->odr;
 80039a6:	6157      	str	r7, [r2, #20]
  gpiop->AFRL    = config->afrl;
 80039a8:	6215      	str	r5, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80039aa:	6255      	str	r5, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80039ac:	6015      	str	r5, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80039ae:	f8cb 5004 	str.w	r5, [fp, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80039b2:	f8cb 6008 	str.w	r6, [fp, #8]
  gpiop->PUPDR   = config->pupdr;
 80039b6:	f8cb 500c 	str.w	r5, [fp, #12]
  gpiop->ODR     = config->odr;
 80039ba:	f8cb 7014 	str.w	r7, [fp, #20]
  gpiop->AFRL    = config->afrl;
 80039be:	f8cb 5020 	str.w	r5, [fp, #32]
  gpiop->AFRH    = config->afrh;
 80039c2:	f8cb 5024 	str.w	r5, [fp, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80039c6:	f8cb 5000 	str.w	r5, [fp]
static void can_lld_set_filters(uint32_t can2sb,
                                uint32_t num,
                                const CANFilter *cfp) {

  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);
 80039ca:	6c0a      	ldr	r2, [r1, #64]	; 0x40
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {

  canp->state    = CAN_STOP;
 80039cc:	f8df 91f4 	ldr.w	r9, [pc, #500]	; 8003bc4 <main+0x3d4>
 80039d0:	f8df a1f4 	ldr.w	sl, [pc, #500]	; 8003bc8 <main+0x3d8>
void can_lld_init(void) {

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
  CAND1.can = CAN1;
 80039d4:	4f6c      	ldr	r7, [pc, #432]	; (8003b88 <main+0x398>)
  canp->config   = NULL;
 80039d6:	f8c9 5004 	str.w	r5, [r9, #4]
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {

  canp->state    = CAN_STOP;
 80039da:	f04f 0801 	mov.w	r8, #1
static void can_lld_set_filters(uint32_t can2sb,
                                uint32_t num,
                                const CANFilter *cfp) {

  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);
 80039de:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 80039e2:	f889 8000 	strb.w	r8, [r9]
 80039e6:	f88a 8000 	strb.w	r8, [sl]
 80039ea:	640a      	str	r2, [r1, #64]	; 0x40

  /* Filters initialization.*/
  CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | CAN_FMR_FINIT;
 80039ec:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
  canp->config   = NULL;
 80039f0:	f8ca 5004 	str.w	r5, [sl, #4]
 80039f4:	0c12      	lsrs	r2, r2, #16
 80039f6:	0412      	lsls	r2, r2, #16
 80039f8:	ea42 0208 	orr.w	r2, r2, r8
 80039fc:	f8c7 2200 	str.w	r2, [r7, #512]	; 0x200
  CAND1.can = CAN1;
#endif
#if STM32_CAN_USE_CAN2
  /* Driver initialization.*/
  canObjectInit(&CAND2);
  CAND2.can = CAN2;
 8003a00:	f5ae 3ed8 	sub.w	lr, lr, #110592	; 0x1b000
  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);

  /* Filters initialization.*/
  CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | CAN_FMR_FINIT;
  CAN1->FMR |=  (can2sb << 8);
 8003a04:	f8d7 2200 	ldr.w	r2, [r7, #512]	; 0x200
  CAND1.can = CAN1;
#endif
#if STM32_CAN_USE_CAN2
  /* Driver initialization.*/
  canObjectInit(&CAND2);
  CAND2.can = CAN2;
 8003a08:	f8ca e02c 	str.w	lr, [sl, #44]	; 0x2c
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8003a0c:	f109 0b1c 	add.w	fp, r9, #28
 8003a10:	f109 0e18 	add.w	lr, r9, #24
 8003a14:	f8c9 e018 	str.w	lr, [r9, #24]
 8003a18:	f8c9 b01c 	str.w	fp, [r9, #28]
 8003a1c:	f109 0c20 	add.w	ip, r9, #32
 8003a20:	f109 0e24 	add.w	lr, r9, #36	; 0x24
 8003a24:	f109 0b28 	add.w	fp, r9, #40	; 0x28
 8003a28:	f8c9 c020 	str.w	ip, [r9, #32]
 8003a2c:	f8c9 e024 	str.w	lr, [r9, #36]	; 0x24
 8003a30:	f8c9 b028 	str.w	fp, [r9, #40]	; 0x28
 8003a34:	f10a 0c18 	add.w	ip, sl, #24
 8003a38:	f10a 0e1c 	add.w	lr, sl, #28
 8003a3c:	f10a 0b20 	add.w	fp, sl, #32
 8003a40:	f8ca c018 	str.w	ip, [sl, #24]
 8003a44:	f8ca e01c 	str.w	lr, [sl, #28]
 8003a48:	f8ca b020 	str.w	fp, [sl, #32]
 8003a4c:	f10a 0c24 	add.w	ip, sl, #36	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003a50:	f109 0b08 	add.w	fp, r9, #8
 8003a54:	f10a 0e28 	add.w	lr, sl, #40	; 0x28
  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);

  /* Filters initialization.*/
  CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | CAN_FMR_FINIT;
  CAN1->FMR |=  (can2sb << 8);
 8003a58:	f442 6260 	orr.w	r2, r2, #3584	; 0xe00
 8003a5c:	f8ca c024 	str.w	ip, [sl, #36]	; 0x24
 8003a60:	f8ca e028 	str.w	lr, [sl, #40]	; 0x28
 8003a64:	f109 0c10 	add.w	ip, r9, #16
 8003a68:	f10a 0e08 	add.w	lr, sl, #8
void can_lld_init(void) {

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
  CAND1.can = CAN1;
 8003a6c:	f8c9 702c 	str.w	r7, [r9, #44]	; 0x2c
  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);

  /* Filters initialization.*/
  CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | CAN_FMR_FINIT;
  CAN1->FMR |=  (can2sb << 8);
 8003a70:	f8c7 2200 	str.w	r2, [r7, #512]	; 0x200
 8003a74:	f10a 0210 	add.w	r2, sl, #16
 8003a78:	f8c9 b008 	str.w	fp, [r9, #8]
  tqp->p_prev = (thread_t *)tqp;
 8003a7c:	f8c9 b00c 	str.w	fp, [r9, #12]
    CAN1->sFilterRegister[can2sb].FR2 = 0;
#endif
    CAN1->FM1R = 0;
    CAN1->FFA1R = 0;
#if STM32_HAS_CAN2
    CAN1->FS1R = 1 | (1 << can2sb);
 8003a80:	f244 0b01 	movw	fp, #16385	; 0x4001
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003a84:	f8c9 c010 	str.w	ip, [r9, #16]
  tqp->p_prev = (thread_t *)tqp;
 8003a88:	f8c9 c014 	str.w	ip, [r9, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003a8c:	f8ca e008 	str.w	lr, [sl, #8]
  tqp->p_prev = (thread_t *)tqp;
 8003a90:	f8ca e00c 	str.w	lr, [sl, #12]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003a94:	f8ca 2010 	str.w	r2, [sl, #16]
  tqp->p_prev = (thread_t *)tqp;
 8003a98:	f8ca 2014 	str.w	r2, [sl, #20]
    }
  }
  else {
    /* Setting up a single default filter that enables everything for both
       CANs.*/
    CAN1->sFilterRegister[0].FR1 = 0;
 8003a9c:	f8c7 5240 	str.w	r5, [r7, #576]	; 0x240
    CAN1->sFilterRegister[0].FR2 = 0;
 8003aa0:	f8c7 5244 	str.w	r5, [r7, #580]	; 0x244
#if STM32_HAS_CAN2
    CAN1->sFilterRegister[can2sb].FR1 = 0;
 8003aa4:	f8c7 52b0 	str.w	r5, [r7, #688]	; 0x2b0
    CAN1->sFilterRegister[can2sb].FR2 = 0;
 8003aa8:	f8c7 52b4 	str.w	r5, [r7, #692]	; 0x2b4
#endif
    CAN1->FM1R = 0;
 8003aac:	f8c7 5204 	str.w	r5, [r7, #516]	; 0x204
    CAN1->FFA1R = 0;
 8003ab0:	f8c7 5214 	str.w	r5, [r7, #532]	; 0x214
#if STM32_HAS_CAN2
    CAN1->FS1R = 1 | (1 << can2sb);
 8003ab4:	f8c7 b20c 	str.w	fp, [r7, #524]	; 0x20c
    CAN1->FA1R = 1 | (1 << can2sb);
 8003ab8:	f8c7 b21c 	str.w	fp, [r7, #540]	; 0x21c
#else
    CAN1->FS1R = 1;
    CAN1->FA1R = 1;
#endif
  }
  CAN1->FMR &= ~CAN_FMR_FINIT;
 8003abc:	f8d7 9200 	ldr.w	r9, [r7, #512]	; 0x200
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8003ac0:	f8df a108 	ldr.w	sl, [pc, #264]	; 8003bcc <main+0x3dc>
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 8003ac4:	f8df b108 	ldr.w	fp, [pc, #264]	; 8003bd0 <main+0x3e0>
  i2cp->config = NULL;
 8003ac8:	f8ca 5004 	str.w	r5, [sl, #4]
 8003acc:	f029 0901 	bic.w	r9, r9, #1
 8003ad0:	f8c7 9200 	str.w	r9, [r7, #512]	; 0x200

  /* Clock disabled, it will be enabled again in can_lld_start().*/
  rccDisableCAN1(FALSE);
 8003ad4:	f8d1 9040 	ldr.w	r9, [r1, #64]	; 0x40
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8003ad8:	f8ca 5014 	str.w	r5, [sl, #20]
 8003adc:	f029 7900 	bic.w	r9, r9, #33554432	; 0x2000000
 8003ae0:	f8c1 9040 	str.w	r9, [r1, #64]	; 0x40
 8003ae4:	f8ca b034 	str.w	fp, [sl, #52]	; 0x34
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 8003ae8:	f100 0b48 	add.w	fp, r0, #72	; 0x48
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8003aec:	4a27      	ldr	r2, [pc, #156]	; (8003b8c <main+0x39c>)
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8003aee:	f8df e0e4 	ldr.w	lr, [pc, #228]	; 8003bd4 <main+0x3e4>
 8003af2:	f8ca b030 	str.w	fp, [sl, #48]	; 0x30
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003af6:	f10a 0b0c 	add.w	fp, sl, #12
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 8003afa:	f8df c0dc 	ldr.w	ip, [pc, #220]	; 8003bd8 <main+0x3e8>

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8003afe:	f8ca 002c 	str.w	r0, [sl, #44]	; 0x2c
 8003b02:	f8ca b00c 	str.w	fp, [sl, #12]
  tqp->p_prev = (thread_t *)tqp;
 8003b06:	f8ca b010 	str.w	fp, [sl, #16]
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
 8003b0a:	f5a7 6740 	sub.w	r7, r7, #3072	; 0xc00
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 8003b0e:	f100 0b18 	add.w	fp, r0, #24
 8003b12:	f88a 8000 	strb.w	r8, [sl]
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 8003b16:	f8ca 501c 	str.w	r5, [sl, #28]
#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 8003b1a:	f100 0a54 	add.w	sl, r0, #84	; 0x54
 8003b1e:	4691      	mov	r9, r2
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
 8003b20:	f8ce 7034 	str.w	r7, [lr, #52]	; 0x34
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 8003b24:	f8ce b02c 	str.w	fp, [lr, #44]	; 0x2c
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003b28:	f10e 070c 	add.w	r7, lr, #12
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 8003b2c:	f8ce a030 	str.w	sl, [lr, #48]	; 0x30
#endif

#if STM32_PWM_USE_TIM5
  /* Driver initialization.*/
  pwmObjectInit(&PWMD5);
  PWMD5.channels = STM32_TIM5_CHANNELS;
 8003b30:	f04f 0b04 	mov.w	fp, #4
  PWMD5.tim = STM32_TIM5;
 8003b34:	f8df a0a4 	ldr.w	sl, [pc, #164]	; 8003bdc <main+0x3ec>
 8003b38:	f8ce 700c 	str.w	r7, [lr, #12]
  tqp->p_prev = (thread_t *)tqp;
 8003b3c:	f8ce 7010 	str.w	r7, [lr, #16]
#endif

#if STM32_PWM_USE_TIM5
  /* Driver initialization.*/
  pwmObjectInit(&PWMD5);
  PWMD5.channels = STM32_TIM5_CHANNELS;
 8003b40:	f88c b010 	strb.w	fp, [ip, #16]
 8003b44:	f88e 8000 	strb.w	r8, [lr]
  i2cp->config = NULL;
 8003b48:	f8ce 5004 	str.w	r5, [lr, #4]
 8003b4c:	f8ce 5014 	str.w	r5, [lr, #20]
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
 8003b50:	f8ce 501c 	str.w	r5, [lr, #28]
 8003b54:	f88c 8000 	strb.w	r8, [ip]
 8003b58:	f8df e084 	ldr.w	lr, [pc, #132]	; 8003be0 <main+0x3f0>
  pwmp->config   = NULL;
 8003b5c:	f8cc 5004 	str.w	r5, [ip, #4]
  pwmp->enabled  = 0;
 8003b60:	f8cc 500c 	str.w	r5, [ip, #12]
 8003b64:	e03e      	b.n	8003be4 <main+0x3f4>
 8003b66:	bf00      	nop
 8003b68:	40023800 	.word	0x40023800
 8003b6c:	40007000 	.word	0x40007000
 8003b70:	20003148 	.word	0x20003148
 8003b74:	08006a10 	.word	0x08006a10
 8003b78:	200030c8 	.word	0x200030c8
 8003b7c:	40026400 	.word	0x40026400
 8003b80:	40020400 	.word	0x40020400
 8003b84:	40021000 	.word	0x40021000
 8003b88:	40006400 	.word	0x40006400
 8003b8c:	200021c4 	.word	0x200021c4
 8003b90:	40026000 	.word	0x40026000
 8003b94:	40020000 	.word	0x40020000
 8003b98:	40020800 	.word	0x40020800
 8003b9c:	40020c00 	.word	0x40020c00
 8003ba0:	40021400 	.word	0x40021400
 8003ba4:	40021800 	.word	0x40021800
 8003ba8:	168202aa 	.word	0x168202aa
 8003bac:	50500000 	.word	0x50500000
 8003bb0:	2a818855 	.word	0x2a818855
 8003bb4:	0a050081 	.word	0x0a050081
 8003bb8:	00997700 	.word	0x00997700
 8003bbc:	0aa00041 	.word	0x0aa00041
 8003bc0:	40022000 	.word	0x40022000
 8003bc4:	20000d84 	.word	0x20000d84
 8003bc8:	20000db4 	.word	0x20000db4
 8003bcc:	20001f90 	.word	0x20001f90
 8003bd0:	40005400 	.word	0x40005400
 8003bd4:	20001fc8 	.word	0x20001fc8
 8003bd8:	20000de4 	.word	0x20000de4
 8003bdc:	40000c00 	.word	0x40000c00
 8003be0:	080069e0 	.word	0x080069e0
  PWMD5.tim = STM32_TIM5;
 8003be4:	f8cc a018 	str.w	sl, [ip, #24]
 *
 * @notapi
 */
void spi_lld_init(void) {

  dummytx = 0xFFFF;
 8003be8:	f8df a314 	ldr.w	sl, [pc, #788]	; 8003f00 <main+0x710>
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 8003bec:	4fb4      	ldr	r7, [pc, #720]	; (8003ec0 <main+0x6d0>)
 8003bee:	f849 eb04 	str.w	lr, [r9], #4
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8003bf2:	f102 0b74 	add.w	fp, r2, #116	; 0x74
  oqp->q_notify  = onfy;
 8003bf6:	f8df c30c 	ldr.w	ip, [pc, #780]	; 8003f04 <main+0x714>
  SD2.usart = USART2;
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
  SD3.usart = USART3;
 8003bfa:	f8df e30c 	ldr.w	lr, [pc, #780]	; 8003f08 <main+0x718>
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8003bfe:	f8c2 b040 	str.w	fp, [r2, #64]	; 0x40
  oqp->q_notify  = onfy;
 8003c02:	f8c2 c04c 	str.w	ip, [r2, #76]	; 0x4c
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8003c06:	f102 0b54 	add.w	fp, r2, #84	; 0x54
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8003c0a:	f102 0c64 	add.w	ip, r2, #100	; 0x64
 8003c0e:	f8c2 e074 	str.w	lr, [r2, #116]	; 0x74
 8003c12:	f8aa 6000 	strh.w	r6, [sl]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003c16:	f102 0e30 	add.w	lr, r2, #48	; 0x30
 8003c1a:	f102 0a0c 	add.w	sl, r2, #12
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8003c1e:	6155      	str	r5, [r2, #20]
 8003c20:	f8c2 9004 	str.w	r9, [r2, #4]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8003c24:	6393      	str	r3, [r2, #56]	; 0x38
 8003c26:	f8c2 a00c 	str.w	sl, [r2, #12]
  tqp->p_prev = (thread_t *)tqp;
 8003c2a:	f8c2 a010 	str.w	sl, [r2, #16]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8003c2e:	f8c2 b018 	str.w	fp, [r2, #24]

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 8003c32:	f100 0a60 	add.w	sl, r0, #96	; 0x60
  iqp->q_rdptr   = bp;
 8003c36:	f8c2 b024 	str.w	fp, [r2, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8003c3a:	f8c2 b020 	str.w	fp, [r2, #32]
  iqp->q_top     = bp + size;
 8003c3e:	f8c2 c01c 	str.w	ip, [r2, #28]
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8003c42:	f8c2 c03c 	str.w	ip, [r2, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8003c46:	f8c2 c048 	str.w	ip, [r2, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8003c4a:	f8c2 c044 	str.w	ip, [r2, #68]	; 0x44
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003c4e:	f8c2 e030 	str.w	lr, [r2, #48]	; 0x30
 8003c52:	f107 0c0c 	add.w	ip, r7, #12
  tqp->p_prev = (thread_t *)tqp;
 8003c56:	f8c2 e034 	str.w	lr, [r2, #52]	; 0x34
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8003c5a:	f882 8008 	strb.w	r8, [r2, #8]
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8003c5e:	6295      	str	r5, [r2, #40]	; 0x28
  iqp->q_link    = link;
 8003c60:	62d2      	str	r2, [r2, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8003c62:	6512      	str	r2, [r2, #80]	; 0x50

  dummytx = 0xFFFF;

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
 8003c64:	f8df 92a4 	ldr.w	r9, [pc, #676]	; 8003f0c <main+0x71c>
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 8003c68:	f8df b2a4 	ldr.w	fp, [pc, #676]	; 8003f10 <main+0x720>
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8003c6c:	4a95      	ldr	r2, [pc, #596]	; (8003ec4 <main+0x6d4>)

  dummytx = 0xFFFF;

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
 8003c6e:	f8c7 901c 	str.w	r9, [r7, #28]
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 8003c72:	3084      	adds	r0, #132	; 0x84
  dummytx = 0xFFFF;

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 8003c74:	f8c7 a020 	str.w	sl, [r7, #32]
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 8003c78:	6278      	str	r0, [r7, #36]	; 0x24
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 8003c7a:	f8c7 b028 	str.w	fp, [r7, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003c7e:	f8c7 c00c 	str.w	ip, [r7, #12]
  tqp->p_prev = (thread_t *)tqp;
 8003c82:	f8c7 c010 	str.w	ip, [r7, #16]
 8003c86:	f887 8000 	strb.w	r8, [r7]
  spip->config = NULL;
 8003c8a:	607d      	str	r5, [r7, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 8003c8c:	60bd      	str	r5, [r7, #8]
 8003c8e:	617d      	str	r5, [r7, #20]
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8003c90:	62fa      	str	r2, [r7, #44]	; 0x2c

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8003c92:	6c0a      	ldr	r2, [r1, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8003c94:	f8df b27c 	ldr.w	fp, [pc, #636]	; 8003f14 <main+0x724>
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003c98:	4f8b      	ldr	r7, [pc, #556]	; (8003ec8 <main+0x6d8>)
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8003c9a:	f8df e27c 	ldr.w	lr, [pc, #636]	; 8003f18 <main+0x728>

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8003c9e:	f8df a27c 	ldr.w	sl, [pc, #636]	; 8003f1c <main+0x72c>
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8003ca2:	488a      	ldr	r0, [pc, #552]	; (8003ecc <main+0x6dc>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8003ca4:	f8df 9278 	ldr.w	r9, [pc, #632]	; 8003f20 <main+0x730>
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8003ca8:	f8df c278 	ldr.w	ip, [pc, #632]	; 8003f24 <main+0x734>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8003cac:	ea42 0208 	orr.w	r2, r2, r8
 8003cb0:	640a      	str	r2, [r1, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8003cb2:	f8db 1008 	ldr.w	r1, [fp, #8]
  tqp->p_prev = (thread_t *)tqp;
 8003cb6:	607f      	str	r7, [r7, #4]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8003cb8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8003cbc:	ea41 0108 	orr.w	r1, r1, r8
 8003cc0:	f8cb 1008 	str.w	r1, [fp, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8003cc4:	f242 01cf 	movw	r1, #8399	; 0x20cf
 8003cc8:	6291      	str	r1, [r2, #40]	; 0x28
 8003cca:	f04f 0b80 	mov.w	fp, #128	; 0x80
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003cce:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8003cd2:	62d6      	str	r6, [r2, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8003cd4:	6195      	str	r5, [r2, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8003cd6:	6355      	str	r5, [r2, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8003cd8:	60d5      	str	r5, [r2, #12]
  STM32_ST_TIM->CR2    = 0;
 8003cda:	6055      	str	r5, [r2, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8003cdc:	f8c2 8014 	str.w	r8, [r2, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8003ce0:	f8c2 8000 	str.w	r8, [r2]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8003ce4:	f88a b31c 	strb.w	fp, [sl, #796]	; 0x31c
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003ce8:	f8ca 1180 	str.w	r1, [sl, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8003cec:	f8ca 1000 	str.w	r1, [sl]
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8003cf0:	f8ce 5008 	str.w	r5, [lr, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003cf4:	f8de 100c 	ldr.w	r1, [lr, #12]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8003cf8:	60bd      	str	r5, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8003cfa:	f64f 02ff 	movw	r2, #63743	; 0xf8ff
 8003cfe:	400a      	ands	r2, r1
  reg_value  =  (reg_value                                   |
 8003d00:	4310      	orrs	r0, r2
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8003d02:	f8ce 000c 	str.w	r0, [lr, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8003d06:	f8d9 200c 	ldr.w	r2, [r9, #12]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8003d0a:	613f      	str	r7, [r7, #16]
 8003d0c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8003d10:	f8c9 200c 	str.w	r2, [r9, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8003d14:	f8dc 2000 	ldr.w	r2, [ip]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8003d18:	617f      	str	r7, [r7, #20]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8003d1a:	f107 011c 	add.w	r1, r7, #28
 8003d1e:	ea42 0208 	orr.w	r2, r2, r8
 8003d22:	f04f 0a00 	mov.w	sl, #0
 8003d26:	f04f 0b00 	mov.w	fp, #0
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003d2a:	f04f 0920 	mov.w	r9, #32
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8003d2e:	a804      	add	r0, sp, #16
 8003d30:	f8cc 2000 	str.w	r2, [ip]
 8003d34:	f88e 301f 	strb.w	r3, [lr, #31]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 8003d38:	627e      	str	r6, [r7, #36]	; 0x24
 8003d3a:	f88e 9022 	strb.w	r9, [lr, #34]	; 0x22
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8003d3e:	61f9      	str	r1, [r7, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8003d40:	6239      	str	r1, [r7, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8003d42:	62bd      	str	r5, [r7, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003d44:	603f      	str	r7, [r7, #0]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8003d46:	f8c7 54a0 	str.w	r5, [r7, #1184]	; 0x4a0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8003d4a:	9604      	str	r6, [sp, #16]
  tmp->worst      = (rtcnt_t)0;
 8003d4c:	9505      	str	r5, [sp, #20]
  tmp->last       = (rtcnt_t)0;
 8003d4e:	9506      	str	r5, [sp, #24]
  tmp->n          = (ucnt_t)0;
 8003d50:	9507      	str	r5, [sp, #28]
  tmp->cumulative = (rttime_t)0;
 8003d52:	e9cd ab08 	strd	sl, fp, [sp, #32]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8003d56:	f7ff f953 	bl	8003000 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8003d5a:	a804      	add	r0, sp, #16
 8003d5c:	f7ff f918 	bl	8002f90 <chTMStopMeasurementX>
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8003d60:	4a5b      	ldr	r2, [pc, #364]	; (8003ed0 <main+0x6e0>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8003d62:	495c      	ldr	r1, [pc, #368]	; (8003ed4 <main+0x6e4>)
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8003d64:	4b5c      	ldr	r3, [pc, #368]	; (8003ed8 <main+0x6e8>)
 8003d66:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 8003f28 <main+0x738>
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8003d6a:	f8df c1c0 	ldr.w	ip, [pc, #448]	; 8003f2c <main+0x73c>
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8003d6e:	6978      	ldr	r0, [r7, #20]
  default_heap.h_free.h.u.next = NULL;
 8003d70:	609d      	str	r5, [r3, #8]

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8003d72:	f507 6e98 	add.w	lr, r7, #1216	; 0x4c0
 8003d76:	e9ce ab00 	strd	sl, fp, [lr]
 8003d7a:	f022 0207 	bic.w	r2, r2, #7
 8003d7e:	f507 6e9b 	add.w	lr, r7, #1240	; 0x4d8
 8003d82:	9203      	str	r2, [sp, #12]
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8003d84:	f021 0107 	bic.w	r1, r1, #7
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
  chTMStopMeasurementX(&tm);
  ch.tm.offset = tm.last;
 8003d88:	9a06      	ldr	r2, [sp, #24]
 8003d8a:	f8c9 1000 	str.w	r1, [r9]

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8003d8e:	e9ce ab00 	strd	sl, fp, [lr]
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8003d92:	f107 0e40 	add.w	lr, r7, #64	; 0x40
 8003d96:	f103 0110 	add.w	r1, r3, #16
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
  chTMStopMeasurementX(&tm);
  ch.tm.offset = tm.last;
 8003d9a:	f8c7 24a0 	str.w	r2, [r7, #1184]	; 0x4a0
 8003d9e:	f8c7 e03c 	str.w	lr, [r7, #60]	; 0x3c
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8003da2:	9a03      	ldr	r2, [sp, #12]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8003da4:	f8df e188 	ldr.w	lr, [pc, #392]	; 8003f30 <main+0x740>
 8003da8:	f8cc 2000 	str.w	r2, [ip]
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
 8003dac:	f04f 0940 	mov.w	r9, #64	; 0x40
 8003db0:	f507 6288 	add.w	r2, r7, #1088	; 0x440
 8003db4:	f8c3 e000 	str.w	lr, [r3]
 8003db8:	6119      	str	r1, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 8003dba:	6159      	str	r1, [r3, #20]
  default_heap.h_free.h.u.next = NULL;
  default_heap.h_free.h.size = 0;
 8003dbc:	60dd      	str	r5, [r3, #12]
 8003dbe:	619d      	str	r5, [r3, #24]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8003dc0:	f507 6e8d 	add.w	lr, r7, #1128	; 0x468
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003dc4:	f207 436c 	addw	r3, r7, #1132	; 0x46c

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8003dc8:	f507 6193 	add.w	r1, r7, #1176	; 0x498

  currp->p_state = CH_STATE_CURRENT;
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 8003dcc:	f8df c164 	ldr.w	ip, [pc, #356]	; 8003f34 <main+0x744>
 *
 * @init
 */
void _stats_init(void) {

  ch.kernel_stats.n_irq = (ucnt_t)0;
 8003dd0:	f8c7 54a8 	str.w	r5, [r7, #1192]	; 0x4a8
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
 8003dd4:	f8c7 54ac 	str.w	r5, [r7, #1196]	; 0x4ac
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8003dd8:	f8c7 64b0 	str.w	r6, [r7, #1200]	; 0x4b0
  tmp->worst      = (rtcnt_t)0;
 8003ddc:	f8c7 54b4 	str.w	r5, [r7, #1204]	; 0x4b4
  tmp->last       = (rtcnt_t)0;
 8003de0:	f8c7 54b8 	str.w	r5, [r7, #1208]	; 0x4b8
  tmp->n          = (ucnt_t)0;
 8003de4:	f8c7 54bc 	str.w	r5, [r7, #1212]	; 0x4bc
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8003de8:	f8c7 64c8 	str.w	r6, [r7, #1224]	; 0x4c8
  tmp->worst      = (rtcnt_t)0;
 8003dec:	f8c7 54cc 	str.w	r5, [r7, #1228]	; 0x4cc
  tmp->last       = (rtcnt_t)0;
 8003df0:	f8c7 54d0 	str.w	r5, [r7, #1232]	; 0x4d0
  tmp->n          = (ucnt_t)0;
 8003df4:	f8c7 54d4 	str.w	r5, [r7, #1236]	; 0x4d4
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8003df8:	f887 5461 	strb.w	r5, [r7, #1121]	; 0x461
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8003dfc:	f8c7 547c 	str.w	r5, [r7, #1148]	; 0x47c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8003e00:	f8c7 5478 	str.w	r5, [r7, #1144]	; 0x478
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8003e04:	f887 8462 	strb.w	r8, [r7, #1122]	; 0x462
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8003e08:	f8c7 5458 	str.w	r5, [r7, #1112]	; 0x458
  REG_INSERT(tp);
 8003e0c:	f8c7 7450 	str.w	r7, [r7, #1104]	; 0x450
 8003e10:	f8c7 9038 	str.w	r9, [r7, #56]	; 0x38
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8003e14:	f8c7 9448 	str.w	r9, [r7, #1096]	; 0x448
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8003e18:	f8c7 0454 	str.w	r0, [r7, #1108]	; 0x454
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8003e1c:	f8c7 9480 	str.w	r9, [r7, #1152]	; 0x480
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8003e20:	6102      	str	r2, [r0, #16]
 8003e22:	f8c7 346c 	str.w	r3, [r7, #1132]	; 0x46c
  tqp->p_prev = (thread_t *)tqp;
 8003e26:	f8c7 3470 	str.w	r3, [r7, #1136]	; 0x470
#endif

#if CH_DBG_STATISTICS == TRUE
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->p_stats);
 8003e2a:	f507 6091 	add.w	r0, r7, #1160	; 0x488
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8003e2e:	f8c7 6488 	str.w	r6, [r7, #1160]	; 0x488
  tmp->worst      = (rtcnt_t)0;
 8003e32:	f8c7 548c 	str.w	r5, [r7, #1164]	; 0x48c
  tmp->last       = (rtcnt_t)0;
 8003e36:	f8c7 5490 	str.w	r5, [r7, #1168]	; 0x490
  tmp->n          = (ucnt_t)0;
 8003e3a:	f8c7 5494 	str.w	r5, [r7, #1172]	; 0x494
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8003e3e:	f887 8460 	strb.w	r8, [r7, #1120]	; 0x460
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8003e42:	f8c7 e468 	str.w	lr, [r7, #1128]	; 0x468
  tmp->cumulative = (rttime_t)0;
 8003e46:	e9c1 ab00 	strd	sl, fp, [r1]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 8003e4a:	f8c7 c45c 	str.w	ip, [r7, #1116]	; 0x45c
 8003e4e:	617a      	str	r2, [r7, #20]
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8003e50:	61ba      	str	r2, [r7, #24]
  currp->p_stklimit = &__main_thread_stack_base__;
#endif

#if CH_DBG_STATISTICS == TRUE
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->p_stats);
 8003e52:	f7ff f8d5 	bl	8003000 <chTMStartMeasurementX>
 *
 * @notapi
 */
void _dbg_check_enable(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003e56:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003e58:	b90b      	cbnz	r3, 8003e5e <main+0x66e>
 8003e5a:	6b7d      	ldr	r5, [r7, #52]	; 0x34
 8003e5c:	b11d      	cbz	r5, 8003e66 <main+0x676>
 8003e5e:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8003e60:	4b1e      	ldr	r3, [pc, #120]	; (8003edc <main+0x6ec>)
 8003e62:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003e64:	e7fe      	b.n	8003e64 <main+0x674>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003e66:	f385 8811 	msr	BASEPRI, r5
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003e6a:	b662      	cpsie	i
 8003e6c:	69bb      	ldr	r3, [r7, #24]
 8003e6e:	4a1c      	ldr	r2, [pc, #112]	; (8003ee0 <main+0x6f0>)
 8003e70:	619a      	str	r2, [r3, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8003e72:	f44f 71c0 	mov.w	r1, #384	; 0x180
 8003e76:	4642      	mov	r2, r8
 8003e78:	4b1a      	ldr	r3, [pc, #104]	; (8003ee4 <main+0x6f4>)
 8003e7a:	9500      	str	r5, [sp, #0]
 8003e7c:	f507 609c 	add.w	r0, r7, #1248	; 0x4e0
 8003e80:	f7ff fb9e 	bl	80035c0 <chThdCreateStatic>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8003e84:	4b18      	ldr	r3, [pc, #96]	; (8003ee8 <main+0x6f8>)
 8003e86:	6183      	str	r3, [r0, #24]
  commands
};

void shellStart(void)
{
  sdStart(SERIAL_CMD, NULL);
 8003e88:	f000 fafa 	bl	8004480 <sdStart.constprop.25>
 * @api
 */
thread_t *shellCreateStatic(const ShellConfig *scp, void *wsp,
                            size_t size, tprio_t prio) {

  return chThdCreateStatic(wsp, size, prio, shell_thread, (void *)scp);
 8003e8c:	4b17      	ldr	r3, [pc, #92]	; (8003eec <main+0x6fc>)
 8003e8e:	9300      	str	r3, [sp, #0]
 8003e90:	464a      	mov	r2, r9
 8003e92:	4b17      	ldr	r3, [pc, #92]	; (8003ef0 <main+0x700>)
 8003e94:	4817      	ldr	r0, [pc, #92]	; (8003ef4 <main+0x704>)
 8003e96:	f44f 61ae 	mov.w	r1, #1392	; 0x570
 8003e9a:	f7ff fb91 	bl	80035c0 <chThdCreateStatic>
  halInit();
  chSysInit();

  shellStart();

  chThdCreateStatic(TFT_thread_wa, sizeof(TFT_thread_wa),
 8003e9e:	9500      	str	r5, [sp, #0]
 8003ea0:	4815      	ldr	r0, [pc, #84]	; (8003ef8 <main+0x708>)
 8003ea2:	4b16      	ldr	r3, [pc, #88]	; (8003efc <main+0x70c>)
 8003ea4:	f241 1170 	movw	r1, #4464	; 0x1170
 8003ea8:	2236      	movs	r2, #54	; 0x36
 8003eaa:	f7ff fb89 	bl	80035c0 <chThdCreateStatic>
  NORMALPRIO - 10,
                    TFT_thread, NULL);

  while (true)
  {
    palTogglePad(GPIOB,GPIOB_LED);
 8003eae:	6963      	ldr	r3, [r4, #20]
 8003eb0:	f083 0308 	eor.w	r3, r3, #8
 8003eb4:	6163      	str	r3, [r4, #20]
    chThdSleepMilliseconds(1000);
 8003eb6:	f242 7010 	movw	r0, #10000	; 0x2710
 8003eba:	f7ff fb51 	bl	8003560 <chThdSleep>
 8003ebe:	e7f6      	b.n	8003eae <main+0x6be>
 8003ec0:	20002194 	.word	0x20002194
 8003ec4:	06010046 	.word	0x06010046
 8003ec8:	20002740 	.word	0x20002740
 8003ecc:	05fa0300 	.word	0x05fa0300
 8003ed0:	20020000 	.word	0x20020000
 8003ed4:	200032e7 	.word	0x200032e7
 8003ed8:	20001f70 	.word	0x20001f70
 8003edc:	08006980 	.word	0x08006980
 8003ee0:	08006960 	.word	0x08006960
 8003ee4:	08002f61 	.word	0x08002f61
 8003ee8:	08006988 	.word	0x08006988
 8003eec:	080069d0 	.word	0x080069d0
 8003ef0:	08001081 	.word	0x08001081
 8003ef4:	20000810 	.word	0x20000810
 8003ef8:	20000e00 	.word	0x20000e00
 8003efc:	08002361 	.word	0x08002361
 8003f00:	20000d80 	.word	0x20000d80
 8003f04:	08000741 	.word	0x08000741
 8003f08:	40004800 	.word	0x40004800
 8003f0c:	40013000 	.word	0x40013000
 8003f10:	06010016 	.word	0x06010016
 8003f14:	e0042000 	.word	0xe0042000
 8003f18:	e000ed00 	.word	0xe000ed00
 8003f1c:	e000e100 	.word	0xe000e100
 8003f20:	e000edf0 	.word	0xe000edf0
 8003f24:	e0001000 	.word	0xe0001000
 8003f28:	20000808 	.word	0x20000808
 8003f2c:	20002000 	.word	0x20002000
 8003f30:	08001b21 	.word	0x08001b21
 8003f34:	20000400 	.word	0x20000400
	...

08003f40 <Host_thread.lto_priv.48>:

#include <math.h>
#define HOST_TRANSMIT_FREQ  100U
static THD_WORKING_AREA(Host_thread_wa, 512);
static THD_FUNCTION(Host_thread, p)
{
 8003f40:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  (void)p;
  chRegSetThreadName("Test");

  if((*SERIAL_DATA).state != SD_READY)
 8003f44:	4d46      	ldr	r5, [pc, #280]	; (8004060 <Host_thread.lto_priv.48+0x120>)
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8003f46:	4e47      	ldr	r6, [pc, #284]	; (8004064 <Host_thread.lto_priv.48+0x124>)
 8003f48:	7a2b      	ldrb	r3, [r5, #8]
 8003f4a:	69b2      	ldr	r2, [r6, #24]
 8003f4c:	4946      	ldr	r1, [pc, #280]	; (8004068 <Host_thread.lto_priv.48+0x128>)
 8003f4e:	6191      	str	r1, [r2, #24]
 8003f50:	2b02      	cmp	r3, #2

#include <math.h>
#define HOST_TRANSMIT_FREQ  100U
static THD_WORKING_AREA(Host_thread_wa, 512);
static THD_FUNCTION(Host_thread, p)
{
 8003f52:	b0a3      	sub	sp, #140	; 0x8c
  (void)p;
  chRegSetThreadName("Test");

  if((*SERIAL_DATA).state != SD_READY)
 8003f54:	d001      	beq.n	8003f5a <Host_thread.lto_priv.48+0x1a>
    sdStart(SERIAL_DATA, NULL);
 8003f56:	f000 fa93 	bl	8004480 <sdStart.constprop.25>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003f5a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003f5e:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8003f60:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  uint32_t tick = chVTGetSystemTimeX();

  const uint16_t period = US2ST(1000000/HOST_TRANSMIT_FREQ);
  while (true)
  {
    tick += period;
 8003f62:	3464      	adds	r4, #100	; 0x64
    if(tick > chVTGetSystemTimeX())
 8003f64:	429c      	cmp	r4, r3
 8003f66:	d967      	bls.n	8004038 <Host_thread.lto_priv.48+0xf8>
 8003f68:	f8df b0f8 	ldr.w	fp, [pc, #248]	; 8004064 <Host_thread.lto_priv.48+0x124>
      tft_printf(3,6,"Host thread timeout occured!");
      break;
    }

    txbuf_d[0] = (int16_t)(tick % 10000);
    txbuf_f[0] = sinf((float)(txbuf_d[0] - 5000) * M_PI/5000.0f);
 8003f6c:	eddf 8a3f 	vldr	s17, [pc, #252]	; 800406c <Host_thread.lto_priv.48+0x12c>
 8003f70:	ed9f 8a3f 	vldr	s16, [pc, #252]	; 8004070 <Host_thread.lto_priv.48+0x130>
 8003f74:	af02      	add	r7, sp, #8
 8003f76:	f10d 080c 	add.w	r8, sp, #12
 8003f7a:	f10d 094c 	add.w	r9, sp, #76	; 0x4c

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003f7e:	2320      	movs	r3, #32
 8003f80:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 8003f84:	f7ff f84c 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8003f88:	f7ff faca 	bl	8003520 <_dbg_check_lock>
 8003f8c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003f90:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 */
void chThdSleepUntil(systime_t time) {

  chSysLock();
  time -= chVTGetSystemTimeX();
  if (time > (systime_t)0) {
 8003f92:	1ae1      	subs	r1, r4, r3
 8003f94:	d002      	beq.n	8003f9c <Host_thread.lto_priv.48+0x5c>
 8003f96:	2008      	movs	r0, #8
 8003f98:	f7ff f8e2 	bl	8003160 <chSchGoSleepTimeoutS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003f9c:	f7ff fab0 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8003fa0:	f7ff f826 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003fa4:	6833      	ldr	r3, [r6, #0]
 8003fa6:	4a2f      	ldr	r2, [pc, #188]	; (8004064 <Host_thread.lto_priv.48+0x124>)
 8003fa8:	42b3      	cmp	r3, r6
 8003faa:	d005      	beq.n	8003fb8 <Host_thread.lto_priv.48+0x78>
 8003fac:	f8db 1018 	ldr.w	r1, [fp, #24]
 8003fb0:	689b      	ldr	r3, [r3, #8]
 8003fb2:	6889      	ldr	r1, [r1, #8]
 8003fb4:	4299      	cmp	r1, r3
 8003fb6:	d34e      	bcc.n	8004056 <Host_thread.lto_priv.48+0x116>
 8003fb8:	2300      	movs	r3, #0
 8003fba:	f383 8811 	msr	BASEPRI, r3
    {
      tft_printf(3,6,"Host thread timeout occured!");
      break;
    }

    txbuf_d[0] = (int16_t)(tick % 10000);
 8003fbe:	4b2d      	ldr	r3, [pc, #180]	; (8004074 <Host_thread.lto_priv.48+0x134>)
 8003fc0:	fba3 3204 	umull	r3, r2, r3, r4
 8003fc4:	0b52      	lsrs	r2, r2, #13
 8003fc6:	f242 7310 	movw	r3, #10000	; 0x2710
 8003fca:	fb03 4212 	mls	r2, r3, r2, r4
    txbuf_f[0] = sinf((float)(txbuf_d[0] - 5000) * M_PI/5000.0f);
 8003fce:	f5a2 539c 	sub.w	r3, r2, #4992	; 0x1380
 8003fd2:	3b08      	subs	r3, #8
 8003fd4:	ee07 3a90 	vmov	s15, r3
 8003fd8:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
    {
      tft_printf(3,6,"Host thread timeout occured!");
      break;
    }

    txbuf_d[0] = (int16_t)(tick % 10000);
 8003fdc:	9202      	str	r2, [sp, #8]
    txbuf_f[0] = sinf((float)(txbuf_d[0] - 5000) * M_PI/5000.0f);
 8003fde:	ee20 0a28 	vmul.f32	s0, s0, s17
  (BaseSequentialStream* chp,
    uint32_t* const txbuf_d, float* const txbuf_f,
    const uint8_t num_int, const uint8_t num_float)
{
  uint32_t sync = SYNC_SEQ;
  char* byte = (char*)&sync;
 8003fe2:	f10d 0a04 	add.w	sl, sp, #4
      tft_printf(3,6,"Host thread timeout occured!");
      break;
    }

    txbuf_d[0] = (int16_t)(tick % 10000);
    txbuf_f[0] = sinf((float)(txbuf_d[0] - 5000) * M_PI/5000.0f);
 8003fe6:	ee80 0a08 	vdiv.f32	s0, s0, s16
 8003fea:	f000 fc29 	bl	8004840 <sinf>
static void transmit_host
  (BaseSequentialStream* chp,
    uint32_t* const txbuf_d, float* const txbuf_f,
    const uint8_t num_int, const uint8_t num_float)
{
  uint32_t sync = SYNC_SEQ;
 8003fee:	4b22      	ldr	r3, [pc, #136]	; (8004078 <Host_thread.lto_priv.48+0x138>)
 8003ff0:	9301      	str	r3, [sp, #4]
      tft_printf(3,6,"Host thread timeout occured!");
      break;
    }

    txbuf_d[0] = (int16_t)(tick % 10000);
    txbuf_f[0] = sinf((float)(txbuf_d[0] - 5000) * M_PI/5000.0f);
 8003ff2:	ed8d 0a12 	vstr	s0, [sp, #72]	; 0x48
  uint32_t sync = SYNC_SEQ;
  char* byte = (char*)&sync;

  uint8_t i;
  for (i = 0; i < 4; i++)
    chSequentialStreamPut(chp, *byte++);
 8003ff6:	682a      	ldr	r2, [r5, #0]
 8003ff8:	f81a 1b01 	ldrb.w	r1, [sl], #1
 8003ffc:	6892      	ldr	r2, [r2, #8]
 8003ffe:	4818      	ldr	r0, [pc, #96]	; (8004060 <Host_thread.lto_priv.48+0x120>)
 8004000:	4790      	blx	r2
{
  uint32_t sync = SYNC_SEQ;
  char* byte = (char*)&sync;

  uint8_t i;
  for (i = 0; i < 4; i++)
 8004002:	45ba      	cmp	sl, r7
 8004004:	d1f7      	bne.n	8003ff6 <Host_thread.lto_priv.48+0xb6>
 8004006:	46ba      	mov	sl, r7
    chSequentialStreamPut(chp, *byte++);

  byte = (char*)txbuf_d;
  for (i = 0; i < 4*num_int; i++)
    chSequentialStreamPut(chp, *byte++);
 8004008:	682a      	ldr	r2, [r5, #0]
 800400a:	f81a 1b01 	ldrb.w	r1, [sl], #1
 800400e:	6892      	ldr	r2, [r2, #8]
 8004010:	4813      	ldr	r0, [pc, #76]	; (8004060 <Host_thread.lto_priv.48+0x120>)
 8004012:	4790      	blx	r2
  uint8_t i;
  for (i = 0; i < 4; i++)
    chSequentialStreamPut(chp, *byte++);

  byte = (char*)txbuf_d;
  for (i = 0; i < 4*num_int; i++)
 8004014:	45c2      	cmp	sl, r8
 8004016:	d1f7      	bne.n	8004008 <Host_thread.lto_priv.48+0xc8>
 8004018:	f10d 0a48 	add.w	sl, sp, #72	; 0x48
    chSequentialStreamPut(chp, *byte++);

  byte = (char*)txbuf_f;
  for (i = 0; i < 4*num_float; i++)
    chSequentialStreamPut(chp, *byte++);
 800401c:	682a      	ldr	r2, [r5, #0]
 800401e:	f81a 1b01 	ldrb.w	r1, [sl], #1
 8004022:	6892      	ldr	r2, [r2, #8]
 8004024:	480e      	ldr	r0, [pc, #56]	; (8004060 <Host_thread.lto_priv.48+0x120>)
 8004026:	4790      	blx	r2
  byte = (char*)txbuf_d;
  for (i = 0; i < 4*num_int; i++)
    chSequentialStreamPut(chp, *byte++);

  byte = (char*)txbuf_f;
  for (i = 0; i < 4*num_float; i++)
 8004028:	45ca      	cmp	sl, r9
 800402a:	d1f7      	bne.n	800401c <Host_thread.lto_priv.48+0xdc>
 800402c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  uint32_t tick = chVTGetSystemTimeX();

  const uint16_t period = US2ST(1000000/HOST_TRANSMIT_FREQ);
  while (true)
  {
    tick += period;
 8004030:	3464      	adds	r4, #100	; 0x64
 8004032:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    if(tick > chVTGetSystemTimeX())
 8004034:	42a3      	cmp	r3, r4
 8004036:	d3a2      	bcc.n	8003f7e <Host_thread.lto_priv.48+0x3e>
      chThdSleepUntil(tick);
    else
    {
      tft_printf(3,6,"Host thread timeout occured!");
 8004038:	2003      	movs	r0, #3
 800403a:	2106      	movs	r1, #6
 800403c:	4a0f      	ldr	r2, [pc, #60]	; (800407c <Host_thread.lto_priv.48+0x13c>)
    transmit_host(chp, txbuf_d, txbuf_f, 1, 1);
  }

  while(true)
  {
    palTogglePad(GPIOB,GPIOB_LED);
 800403e:	4c10      	ldr	r4, [pc, #64]	; (8004080 <Host_thread.lto_priv.48+0x140>)
    tick += period;
    if(tick > chVTGetSystemTimeX())
      chThdSleepUntil(tick);
    else
    {
      tft_printf(3,6,"Host thread timeout occured!");
 8004040:	f000 f94e 	bl	80042e0 <tft_printf.constprop.3>
    transmit_host(chp, txbuf_d, txbuf_f, 1, 1);
  }

  while(true)
  {
    palTogglePad(GPIOB,GPIOB_LED);
 8004044:	6963      	ldr	r3, [r4, #20]
 8004046:	f083 0308 	eor.w	r3, r3, #8
 800404a:	6163      	str	r3, [r4, #20]
    chThdSleepMilliseconds(100);
 800404c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004050:	f7ff fa86 	bl	8003560 <chThdSleep>
 8004054:	e7f6      	b.n	8004044 <Host_thread.lto_priv.48+0x104>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004056:	b672      	cpsid	i
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8004058:	4b0a      	ldr	r3, [pc, #40]	; (8004084 <Host_thread.lto_priv.48+0x144>)
 800405a:	62d3      	str	r3, [r2, #44]	; 0x2c
 800405c:	e7fe      	b.n	800405c <Host_thread.lto_priv.48+0x11c>
 800405e:	bf00      	nop
 8004060:	200021c4 	.word	0x200021c4
 8004064:	20002740 	.word	0x20002740
 8004068:	08006990 	.word	0x08006990
 800406c:	40490fdb 	.word	0x40490fdb
 8004070:	459c4000 	.word	0x459c4000
 8004074:	d1b71759 	.word	0xd1b71759
 8004078:	aabbccdd 	.word	0xaabbccdd
 800407c:	08006998 	.word	0x08006998
 8004080:	40020400 	.word	0x40020400
 8004084:	08006a00 	.word	0x08006a00
	...

08004090 <cmd_data>:

  chprintf(chp,"Shell Working");
}

void cmd_data(BaseSequentialStream * chp, int argc, char *argv[])
{
 8004090:	b510      	push	{r4, lr}
 8004092:	b082      	sub	sp, #8
  uint8_t sec = 10;

  if(argc)
 8004094:	b1d9      	cbz	r1, 80040ce <cmd_data+0x3e>
  {
    char *toNumber = argv[0];
 8004096:	6811      	ldr	r1, [r2, #0]
    uint32_t finalNum=0;
    while(*toNumber>='0' && *toNumber<='9')
 8004098:	780b      	ldrb	r3, [r1, #0]
 800409a:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800409e:	2a09      	cmp	r2, #9
 80040a0:	d815      	bhi.n	80040ce <cmd_data+0x3e>
 80040a2:	2200      	movs	r2, #0
      finalNum=finalNum*10+*(toNumber++)-'0';
 80040a4:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80040a8:	eb03 0242 	add.w	r2, r3, r2, lsl #1

  if(argc)
  {
    char *toNumber = argv[0];
    uint32_t finalNum=0;
    while(*toNumber>='0' && *toNumber<='9')
 80040ac:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 80040b0:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
 80040b4:	2c09      	cmp	r4, #9
      finalNum=finalNum*10+*(toNumber++)-'0';
 80040b6:	f1a2 0230 	sub.w	r2, r2, #48	; 0x30

  if(argc)
  {
    char *toNumber = argv[0];
    uint32_t finalNum=0;
    while(*toNumber>='0' && *toNumber<='9')
 80040ba:	d9f3      	bls.n	80040a4 <cmd_data+0x14>
      finalNum=finalNum*10+*(toNumber++)-'0';

    if(finalNum == 0)
 80040bc:	b13a      	cbz	r2, 80040ce <cmd_data+0x3e>
 80040be:	2a3c      	cmp	r2, #60	; 0x3c
 80040c0:	bf28      	it	cs
 80040c2:	223c      	movcs	r2, #60	; 0x3c
 80040c4:	f242 7410 	movw	r4, #10000	; 0x2710
 80040c8:	fb04 f402 	mul.w	r4, r4, r2
 80040cc:	e001      	b.n	80040d2 <cmd_data+0x42>

void cmd_data(BaseSequentialStream * chp, int argc, char *argv[])
{
  uint8_t sec = 10;

  if(argc)
 80040ce:	4c09      	ldr	r4, [pc, #36]	; (80040f4 <cmd_data+0x64>)
 80040d0:	220a      	movs	r2, #10
      finalNum = 10;

    sec = (finalNum < 60 ? finalNum : 60);
  }

  chprintf(chp,"Data transmission start in %d seconds...", sec);
 80040d2:	4909      	ldr	r1, [pc, #36]	; (80040f8 <cmd_data+0x68>)
 80040d4:	f7fe f934 	bl	8002340 <chprintf>
  chThdSleepSeconds(sec);
 80040d8:	4620      	mov	r0, r4
 80040da:	f7ff fa41 	bl	8003560 <chThdSleep>

  chThdCreateStatic(Host_thread_wa, sizeof(Host_thread_wa),
 80040de:	2300      	movs	r3, #0
 80040e0:	9300      	str	r3, [sp, #0]
 80040e2:	f44f 715c 	mov.w	r1, #880	; 0x370
 80040e6:	4b05      	ldr	r3, [pc, #20]	; (80040fc <cmd_data+0x6c>)
 80040e8:	4805      	ldr	r0, [pc, #20]	; (8004100 <cmd_data+0x70>)
 80040ea:	2240      	movs	r2, #64	; 0x40
 80040ec:	f7ff fa68 	bl	80035c0 <chThdCreateStatic>
  NORMALPRIO,
                    Host_thread, NULL);
}
 80040f0:	b002      	add	sp, #8
 80040f2:	bd10      	pop	{r4, pc}
 80040f4:	000186a0 	.word	0x000186a0
 80040f8:	08006b40 	.word	0x08006b40
 80040fc:	08003f41 	.word	0x08003f41
 8004100:	200023d0 	.word	0x200023d0
	...

08004110 <cmd_test>:
static THD_WORKING_AREA(Shell_thread_wa, 1024);
void cmd_test(BaseSequentialStream * chp, int argc, char *argv[])
{
  (void) argc,argv;

  chprintf(chp,"Shell Working");
 8004110:	4901      	ldr	r1, [pc, #4]	; (8004118 <cmd_test+0x8>)
 8004112:	f7fe b915 	b.w	8002340 <chprintf>
 8004116:	bf00      	nop
 8004118:	08006b6c 	.word	0x08006b6c
 800411c:	00000000 	.word	0x00000000

08004120 <chThdDequeueAllI.constprop.39>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8004120:	b538      	push	{r3, r4, r5, lr}
 8004122:	4603      	mov	r3, r0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8004124:	6800      	ldr	r0, [r0, #0]

  while (queue_notempty(tqp)) {
 8004126:	4283      	cmp	r3, r0
 8004128:	d020      	beq.n	800416c <chThdDequeueAllI.constprop.39+0x4c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800412a:	6802      	ldr	r2, [r0, #0]
 800412c:	601a      	str	r2, [r3, #0]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 800412e:	f890 1020 	ldrb.w	r1, [r0, #32]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8004132:	6053      	str	r3, [r2, #4]
 8004134:	2904      	cmp	r1, #4
 8004136:	d004      	beq.n	8004142 <chThdDequeueAllI.constprop.39+0x22>
 8004138:	b672      	cpsid	i
 800413a:	4b0d      	ldr	r3, [pc, #52]	; (8004170 <chThdDequeueAllI.constprop.39+0x50>)
 800413c:	4a0d      	ldr	r2, [pc, #52]	; (8004174 <chThdDequeueAllI.constprop.39+0x54>)
 800413e:	62da      	str	r2, [r3, #44]	; 0x2c
 8004140:	e7fe      	b.n	8004140 <chThdDequeueAllI.constprop.39+0x20>
 8004142:	461c      	mov	r4, r3

  tp->p_u.rdymsg = msg;
 8004144:	2500      	movs	r5, #0
 8004146:	6245      	str	r5, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8004148:	f7ff f8da 	bl	8003300 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800414c:	6820      	ldr	r0, [r4, #0]
 800414e:	4284      	cmp	r4, r0
 8004150:	d00c      	beq.n	800416c <chThdDequeueAllI.constprop.39+0x4c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8004152:	6803      	ldr	r3, [r0, #0]
 8004154:	6023      	str	r3, [r4, #0]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 8004156:	f890 2020 	ldrb.w	r2, [r0, #32]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800415a:	605c      	str	r4, [r3, #4]
 800415c:	2a04      	cmp	r2, #4
 800415e:	d1eb      	bne.n	8004138 <chThdDequeueAllI.constprop.39+0x18>

  tp->p_u.rdymsg = msg;
 8004160:	6245      	str	r5, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8004162:	f7ff f8cd 	bl	8003300 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8004166:	6820      	ldr	r0, [r4, #0]
 8004168:	4284      	cmp	r4, r0
 800416a:	d1f2      	bne.n	8004152 <chThdDequeueAllI.constprop.39+0x32>
 800416c:	bd38      	pop	{r3, r4, r5, pc}
 800416e:	bf00      	nop
 8004170:	20002740 	.word	0x20002740
 8004174:	08006b80 	.word	0x08006b80
	...

08004180 <dmaStreamAllocate.constprop.22>:
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {

  osalDbgCheck(dmastp != NULL);
 8004180:	2800      	cmp	r0, #0
 8004182:	d053      	beq.n	800422c <dmaStreamAllocate.constprop.22+0xac>
 * @retval false        no error, stream taken.
 * @retval true         error, stream already taken.
 *
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
 8004184:	b5f0      	push	{r4, r5, r6, r7, lr}
                       void *param) {

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8004186:	4e2c      	ldr	r6, [pc, #176]	; (8004238 <dmaStreamAllocate.constprop.22+0xb8>)
 8004188:	7a45      	ldrb	r5, [r0, #9]
 800418a:	6832      	ldr	r2, [r6, #0]
 800418c:	2301      	movs	r3, #1
 800418e:	fa03 f705 	lsl.w	r7, r3, r5
 8004192:	4217      	tst	r7, r2
 8004194:	d146      	bne.n	8004224 <dmaStreamAllocate.constprop.22+0xa4>
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8004196:	4c29      	ldr	r4, [pc, #164]	; (800423c <dmaStreamAllocate.constprop.22+0xbc>)
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8004198:	f8df e0b0 	ldr.w	lr, [pc, #176]	; 800424c <dmaStreamAllocate.constprop.22+0xcc>
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 800419c:	f844 1035 	str.w	r1, [r4, r5, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1U << dmastp->selfindex);
 80041a0:	ea47 0302 	orr.w	r3, r7, r2
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 80041a4:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
  dma_streams_mask |= (1U << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 80041a8:	f013 0fff 	tst.w	r3, #255	; 0xff
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1U << dmastp->selfindex);
 80041ac:	6033      	str	r3, [r6, #0]
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 80041ae:	f8c4 e004 	str.w	lr, [r4, #4]
  dma_streams_mask |= (1U << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 80041b2:	d004      	beq.n	80041be <dmaStreamAllocate.constprop.22+0x3e>
    rccEnableDMA1(false);
 80041b4:	4c22      	ldr	r4, [pc, #136]	; (8004240 <dmaStreamAllocate.constprop.22+0xc0>)
 80041b6:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80041b8:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80041bc:	6322      	str	r2, [r4, #48]	; 0x30
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
 80041be:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
 80041c2:	d129      	bne.n	8004218 <dmaStreamAllocate.constprop.22+0x98>
    rccEnableDMA2(false);
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80041c4:	6802      	ldr	r2, [r0, #0]
 80041c6:	6813      	ldr	r3, [r2, #0]
 80041c8:	f023 031f 	bic.w	r3, r3, #31
 80041cc:	6013      	str	r3, [r2, #0]
 80041ce:	6813      	ldr	r3, [r2, #0]
 80041d0:	f013 0301 	ands.w	r3, r3, #1
 80041d4:	d1fb      	bne.n	80041ce <dmaStreamAllocate.constprop.22+0x4e>
 80041d6:	7a05      	ldrb	r5, [r0, #8]
 80041d8:	6846      	ldr	r6, [r0, #4]
 80041da:	243d      	movs	r4, #61	; 0x3d
 80041dc:	40ac      	lsls	r4, r5
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 80041de:	2521      	movs	r5, #33	; 0x21
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
    rccEnableDMA2(false);
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80041e0:	6034      	str	r4, [r6, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 80041e2:	6013      	str	r3, [r2, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 80041e4:	6155      	str	r5, [r2, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
 80041e6:	b1f9      	cbz	r1, 8004228 <dmaStreamAllocate.constprop.22+0xa8>
    nvicEnableVector(dmastp->vector, priority);
 80041e8:	7a81      	ldrb	r1, [r0, #10]
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80041ea:	094a      	lsrs	r2, r1, #5
 80041ec:	0092      	lsls	r2, r2, #2

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80041ee:	f101 4460 	add.w	r4, r1, #3758096384	; 0xe0000000
 80041f2:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 80041f6:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 80041fa:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80041fe:	2001      	movs	r0, #1
 8004200:	f001 011f 	and.w	r1, r1, #31
 8004204:	fa00 f101 	lsl.w	r1, r0, r1

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8004208:	25a0      	movs	r5, #160	; 0xa0
 800420a:	f884 5300 	strb.w	r5, [r4, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800420e:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8004212:	6011      	str	r1, [r2, #0]
 8004214:	4618      	mov	r0, r3
 8004216:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
    rccEnableDMA1(false);
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
    rccEnableDMA2(false);
 8004218:	4a09      	ldr	r2, [pc, #36]	; (8004240 <dmaStreamAllocate.constprop.22+0xc0>)
 800421a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800421c:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8004220:	6313      	str	r3, [r2, #48]	; 0x30
 8004222:	e7cf      	b.n	80041c4 <dmaStreamAllocate.constprop.22+0x44>

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;
 8004224:	4618      	mov	r0, r3
 8004226:	bdf0      	pop	{r4, r5, r6, r7, pc}
  dmaStreamDisable(dmastp);
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
 8004228:	4608      	mov	r0, r1
    nvicEnableVector(dmastp->vector, priority);
  }

  return false;
}
 800422a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800422c:	b672      	cpsid	i
 800422e:	4b05      	ldr	r3, [pc, #20]	; (8004244 <dmaStreamAllocate.constprop.22+0xc4>)
 8004230:	4a05      	ldr	r2, [pc, #20]	; (8004248 <dmaStreamAllocate.constprop.22+0xc8>)
 8004232:	62da      	str	r2, [r3, #44]	; 0x2c
 8004234:	e7fe      	b.n	8004234 <dmaStreamAllocate.constprop.22+0xb4>
 8004236:	bf00      	nop
 8004238:	20003148 	.word	0x20003148
 800423c:	200030c8 	.word	0x200030c8
 8004240:	40023800 	.word	0x40023800
 8004244:	20002740 	.word	0x20002740
 8004248:	08006af0 	.word	0x08006af0
 800424c:	20002194 	.word	0x20002194

08004250 <_strtok.constprop.9>:
/**
 * @brief   Shell termination event source.
 */
event_source_t shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
 8004250:	b538      	push	{r3, r4, r5, lr}
 8004252:	460d      	mov	r5, r1
  char *token;
  if (str)
 8004254:	4604      	mov	r4, r0
 8004256:	b190      	cbz	r0, 800427e <_strtok.constprop.9+0x2e>
    *saveptr = str;
 8004258:	6028      	str	r0, [r5, #0]
  token = *saveptr;

  if (!token)
    return NULL;

  token += strspn(token, delim);
 800425a:	4620      	mov	r0, r4
 800425c:	490b      	ldr	r1, [pc, #44]	; (800428c <_strtok.constprop.9+0x3c>)
 800425e:	f000 facf 	bl	8004800 <strspn>
 8004262:	4404      	add	r4, r0
  *saveptr = strpbrk(token, delim);
 8004264:	4620      	mov	r0, r4
 8004266:	4909      	ldr	r1, [pc, #36]	; (800428c <_strtok.constprop.9+0x3c>)
 8004268:	f000 faa2 	bl	80047b0 <strpbrk>
  if (*saveptr)
 800426c:	b160      	cbz	r0, 8004288 <_strtok.constprop.9+0x38>
    *(*saveptr)++ = '\0';
 800426e:	1c42      	adds	r2, r0, #1
 8004270:	2300      	movs	r3, #0
 8004272:	602a      	str	r2, [r5, #0]
 8004274:	7003      	strb	r3, [r0, #0]

  return *token ? token : NULL;
 8004276:	7823      	ldrb	r3, [r4, #0]
 8004278:	b123      	cbz	r3, 8004284 <_strtok.constprop.9+0x34>
 800427a:	4620      	mov	r0, r4
}
 800427c:	bd38      	pop	{r3, r4, r5, pc}

static char *_strtok(char *str, const char *delim, char **saveptr) {
  char *token;
  if (str)
    *saveptr = str;
  token = *saveptr;
 800427e:	680c      	ldr	r4, [r1, #0]

  if (!token)
 8004280:	2c00      	cmp	r4, #0
 8004282:	d1ea      	bne.n	800425a <_strtok.constprop.9+0xa>
    return NULL;
 8004284:	2000      	movs	r0, #0
 8004286:	bd38      	pop	{r3, r4, r5, pc}

  token += strspn(token, delim);
  *saveptr = strpbrk(token, delim);
 8004288:	6028      	str	r0, [r5, #0]
 800428a:	e7f4      	b.n	8004276 <_strtok.constprop.9+0x26>
 800428c:	08006b7c 	.word	0x08006b7c

08004290 <long_to_string_with_divisor.constprop.8>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8004290:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8004292:	f100 070b 	add.w	r7, r0, #11
 8004296:	463c      	mov	r4, r7
 8004298:	460d      	mov	r5, r1
  do {
    i = (int)(l % radix);
 800429a:	fbb1 f6f2 	udiv	r6, r1, r2
 800429e:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 80042a2:	f101 0330 	add.w	r3, r1, #48	; 0x30
    if (i > '9')
 80042a6:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 80042a8:	bfc8      	it	gt
 80042aa:	f101 0337 	addgt.w	r3, r1, #55	; 0x37
    *--q = i;
 80042ae:	b2db      	uxtb	r3, r3
 80042b0:	f804 3d01 	strb.w	r3, [r4, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
 80042b4:	fbb5 f5f2 	udiv	r5, r5, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 80042b8:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
 80042ba:	2d00      	cmp	r5, #0
 80042bc:	d1ed      	bne.n	800429a <long_to_string_with_divisor.constprop.8+0xa>

  i = (int)(p + MAX_FILLER - q);
 80042be:	1b3a      	subs	r2, r7, r4
 80042c0:	4402      	add	r2, r0
 80042c2:	e001      	b.n	80042c8 <long_to_string_with_divisor.constprop.8+0x38>
 80042c4:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  do
    *p++ = *q++;
 80042c8:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 80042cc:	4290      	cmp	r0, r2
 80042ce:	d1f9      	bne.n	80042c4 <long_to_string_with_divisor.constprop.8+0x34>

  return p;
}
 80042d0:	bcf0      	pop	{r4, r5, r6, r7}
 80042d2:	4770      	bx	lr
	...

080042e0 <tft_printf.constprop.3>:
  * @param  x: starting x-coordinate
  * @param  y: starting y-coordinate
  * @param  pstr: string to be printed
  * @retval None
  */
void tft_printf(uint8_t x, uint8_t y, const char * pstr, ...)
 80042e0:	b40c      	push	{r2, r3}
 80042e2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80042e6:	b0c6      	sub	sp, #280	; 0x118
 80042e8:	aa4e      	add	r2, sp, #312	; 0x138
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
  msp->buffer = buffer;
 80042ea:	ac06      	add	r4, sp, #24
 80042ec:	f852 3b04 	ldr.w	r3, [r2], #4
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
 80042f0:	4f36      	ldr	r7, [pc, #216]	; (80043cc <tft_printf.constprop.3+0xec>)
	va_list arglist;

  MemoryStream ms;
  msObjectInit(&ms, buf, 255, 0);

  va_start(arglist, pstr);
 80042f2:	9200      	str	r2, [sp, #0]
  msp->buffer = buffer;
  msp->size   = size;
  msp->eos    = eos;
 80042f4:	2600      	movs	r6, #0
  * @param  x: starting x-coordinate
  * @param  y: starting y-coordinate
  * @param  pstr: string to be printed
  * @retval None
  */
void tft_printf(uint8_t x, uint8_t y, const char * pstr, ...)
 80042f6:	460d      	mov	r5, r1

  MemoryStream ms;
  msObjectInit(&ms, buf, 255, 0);

  va_start(arglist, pstr);
  chvprintf((BaseSequentialStream *)(void *)&ms, pstr, arglist);
 80042f8:	a801      	add	r0, sp, #4
 80042fa:	4619      	mov	r1, r3
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
  msp->buffer = buffer;
  msp->size   = size;
 80042fc:	23ff      	movs	r3, #255	; 0xff
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
 80042fe:	9701      	str	r7, [sp, #4]
  msp->buffer = buffer;
  msp->size   = size;
 8004300:	9303      	str	r3, [sp, #12]
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
  msp->buffer = buffer;
 8004302:	9402      	str	r4, [sp, #8]
  msp->size   = size;
  msp->eos    = eos;
 8004304:	9604      	str	r6, [sp, #16]
  msp->offset = 0;
 8004306:	9605      	str	r6, [sp, #20]
 8004308:	f7fd fe92 	bl	8002030 <chvprintf>
  va_end(arglist);

  if (ms.eos < 255)
 800430c:	9b04      	ldr	r3, [sp, #16]
			}
      if (*fp == '\\' && (*(fp+1) == '[' || *(fp+1) == ']')) {
        fp++;
      }
			text[x][y] = *fp++;
			text_color[x][y] = is_special ? curr_text_color_sp : curr_text_color;
 800430e:	4930      	ldr	r1, [pc, #192]	; (80043d0 <tft_printf.constprop.3+0xf0>)
 8004310:	4a30      	ldr	r2, [pc, #192]	; (80043d4 <tft_printf.constprop.3+0xf4>)
				continue;
			}
      if (*fp == '\\' && (*(fp+1) == '[' || *(fp+1) == ']')) {
        fp++;
      }
			text[x][y] = *fp++;
 8004312:	f8df e0d0 	ldr.w	lr, [pc, #208]	; 80043e4 <tft_printf.constprop.3+0x104>
			text_color[x][y] = is_special ? curr_text_color_sp : curr_text_color;
 8004316:	4f30      	ldr	r7, [pc, #192]	; (80043d8 <tft_printf.constprop.3+0xf8>)
 8004318:	f8b1 9000 	ldrh.w	r9, [r1]
 800431c:	f8b2 8000 	ldrh.w	r8, [r2]

  va_start(arglist, pstr);
  chvprintf((BaseSequentialStream *)(void *)&ms, pstr, arglist);
  va_end(arglist);

  if (ms.eos < 255)
 8004320:	2bfe      	cmp	r3, #254	; 0xfe
      buf[ms.eos] = 0;
 8004322:	bf98      	it	ls
 8004324:	54e6      	strbls	r6, [r4, r3]
      if (*fp == '\\' && (*(fp+1) == '[' || *(fp+1) == ']')) {
        fp++;
      }
			text[x][y] = *fp++;
			text_color[x][y] = is_special ? curr_text_color_sp : curr_text_color;
			bg_color[x][y] = curr_bg_color;
 8004326:	4b2d      	ldr	r3, [pc, #180]	; (80043dc <tft_printf.constprop.3+0xfc>)
 8004328:	4e2d      	ldr	r6, [pc, #180]	; (80043e0 <tft_printf.constprop.3+0x100>)
 800432a:	f8b3 c000 	ldrh.w	ip, [r3]
 800432e:	4622      	mov	r2, r4
 8004330:	2103      	movs	r1, #3
 8004332:	2400      	movs	r4, #0
  if (ms.eos < 255)
      buf[ms.eos] = 0;

  fp = buf;

	while (*fp)	{
 8004334:	7813      	ldrb	r3, [r2, #0]
 8004336:	b34b      	cbz	r3, 800438c <tft_printf.constprop.3+0xac>
		if (*fp == '[' && *(fp - 1) != '\\') {
 8004338:	2b5b      	cmp	r3, #91	; 0x5b
 800433a:	d02e      	beq.n	800439a <tft_printf.constprop.3+0xba>
			is_special = 1;
			fp++;
		} else if (*fp == ']' && *(fp - 1) != '\\') {
 800433c:	2b5d      	cmp	r3, #93	; 0x5d
 800433e:	d033      	beq.n	80043a8 <tft_printf.constprop.3+0xc8>
			is_special = 0;
			fp++;
		} else if (*fp == '\r' || *fp == '\n') {
 8004340:	2b0d      	cmp	r3, #13
 8004342:	d028      	beq.n	8004396 <tft_printf.constprop.3+0xb6>
 8004344:	2b0a      	cmp	r3, #10
 8004346:	d026      	beq.n	8004396 <tft_printf.constprop.3+0xb6>
			fp++;
		} else {
			if (x > CHAR_MAX_X || y > CHAR_MAX_Y) {
 8004348:	2914      	cmp	r1, #20
 800434a:	d824      	bhi.n	8004396 <tft_printf.constprop.3+0xb6>
 800434c:	2d0a      	cmp	r5, #10
 800434e:	d822      	bhi.n	8004396 <tft_printf.constprop.3+0xb6>
				fp++;
				continue;
			}
      if (*fp == '\\' && (*(fp+1) == '[' || *(fp+1) == ']')) {
 8004350:	2b5c      	cmp	r3, #92	; 0x5c
 8004352:	d034      	beq.n	80043be <tft_printf.constprop.3+0xde>
        fp++;
      }
			text[x][y] = *fp++;
 8004354:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 8004358:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 800435c:	f892 a000 	ldrb.w	sl, [r2]
			text_color[x][y] = is_special ? curr_text_color_sp : curr_text_color;
			bg_color[x][y] = curr_bg_color;
 8004360:	f826 c013 	strh.w	ip, [r6, r3, lsl #1]
			}
      if (*fp == '\\' && (*(fp+1) == '[' || *(fp+1) == ']')) {
        fp++;
      }
			text[x][y] = *fp++;
			text_color[x][y] = is_special ? curr_text_color_sp : curr_text_color;
 8004364:	2c00      	cmp	r4, #0
 8004366:	bf14      	ite	ne
 8004368:	4648      	movne	r0, r9
 800436a:	4640      	moveq	r0, r8
			bg_color[x][y] = curr_bg_color;
			if (x >= CHAR_MAX_X) {
 800436c:	2914      	cmp	r1, #20
				continue;
			}
      if (*fp == '\\' && (*(fp+1) == '[' || *(fp+1) == ']')) {
        fp++;
      }
			text[x][y] = *fp++;
 800436e:	f80e a003 	strb.w	sl, [lr, r3]
 8004372:	f102 0201 	add.w	r2, r2, #1
			text_color[x][y] = is_special ? curr_text_color_sp : curr_text_color;
 8004376:	f827 0013 	strh.w	r0, [r7, r3, lsl #1]
			bg_color[x][y] = curr_bg_color;
			if (x >= CHAR_MAX_X) {
 800437a:	d01c      	beq.n	80043b6 <tft_printf.constprop.3+0xd6>
				x = 0;
				y++;
			} else {
				x++;
 800437c:	3101      	adds	r1, #1
 800437e:	b2c9      	uxtb	r1, r1
  if (ms.eos < 255)
      buf[ms.eos] = 0;

  fp = buf;

	while (*fp)	{
 8004380:	7813      	ldrb	r3, [r2, #0]
				x = 0;
				y++;
			} else {
				x++;
			}
			if (y >= CHAR_MAX_Y)
 8004382:	2d09      	cmp	r5, #9
				y = 0;
 8004384:	bf88      	it	hi
 8004386:	2500      	movhi	r5, #0
  if (ms.eos < 255)
      buf[ms.eos] = 0;

  fp = buf;

	while (*fp)	{
 8004388:	2b00      	cmp	r3, #0
 800438a:	d1d5      	bne.n	8004338 <tft_printf.constprop.3+0x58>
			}
			if (y >= CHAR_MAX_Y)
				y = 0;
		}
	}
}
 800438c:	b046      	add	sp, #280	; 0x118
 800438e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004392:	b002      	add	sp, #8
 8004394:	4770      	bx	lr
			fp++;
		} else if (*fp == '\r' || *fp == '\n') {
			fp++;
		} else {
			if (x > CHAR_MAX_X || y > CHAR_MAX_Y) {
				fp++;
 8004396:	3201      	adds	r2, #1
 8004398:	e7cc      	b.n	8004334 <tft_printf.constprop.3+0x54>
      buf[ms.eos] = 0;

  fp = buf;

	while (*fp)	{
		if (*fp == '[' && *(fp - 1) != '\\') {
 800439a:	f812 0c01 	ldrb.w	r0, [r2, #-1]
 800439e:	285c      	cmp	r0, #92	; 0x5c
 80043a0:	d0d2      	beq.n	8004348 <tft_printf.constprop.3+0x68>
			is_special = 1;
			fp++;
 80043a2:	3201      	adds	r2, #1

  fp = buf;

	while (*fp)	{
		if (*fp == '[' && *(fp - 1) != '\\') {
			is_special = 1;
 80043a4:	2401      	movs	r4, #1
 80043a6:	e7c5      	b.n	8004334 <tft_printf.constprop.3+0x54>
			fp++;
		} else if (*fp == ']' && *(fp - 1) != '\\') {
 80043a8:	f812 0c01 	ldrb.w	r0, [r2, #-1]
 80043ac:	285c      	cmp	r0, #92	; 0x5c
 80043ae:	d0cb      	beq.n	8004348 <tft_printf.constprop.3+0x68>
			is_special = 0;
			fp++;
 80043b0:	3201      	adds	r2, #1
	while (*fp)	{
		if (*fp == '[' && *(fp - 1) != '\\') {
			is_special = 1;
			fp++;
		} else if (*fp == ']' && *(fp - 1) != '\\') {
			is_special = 0;
 80043b2:	2400      	movs	r4, #0
 80043b4:	e7be      	b.n	8004334 <tft_printf.constprop.3+0x54>
			text[x][y] = *fp++;
			text_color[x][y] = is_special ? curr_text_color_sp : curr_text_color;
			bg_color[x][y] = curr_bg_color;
			if (x >= CHAR_MAX_X) {
				x = 0;
				y++;
 80043b6:	3501      	adds	r5, #1
 80043b8:	b2ed      	uxtb	r5, r5
      }
			text[x][y] = *fp++;
			text_color[x][y] = is_special ? curr_text_color_sp : curr_text_color;
			bg_color[x][y] = curr_bg_color;
			if (x >= CHAR_MAX_X) {
				x = 0;
 80043ba:	2100      	movs	r1, #0
 80043bc:	e7e0      	b.n	8004380 <tft_printf.constprop.3+0xa0>
		} else {
			if (x > CHAR_MAX_X || y > CHAR_MAX_Y) {
				fp++;
				continue;
			}
      if (*fp == '\\' && (*(fp+1) == '[' || *(fp+1) == ']')) {
 80043be:	7853      	ldrb	r3, [r2, #1]
 80043c0:	2b5b      	cmp	r3, #91	; 0x5b
 80043c2:	d001      	beq.n	80043c8 <tft_printf.constprop.3+0xe8>
 80043c4:	2b5d      	cmp	r3, #93	; 0x5d
 80043c6:	d1c5      	bne.n	8004354 <tft_printf.constprop.3+0x74>
        fp++;
 80043c8:	3201      	adds	r2, #1
 80043ca:	e7c3      	b.n	8004354 <tft_printf.constprop.3+0x74>
 80043cc:	08006b10 	.word	0x08006b10
 80043d0:	2000314c 	.word	0x2000314c
 80043d4:	20002f32 	.word	0x20002f32
 80043d8:	20002f38 	.word	0x20002f38
 80043dc:	20002f30 	.word	0x20002f30
 80043e0:	20002004 	.word	0x20002004
 80043e4:	2000223c 	.word	0x2000223c
	...

080043f0 <tft_char_is_changed>:
    tft_write_data(color >> 8);
    tft_write_data(color);
}

uint8_t tft_char_is_changed(uint8_t x, uint8_t y)
{
 80043f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t re = (text_prev[x][y] != text[x][y] || text_color_prev[x][y] != text_color[x][y] || bg_color_prev[x][y] != bg_color[x][y]);
 80043f4:	0086      	lsls	r6, r0, #2
 80043f6:	1833      	adds	r3, r6, r0
 80043f8:	eb01 0343 	add.w	r3, r1, r3, lsl #1
    tft_write_data(color >> 8);
    tft_write_data(color);
}

uint8_t tft_char_is_changed(uint8_t x, uint8_t y)
{
 80043fc:	4602      	mov	r2, r0
	uint8_t re = (text_prev[x][y] != text[x][y] || text_color_prev[x][y] != text_color[x][y] || bg_color_prev[x][y] != bg_color[x][y]);
 80043fe:	4c18      	ldr	r4, [pc, #96]	; (8004460 <tft_char_is_changed+0x70>)
 8004400:	4818      	ldr	r0, [pc, #96]	; (8004464 <tft_char_is_changed+0x74>)
 8004402:	5cc5      	ldrb	r5, [r0, r3]
 8004404:	5ce0      	ldrb	r0, [r4, r3]
 8004406:	42a8      	cmp	r0, r5
 8004408:	d013      	beq.n	8004432 <tft_char_is_changed+0x42>
 800440a:	4f17      	ldr	r7, [pc, #92]	; (8004468 <tft_char_is_changed+0x78>)
 800440c:	4817      	ldr	r0, [pc, #92]	; (800446c <tft_char_is_changed+0x7c>)
 800440e:	f837 e013 	ldrh.w	lr, [r7, r3, lsl #1]
 8004412:	f8df c060 	ldr.w	ip, [pc, #96]	; 8004474 <tft_char_is_changed+0x84>
 8004416:	4f16      	ldr	r7, [pc, #88]	; (8004470 <tft_char_is_changed+0x80>)
 8004418:	f830 8013 	ldrh.w	r8, [r0, r3, lsl #1]
 800441c:	2001      	movs	r0, #1
	text_prev[x][y] = text[x][y];
 800441e:	4432      	add	r2, r6
 8004420:	eb01 0142 	add.w	r1, r1, r2, lsl #1
 8004424:	5465      	strb	r5, [r4, r1]
	text_color_prev[x][y] = text_color[x][y];
 8004426:	f827 e011 	strh.w	lr, [r7, r1, lsl #1]
	bg_color_prev[x][y] = bg_color[x][y];
 800442a:	f82c 8011 	strh.w	r8, [ip, r1, lsl #1]
	return re;
}
 800442e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    tft_write_data(color);
}

uint8_t tft_char_is_changed(uint8_t x, uint8_t y)
{
	uint8_t re = (text_prev[x][y] != text[x][y] || text_color_prev[x][y] != text_color[x][y] || bg_color_prev[x][y] != bg_color[x][y]);
 8004432:	4f0f      	ldr	r7, [pc, #60]	; (8004470 <tft_char_is_changed+0x80>)
 8004434:	f8df e030 	ldr.w	lr, [pc, #48]	; 8004468 <tft_char_is_changed+0x78>
 8004438:	f837 0013 	ldrh.w	r0, [r7, r3, lsl #1]
 800443c:	f83e e013 	ldrh.w	lr, [lr, r3, lsl #1]
 8004440:	f8df c030 	ldr.w	ip, [pc, #48]	; 8004474 <tft_char_is_changed+0x84>
 8004444:	4570      	cmp	r0, lr
 8004446:	4809      	ldr	r0, [pc, #36]	; (800446c <tft_char_is_changed+0x7c>)
 8004448:	f830 8013 	ldrh.w	r8, [r0, r3, lsl #1]
 800444c:	d001      	beq.n	8004452 <tft_char_is_changed+0x62>
 800444e:	2001      	movs	r0, #1
 8004450:	e7e5      	b.n	800441e <tft_char_is_changed+0x2e>
 8004452:	f83c 0013 	ldrh.w	r0, [ip, r3, lsl #1]
 8004456:	ebb0 0008 	subs.w	r0, r0, r8
 800445a:	bf18      	it	ne
 800445c:	2001      	movne	r0, #1
 800445e:	e7de      	b.n	800441e <tft_char_is_changed+0x2e>
 8004460:	20002304 	.word	0x20002304
 8004464:	2000223c 	.word	0x2000223c
 8004468:	20002f38 	.word	0x20002f38
 800446c:	20002004 	.word	0x20002004
 8004470:	20002da0 	.word	0x20002da0
 8004474:	20003150 	.word	0x20003150
	...

08004480 <sdStart.constprop.25>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8004480:	b538      	push	{r3, r4, r5, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8004482:	2320      	movs	r3, #32
 8004484:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 8004488:	f7fe fdca 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800448c:	f7ff f848 	bl	8003520 <_dbg_check_lock>

  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 8004490:	4a25      	ldr	r2, [pc, #148]	; (8004528 <sdStart.constprop.25+0xa8>)
 8004492:	7a13      	ldrb	r3, [r2, #8]
 8004494:	1e59      	subs	r1, r3, #1
 8004496:	2901      	cmp	r1, #1
 8004498:	d904      	bls.n	80044a4 <sdStart.constprop.25+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800449a:	b672      	cpsid	i
 800449c:	4b23      	ldr	r3, [pc, #140]	; (800452c <sdStart.constprop.25+0xac>)
 800449e:	4a24      	ldr	r2, [pc, #144]	; (8004530 <sdStart.constprop.25+0xb0>)
 80044a0:	62da      	str	r2, [r3, #44]	; 0x2c
 80044a2:	e7fe      	b.n	80044a2 <sdStart.constprop.25+0x22>
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 80044a4:	2b01      	cmp	r3, #1
 80044a6:	d02d      	beq.n	8004504 <sdStart.constprop.25+0x84>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 80044a8:	6f53      	ldr	r3, [r2, #116]	; 0x74

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 80044aa:	4922      	ldr	r1, [pc, #136]	; (8004534 <sdStart.constprop.25+0xb4>)
 80044ac:	428b      	cmp	r3, r1
 80044ae:	d025      	beq.n	80044fc <sdStart.constprop.25+0x7c>
 80044b0:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 80044b4:	428b      	cmp	r3, r1
 80044b6:	d021      	beq.n	80044fc <sdStart.constprop.25+0x7c>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;
 80044b8:	f44f 71b6 	mov.w	r1, #364	; 0x16c
 80044bc:	6099      	str	r1, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80044be:	f244 0140 	movw	r1, #16448	; 0x4040
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 80044c2:	2000      	movs	r0, #0
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80044c4:	2501      	movs	r5, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80044c6:	f242 142c 	movw	r4, #8492	; 0x212c
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80044ca:	6119      	str	r1, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80044cc:	615d      	str	r5, [r3, #20]
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 80044ce:	2102      	movs	r1, #2
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80044d0:	60dc      	str	r4, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 80044d2:	6018      	str	r0, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 80044d4:	6818      	ldr	r0, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 80044d6:	685b      	ldr	r3, [r3, #4]
 80044d8:	7211      	strb	r1, [r2, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80044da:	f7ff f811 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80044de:	f7fe fd87 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80044e2:	4b12      	ldr	r3, [pc, #72]	; (800452c <sdStart.constprop.25+0xac>)
 80044e4:	681a      	ldr	r2, [r3, #0]
 80044e6:	429a      	cmp	r2, r3
 80044e8:	d004      	beq.n	80044f4 <sdStart.constprop.25+0x74>
 80044ea:	6999      	ldr	r1, [r3, #24]
 80044ec:	6892      	ldr	r2, [r2, #8]
 80044ee:	6889      	ldr	r1, [r1, #8]
 80044f0:	4291      	cmp	r1, r2
 80044f2:	d315      	bcc.n	8004520 <sdStart.constprop.25+0xa0>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80044f4:	2300      	movs	r3, #0
 80044f6:	f383 8811 	msr	BASEPRI, r3
 80044fa:	bd38      	pop	{r3, r4, r5, pc}
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 80044fc:	f240 21d9 	movw	r1, #729	; 0x2d9
 8004500:	6099      	str	r1, [r3, #8]
 8004502:	e7dc      	b.n	80044be <sdStart.constprop.25+0x3e>
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
      rccEnableUSART3(FALSE);
 8004504:	4c0c      	ldr	r4, [pc, #48]	; (8004538 <sdStart.constprop.25+0xb8>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8004506:	4b0d      	ldr	r3, [pc, #52]	; (800453c <sdStart.constprop.25+0xbc>)
 8004508:	6c21      	ldr	r1, [r4, #64]	; 0x40
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800450a:	2080      	movs	r0, #128	; 0x80

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800450c:	25c0      	movs	r5, #192	; 0xc0
 800450e:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
 8004512:	6421      	str	r1, [r4, #64]	; 0x40
 8004514:	f883 5327 	strb.w	r5, [r3, #807]	; 0x327
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004518:	f8c3 0184 	str.w	r0, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800451c:	6058      	str	r0, [r3, #4]
 800451e:	e7c3      	b.n	80044a8 <sdStart.constprop.25+0x28>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004520:	b672      	cpsid	i
 8004522:	4a07      	ldr	r2, [pc, #28]	; (8004540 <sdStart.constprop.25+0xc0>)
 8004524:	62da      	str	r2, [r3, #44]	; 0x2c
 8004526:	e7fe      	b.n	8004526 <sdStart.constprop.25+0xa6>
 8004528:	200021c4 	.word	0x200021c4
 800452c:	20002740 	.word	0x20002740
 8004530:	08006b20 	.word	0x08006b20
 8004534:	40011000 	.word	0x40011000
 8004538:	40023800 	.word	0x40023800
 800453c:	e000e100 	.word	0xe000e100
 8004540:	08006bb0 	.word	0x08006bb0
	...

08004550 <spiSelect.constprop.18>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
 8004550:	b508      	push	{r3, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8004552:	2320      	movs	r3, #32
 8004554:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 8004558:	f7fe fd62 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800455c:	f7fe ffe0 	bl	8003520 <_dbg_check_lock>

  osalDbgCheck(spip != NULL);

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8004560:	4b12      	ldr	r3, [pc, #72]	; (80045ac <spiSelect.constprop.18+0x5c>)
 8004562:	781a      	ldrb	r2, [r3, #0]
 8004564:	2a02      	cmp	r2, #2
 8004566:	d004      	beq.n	8004572 <spiSelect.constprop.18+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004568:	b672      	cpsid	i
 800456a:	4b11      	ldr	r3, [pc, #68]	; (80045b0 <spiSelect.constprop.18+0x60>)
 800456c:	4a11      	ldr	r2, [pc, #68]	; (80045b4 <spiSelect.constprop.18+0x64>)
 800456e:	62da      	str	r2, [r3, #44]	; 0x2c
 8004570:	e7fe      	b.n	8004570 <spiSelect.constprop.18+0x20>
 *
 * @notapi
 */
void spi_lld_select(SPIDriver *spip) {

  palClearPad(spip->config->ssport, spip->config->sspad);
 8004572:	685b      	ldr	r3, [r3, #4]
 8004574:	8919      	ldrh	r1, [r3, #8]
 8004576:	685a      	ldr	r2, [r3, #4]
 8004578:	2301      	movs	r3, #1
 800457a:	408b      	lsls	r3, r1
 800457c:	b29b      	uxth	r3, r3
 800457e:	8353      	strh	r3, [r2, #26]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004580:	f7fe ffbe 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8004584:	f7fe fd34 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004588:	4b09      	ldr	r3, [pc, #36]	; (80045b0 <spiSelect.constprop.18+0x60>)
 800458a:	681a      	ldr	r2, [r3, #0]
 800458c:	429a      	cmp	r2, r3
 800458e:	d004      	beq.n	800459a <spiSelect.constprop.18+0x4a>
 8004590:	6999      	ldr	r1, [r3, #24]
 8004592:	6892      	ldr	r2, [r2, #8]
 8004594:	6889      	ldr	r1, [r1, #8]
 8004596:	4291      	cmp	r1, r2
 8004598:	d303      	bcc.n	80045a2 <spiSelect.constprop.18+0x52>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800459a:	2300      	movs	r3, #0
 800459c:	f383 8811 	msr	BASEPRI, r3
 80045a0:	bd08      	pop	{r3, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80045a2:	b672      	cpsid	i
 80045a4:	4a04      	ldr	r2, [pc, #16]	; (80045b8 <spiSelect.constprop.18+0x68>)
 80045a6:	62da      	str	r2, [r3, #44]	; 0x2c
 80045a8:	e7fe      	b.n	80045a8 <spiSelect.constprop.18+0x58>
 80045aa:	bf00      	nop
 80045ac:	20002194 	.word	0x20002194
 80045b0:	20002740 	.word	0x20002740
 80045b4:	08006ad0 	.word	0x08006ad0
 80045b8:	08006bc0 	.word	0x08006bc0
 80045bc:	00000000 	.word	0x00000000

080045c0 <spiUnselect.constprop.16>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
 80045c0:	b508      	push	{r3, lr}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80045c2:	2320      	movs	r3, #32
 80045c4:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 80045c8:	f7fe fd2a 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80045cc:	f7fe ffa8 	bl	8003520 <_dbg_check_lock>

  osalDbgCheck(spip != NULL);

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 80045d0:	4b12      	ldr	r3, [pc, #72]	; (800461c <spiUnselect.constprop.16+0x5c>)
 80045d2:	781a      	ldrb	r2, [r3, #0]
 80045d4:	2a02      	cmp	r2, #2
 80045d6:	d004      	beq.n	80045e2 <spiUnselect.constprop.16+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80045d8:	b672      	cpsid	i
 80045da:	4b11      	ldr	r3, [pc, #68]	; (8004620 <spiUnselect.constprop.16+0x60>)
 80045dc:	4a11      	ldr	r2, [pc, #68]	; (8004624 <spiUnselect.constprop.16+0x64>)
 80045de:	62da      	str	r2, [r3, #44]	; 0x2c
 80045e0:	e7fe      	b.n	80045e0 <spiUnselect.constprop.16+0x20>
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip) {

  palSetPad(spip->config->ssport, spip->config->sspad);
 80045e2:	685b      	ldr	r3, [r3, #4]
 80045e4:	8919      	ldrh	r1, [r3, #8]
 80045e6:	685a      	ldr	r2, [r3, #4]
 80045e8:	2301      	movs	r3, #1
 80045ea:	408b      	lsls	r3, r1
 80045ec:	b29b      	uxth	r3, r3
 80045ee:	8313      	strh	r3, [r2, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80045f0:	f7fe ff86 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80045f4:	f7fe fcfc 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80045f8:	4b09      	ldr	r3, [pc, #36]	; (8004620 <spiUnselect.constprop.16+0x60>)
 80045fa:	681a      	ldr	r2, [r3, #0]
 80045fc:	429a      	cmp	r2, r3
 80045fe:	d004      	beq.n	800460a <spiUnselect.constprop.16+0x4a>
 8004600:	6999      	ldr	r1, [r3, #24]
 8004602:	6892      	ldr	r2, [r2, #8]
 8004604:	6889      	ldr	r1, [r1, #8]
 8004606:	4291      	cmp	r1, r2
 8004608:	d303      	bcc.n	8004612 <spiUnselect.constprop.16+0x52>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800460a:	2300      	movs	r3, #0
 800460c:	f383 8811 	msr	BASEPRI, r3
 8004610:	bd08      	pop	{r3, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004612:	b672      	cpsid	i
 8004614:	4a04      	ldr	r2, [pc, #16]	; (8004628 <spiUnselect.constprop.16+0x68>)
 8004616:	62da      	str	r2, [r3, #44]	; 0x2c
 8004618:	e7fe      	b.n	8004618 <spiUnselect.constprop.16+0x58>
 800461a:	bf00      	nop
 800461c:	20002194 	.word	0x20002194
 8004620:	20002740 	.word	0x20002740
 8004624:	08006b30 	.word	0x08006b30
 8004628:	08006bc0 	.word	0x08006bc0
 800462c:	00000000 	.word	0x00000000

08004630 <spiSend.constprop.14>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 8004630:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));
 8004632:	b1c0      	cbz	r0, 8004666 <spiSend.constprop.14+0x36>
 8004634:	4606      	mov	r6, r0

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8004636:	2320      	movs	r3, #32
 8004638:	f383 8811 	msr	BASEPRI, r3
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
 800463c:	f7fe fcf0 	bl	8003020 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8004640:	f7fe ff6e 	bl	8003520 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 8004644:	4b28      	ldr	r3, [pc, #160]	; (80046e8 <spiSend.constprop.14+0xb8>)
 8004646:	781a      	ldrb	r2, [r3, #0]
 8004648:	2a02      	cmp	r2, #2
 800464a:	d004      	beq.n	8004656 <spiSend.constprop.14+0x26>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800464c:	b672      	cpsid	i
 800464e:	4b27      	ldr	r3, [pc, #156]	; (80046ec <spiSend.constprop.14+0xbc>)
 8004650:	4a27      	ldr	r2, [pc, #156]	; (80046f0 <spiSend.constprop.14+0xc0>)
 8004652:	62da      	str	r2, [r3, #44]	; 0x2c
 8004654:	e7fe      	b.n	8004654 <spiSend.constprop.14+0x24>
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
 8004656:	685a      	ldr	r2, [r3, #4]
 8004658:	6812      	ldr	r2, [r2, #0]
 800465a:	b14a      	cbz	r2, 8004670 <spiSend.constprop.14+0x40>
 800465c:	b672      	cpsid	i
 800465e:	4b23      	ldr	r3, [pc, #140]	; (80046ec <spiSend.constprop.14+0xbc>)
 8004660:	4a23      	ldr	r2, [pc, #140]	; (80046f0 <spiSend.constprop.14+0xc0>)
 8004662:	62da      	str	r2, [r3, #44]	; 0x2c
 8004664:	e7fe      	b.n	8004664 <spiSend.constprop.14+0x34>
 8004666:	b672      	cpsid	i
 8004668:	4b20      	ldr	r3, [pc, #128]	; (80046ec <spiSend.constprop.14+0xbc>)
 800466a:	4a21      	ldr	r2, [pc, #132]	; (80046f0 <spiSend.constprop.14+0xc0>)
 800466c:	62da      	str	r2, [r3, #44]	; 0x2c
 800466e:	e7fe      	b.n	800466e <spiSend.constprop.14+0x3e>
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 8004670:	6a19      	ldr	r1, [r3, #32]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8004672:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 8004674:	6809      	ldr	r1, [r1, #0]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8004676:	6adc      	ldr	r4, [r3, #44]	; 0x2c

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 8004678:	6812      	ldr	r2, [r2, #0]
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800467a:	481e      	ldr	r0, [pc, #120]	; (80046f4 <spiSend.constprop.14+0xc4>)
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800467c:	6a9f      	ldr	r7, [r3, #40]	; 0x28
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800467e:	60c8      	str	r0, [r1, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8004680:	2501      	movs	r5, #1
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8004682:	f444 6480 	orr.w	r4, r4, #1024	; 0x400
  spiStartSendI(spip, n, txbuf);
 8004686:	2003      	movs	r0, #3
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
  dmaStreamSetTransactionSize(spip->dmarx, n);
 8004688:	604d      	str	r5, [r1, #4]
 800468a:	7018      	strb	r0, [r3, #0]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800468c:	600f      	str	r7, [r1, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800468e:	60d6      	str	r6, [r2, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 8004690:	6055      	str	r5, [r2, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 8004692:	6014      	str	r4, [r2, #0]

  dmaStreamEnable(spip->dmarx);
 8004694:	680d      	ldr	r5, [r1, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004696:	4c15      	ldr	r4, [pc, #84]	; (80046ec <spiSend.constprop.14+0xbc>)
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");
 8004698:	689f      	ldr	r7, [r3, #8]
 800469a:	69a6      	ldr	r6, [r4, #24]
 800469c:	f045 0501 	orr.w	r5, r5, #1
 80046a0:	600d      	str	r5, [r1, #0]
  dmaStreamEnable(spip->dmatx);
 80046a2:	6811      	ldr	r1, [r2, #0]
 80046a4:	f041 0101 	orr.w	r1, r1, #1
 80046a8:	6011      	str	r1, [r2, #0]
 80046aa:	b11f      	cbz	r7, 80046b4 <spiSend.constprop.14+0x84>
 80046ac:	b672      	cpsid	i
 80046ae:	4b12      	ldr	r3, [pc, #72]	; (80046f8 <spiSend.constprop.14+0xc8>)
 80046b0:	62e3      	str	r3, [r4, #44]	; 0x2c
 80046b2:	e7fe      	b.n	80046b2 <spiSend.constprop.14+0x82>

  *trp = tp;
 80046b4:	f843 6f08 	str.w	r6, [r3, #8]!
  tp->p_u.wttrp = trp;
 80046b8:	6273      	str	r3, [r6, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 80046ba:	f7fe fd09 	bl	80030d0 <chSchGoSleepS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80046be:	f7fe ff1f 	bl	8003500 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80046c2:	f7fe fc95 	bl	8002ff0 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80046c6:	6823      	ldr	r3, [r4, #0]
 80046c8:	42a3      	cmp	r3, r4
 80046ca:	d004      	beq.n	80046d6 <spiSend.constprop.14+0xa6>
 80046cc:	69a2      	ldr	r2, [r4, #24]
 80046ce:	689b      	ldr	r3, [r3, #8]
 80046d0:	6892      	ldr	r2, [r2, #8]
 80046d2:	429a      	cmp	r2, r3
 80046d4:	d303      	bcc.n	80046de <spiSend.constprop.14+0xae>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80046d6:	2300      	movs	r3, #0
 80046d8:	f383 8811 	msr	BASEPRI, r3
 80046dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80046de:	b672      	cpsid	i
 80046e0:	4b06      	ldr	r3, [pc, #24]	; (80046fc <spiSend.constprop.14+0xcc>)
 80046e2:	62e3      	str	r3, [r4, #44]	; 0x2c
 80046e4:	e7fe      	b.n	80046e4 <spiSend.constprop.14+0xb4>
 80046e6:	bf00      	nop
 80046e8:	20002194 	.word	0x20002194
 80046ec:	20002740 	.word	0x20002740
 80046f0:	08006ba0 	.word	0x08006ba0
 80046f4:	20002f34 	.word	0x20002f34
 80046f8:	08006ae0 	.word	0x08006ae0
 80046fc:	08006bc0 	.word	0x08006bc0

08004700 <tft_write_data>:
  * @brief  Sending a data
  * @param  data: one byte data to be sent
  * @retval None
  */
void tft_write_data(uint8_t data)
{
 8004700:	b510      	push	{r4, lr}
 8004702:	b082      	sub	sp, #8
 8004704:	ac02      	add	r4, sp, #8
	palSetPad(TFT_DC_PORT, TFT_DC_PIN);
 8004706:	4b07      	ldr	r3, [pc, #28]	; (8004724 <tft_write_data+0x24>)
  * @brief  Sending a data
  * @param  data: one byte data to be sent
  * @retval None
  */
void tft_write_data(uint8_t data)
{
 8004708:	f804 0d01 	strb.w	r0, [r4, #-1]!
	palSetPad(TFT_DC_PORT, TFT_DC_PIN);
 800470c:	2220      	movs	r2, #32
 800470e:	831a      	strh	r2, [r3, #24]

  spiSelect(TFT_SPI);
 8004710:	f7ff ff1e 	bl	8004550 <spiSelect.constprop.18>
  spiSend(TFT_SPI, 1, &data);
 8004714:	4620      	mov	r0, r4
 8004716:	f7ff ff8b 	bl	8004630 <spiSend.constprop.14>
  spiUnselect(TFT_SPI);
 800471a:	f7ff ff51 	bl	80045c0 <spiUnselect.constprop.16>
}
 800471e:	b002      	add	sp, #8
 8004720:	bd10      	pop	{r4, pc}
 8004722:	bf00      	nop
 8004724:	40020800 	.word	0x40020800
	...

08004730 <tft_write_command>:
  * @brief  Sending a command
  * @param  command: one byte command to be sent
  * @retval None
  */
void tft_write_command(uint8_t command)
{
 8004730:	b510      	push	{r4, lr}
 8004732:	b082      	sub	sp, #8
 8004734:	ac02      	add	r4, sp, #8
	palClearPad(TFT_DC_PORT, TFT_DC_PIN);
 8004736:	4b07      	ldr	r3, [pc, #28]	; (8004754 <tft_write_command+0x24>)
  * @brief  Sending a command
  * @param  command: one byte command to be sent
  * @retval None
  */
void tft_write_command(uint8_t command)
{
 8004738:	f804 0d01 	strb.w	r0, [r4, #-1]!
	palClearPad(TFT_DC_PORT, TFT_DC_PIN);
 800473c:	2220      	movs	r2, #32
 800473e:	835a      	strh	r2, [r3, #26]

  spiSelect(TFT_SPI);
 8004740:	f7ff ff06 	bl	8004550 <spiSelect.constprop.18>
  spiSend(TFT_SPI, 1, &command);
 8004744:	4620      	mov	r0, r4
 8004746:	f7ff ff73 	bl	8004630 <spiSend.constprop.14>
  spiUnselect(TFT_SPI);
 800474a:	f7ff ff39 	bl	80045c0 <spiUnselect.constprop.16>
}
 800474e:	b002      	add	sp, #8
 8004750:	bd10      	pop	{r4, pc}
 8004752:	bf00      	nop
 8004754:	40020800 	.word	0x40020800
	...

08004760 <tft_set_char_pos>:
  * @brief  Set the position of some characters
  * @param  None
  * @retval None
  */
void tft_set_char_pos(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2)
{
 8004760:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004762:	4607      	mov	r7, r0
	tft_write_command(0x2a);		// Column addr set
 8004764:	202a      	movs	r0, #42	; 0x2a
  * @brief  Set the position of some characters
  * @param  None
  * @retval None
  */
void tft_set_char_pos(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2)
{
 8004766:	460d      	mov	r5, r1
 8004768:	4616      	mov	r6, r2
 800476a:	461c      	mov	r4, r3
	tft_write_command(0x2a);		// Column addr set
 800476c:	f7ff ffe0 	bl	8004730 <tft_write_command>
	tft_write_data(0x00);
 8004770:	2000      	movs	r0, #0
 8004772:	f7ff ffc5 	bl	8004700 <tft_write_data>
	tft_write_data(x1); 			//X START
 8004776:	4638      	mov	r0, r7
 8004778:	f7ff ffc2 	bl	8004700 <tft_write_data>
	tft_write_data(0x00);
 800477c:	2000      	movs	r0, #0
 800477e:	f7ff ffbf 	bl	8004700 <tft_write_data>
	tft_write_data(x2); 			//X END
 8004782:	4630      	mov	r0, r6
 8004784:	f7ff ffbc 	bl	8004700 <tft_write_data>

	tft_write_command(0x2b);		//Row addr set
 8004788:	202b      	movs	r0, #43	; 0x2b
 800478a:	f7ff ffd1 	bl	8004730 <tft_write_command>
	tft_write_data(0x00);
 800478e:	2000      	movs	r0, #0
 8004790:	f7ff ffb6 	bl	8004700 <tft_write_data>
	tft_write_data(y1);			//Y START
 8004794:	4628      	mov	r0, r5
 8004796:	f7ff ffb3 	bl	8004700 <tft_write_data>
	tft_write_data(0x00);
 800479a:	2000      	movs	r0, #0
 800479c:	f7ff ffb0 	bl	8004700 <tft_write_data>
	tft_write_data(y2);		//Y END
 80047a0:	4620      	mov	r0, r4
 80047a2:	f7ff ffad 	bl	8004700 <tft_write_data>

	tft_write_command(0x2c); 		// write to RAM
 80047a6:	202c      	movs	r0, #44	; 0x2c
}
 80047a8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	tft_write_data(0x00);
	tft_write_data(y1);			//Y START
	tft_write_data(0x00);
	tft_write_data(y2);		//Y END

	tft_write_command(0x2c); 		// write to RAM
 80047ac:	f7ff bfc0 	b.w	8004730 <tft_write_command>

080047b0 <strpbrk>:
 80047b0:	b430      	push	{r4, r5}
 80047b2:	7804      	ldrb	r4, [r0, #0]
 80047b4:	b1ec      	cbz	r4, 80047f2 <strpbrk+0x42>
 80047b6:	780d      	ldrb	r5, [r1, #0]
 80047b8:	b1ad      	cbz	r5, 80047e6 <strpbrk+0x36>
 80047ba:	42ac      	cmp	r4, r5
 80047bc:	d00e      	beq.n	80047dc <strpbrk+0x2c>
 80047be:	460a      	mov	r2, r1
 80047c0:	e001      	b.n	80047c6 <strpbrk+0x16>
 80047c2:	429c      	cmp	r4, r3
 80047c4:	d009      	beq.n	80047da <strpbrk+0x2a>
 80047c6:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80047ca:	2b00      	cmp	r3, #0
 80047cc:	d1f9      	bne.n	80047c2 <strpbrk+0x12>
 80047ce:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 80047d2:	2c00      	cmp	r4, #0
 80047d4:	d1f0      	bne.n	80047b8 <strpbrk+0x8>
 80047d6:	7815      	ldrb	r5, [r2, #0]
 80047d8:	e000      	b.n	80047dc <strpbrk+0x2c>
 80047da:	4625      	mov	r5, r4
 80047dc:	2d00      	cmp	r5, #0
 80047de:	bf08      	it	eq
 80047e0:	2000      	moveq	r0, #0
 80047e2:	bc30      	pop	{r4, r5}
 80047e4:	4770      	bx	lr
 80047e6:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 80047ea:	460a      	mov	r2, r1
 80047ec:	2c00      	cmp	r4, #0
 80047ee:	d1e3      	bne.n	80047b8 <strpbrk+0x8>
 80047f0:	e7f1      	b.n	80047d6 <strpbrk+0x26>
 80047f2:	4620      	mov	r0, r4
 80047f4:	bc30      	pop	{r4, r5}
 80047f6:	4770      	bx	lr
	...

08004800 <strspn>:
 8004800:	b470      	push	{r4, r5, r6}
 8004802:	7804      	ldrb	r4, [r0, #0]
 8004804:	b1a4      	cbz	r4, 8004830 <strspn+0x30>
 8004806:	780e      	ldrb	r6, [r1, #0]
 8004808:	4605      	mov	r5, r0
 800480a:	b14e      	cbz	r6, 8004820 <strspn+0x20>
 800480c:	42b4      	cmp	r4, r6
 800480e:	d00a      	beq.n	8004826 <strspn+0x26>
 8004810:	460a      	mov	r2, r1
 8004812:	e001      	b.n	8004818 <strspn+0x18>
 8004814:	429c      	cmp	r4, r3
 8004816:	d006      	beq.n	8004826 <strspn+0x26>
 8004818:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800481c:	2b00      	cmp	r3, #0
 800481e:	d1f9      	bne.n	8004814 <strspn+0x14>
 8004820:	1a28      	subs	r0, r5, r0
 8004822:	bc70      	pop	{r4, r5, r6}
 8004824:	4770      	bx	lr
 8004826:	f815 4f01 	ldrb.w	r4, [r5, #1]!
 800482a:	2c00      	cmp	r4, #0
 800482c:	d1ed      	bne.n	800480a <strspn+0xa>
 800482e:	e7f7      	b.n	8004820 <strspn+0x20>
 8004830:	4620      	mov	r0, r4
 8004832:	e7f6      	b.n	8004822 <strspn+0x22>
	...

08004840 <sinf>:
 8004840:	b500      	push	{lr}
 8004842:	ee10 3a10 	vmov	r3, s0
 8004846:	4a1b      	ldr	r2, [pc, #108]	; (80048b4 <sinf+0x74>)
 8004848:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800484c:	4293      	cmp	r3, r2
 800484e:	b083      	sub	sp, #12
 8004850:	dd1a      	ble.n	8004888 <sinf+0x48>
 8004852:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8004856:	db04      	blt.n	8004862 <sinf+0x22>
 8004858:	ee30 0a40 	vsub.f32	s0, s0, s0
 800485c:	b003      	add	sp, #12
 800485e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004862:	4668      	mov	r0, sp
 8004864:	f000 f82c 	bl	80048c0 <__ieee754_rem_pio2f>
 8004868:	f000 0003 	and.w	r0, r0, #3
 800486c:	2801      	cmp	r0, #1
 800486e:	ed9d 0a00 	vldr	s0, [sp]
 8004872:	eddd 0a01 	vldr	s1, [sp, #4]
 8004876:	d015      	beq.n	80048a4 <sinf+0x64>
 8004878:	2802      	cmp	r0, #2
 800487a:	d00d      	beq.n	8004898 <sinf+0x58>
 800487c:	b1a8      	cbz	r0, 80048aa <sinf+0x6a>
 800487e:	f000 f967 	bl	8004b50 <__kernel_cosf>
 8004882:	eeb1 0a40 	vneg.f32	s0, s0
 8004886:	e7e9      	b.n	800485c <sinf+0x1c>
 8004888:	eddf 0a0b 	vldr	s1, [pc, #44]	; 80048b8 <sinf+0x78>
 800488c:	2000      	movs	r0, #0
 800488e:	f000 fcdf 	bl	8005250 <__kernel_sinf>
 8004892:	b003      	add	sp, #12
 8004894:	f85d fb04 	ldr.w	pc, [sp], #4
 8004898:	2001      	movs	r0, #1
 800489a:	f000 fcd9 	bl	8005250 <__kernel_sinf>
 800489e:	eeb1 0a40 	vneg.f32	s0, s0
 80048a2:	e7db      	b.n	800485c <sinf+0x1c>
 80048a4:	f000 f954 	bl	8004b50 <__kernel_cosf>
 80048a8:	e7d8      	b.n	800485c <sinf+0x1c>
 80048aa:	2001      	movs	r0, #1
 80048ac:	f000 fcd0 	bl	8005250 <__kernel_sinf>
 80048b0:	e7d4      	b.n	800485c <sinf+0x1c>
 80048b2:	bf00      	nop
 80048b4:	3f490fd8 	.word	0x3f490fd8
	...

080048c0 <__ieee754_rem_pio2f>:
 80048c0:	b570      	push	{r4, r5, r6, lr}
 80048c2:	ee10 3a10 	vmov	r3, s0
 80048c6:	4a94      	ldr	r2, [pc, #592]	; (8004b18 <__ieee754_rem_pio2f+0x258>)
 80048c8:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
 80048cc:	4294      	cmp	r4, r2
 80048ce:	b086      	sub	sp, #24
 80048d0:	ee10 6a10 	vmov	r6, s0
 80048d4:	4605      	mov	r5, r0
 80048d6:	dd66      	ble.n	80049a6 <__ieee754_rem_pio2f+0xe6>
 80048d8:	4a90      	ldr	r2, [pc, #576]	; (8004b1c <__ieee754_rem_pio2f+0x25c>)
 80048da:	4294      	cmp	r4, r2
 80048dc:	dc1a      	bgt.n	8004914 <__ieee754_rem_pio2f+0x54>
 80048de:	2b00      	cmp	r3, #0
 80048e0:	eddf 7a8f 	vldr	s15, [pc, #572]	; 8004b20 <__ieee754_rem_pio2f+0x260>
 80048e4:	4a8f      	ldr	r2, [pc, #572]	; (8004b24 <__ieee754_rem_pio2f+0x264>)
 80048e6:	f024 040f 	bic.w	r4, r4, #15
 80048ea:	f340 80dd 	ble.w	8004aa8 <__ieee754_rem_pio2f+0x1e8>
 80048ee:	4294      	cmp	r4, r2
 80048f0:	ee70 7a67 	vsub.f32	s15, s0, s15
 80048f4:	d066      	beq.n	80049c4 <__ieee754_rem_pio2f+0x104>
 80048f6:	ed9f 7a8c 	vldr	s14, [pc, #560]	; 8004b28 <__ieee754_rem_pio2f+0x268>
 80048fa:	ee77 6ac7 	vsub.f32	s13, s15, s14
 80048fe:	2001      	movs	r0, #1
 8004900:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8004904:	edc5 6a00 	vstr	s13, [r5]
 8004908:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800490c:	edc5 7a01 	vstr	s15, [r5, #4]
 8004910:	b006      	add	sp, #24
 8004912:	bd70      	pop	{r4, r5, r6, pc}
 8004914:	4a85      	ldr	r2, [pc, #532]	; (8004b2c <__ieee754_rem_pio2f+0x26c>)
 8004916:	4294      	cmp	r4, r2
 8004918:	dd66      	ble.n	80049e8 <__ieee754_rem_pio2f+0x128>
 800491a:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 800491e:	da49      	bge.n	80049b4 <__ieee754_rem_pio2f+0xf4>
 8004920:	15e2      	asrs	r2, r4, #23
 8004922:	3a86      	subs	r2, #134	; 0x86
 8004924:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
 8004928:	ee07 3a10 	vmov	s14, r3
 800492c:	eefd 6ac7 	vcvt.s32.f32	s13, s14
 8004930:	eddf 7a7f 	vldr	s15, [pc, #508]	; 8004b30 <__ieee754_rem_pio2f+0x270>
 8004934:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8004938:	ee37 7a66 	vsub.f32	s14, s14, s13
 800493c:	edcd 6a03 	vstr	s13, [sp, #12]
 8004940:	ee27 7a27 	vmul.f32	s14, s14, s15
 8004944:	eefd 6ac7 	vcvt.s32.f32	s13, s14
 8004948:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800494c:	ee37 7a66 	vsub.f32	s14, s14, s13
 8004950:	edcd 6a04 	vstr	s13, [sp, #16]
 8004954:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004958:	eef5 7a40 	vcmp.f32	s15, #0.0
 800495c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004960:	edcd 7a05 	vstr	s15, [sp, #20]
 8004964:	f040 80b3 	bne.w	8004ace <__ieee754_rem_pio2f+0x20e>
 8004968:	eef5 6a40 	vcmp.f32	s13, #0.0
 800496c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004970:	bf14      	ite	ne
 8004972:	2302      	movne	r3, #2
 8004974:	2301      	moveq	r3, #1
 8004976:	496f      	ldr	r1, [pc, #444]	; (8004b34 <__ieee754_rem_pio2f+0x274>)
 8004978:	2002      	movs	r0, #2
 800497a:	e88d 0003 	stmia.w	sp, {r0, r1}
 800497e:	a803      	add	r0, sp, #12
 8004980:	4629      	mov	r1, r5
 8004982:	f000 f96d 	bl	8004c60 <__kernel_rem_pio2f>
 8004986:	2e00      	cmp	r6, #0
 8004988:	da12      	bge.n	80049b0 <__ieee754_rem_pio2f+0xf0>
 800498a:	ed95 7a00 	vldr	s14, [r5]
 800498e:	edd5 7a01 	vldr	s15, [r5, #4]
 8004992:	eeb1 7a47 	vneg.f32	s14, s14
 8004996:	eef1 7a67 	vneg.f32	s15, s15
 800499a:	4240      	negs	r0, r0
 800499c:	ed85 7a00 	vstr	s14, [r5]
 80049a0:	edc5 7a01 	vstr	s15, [r5, #4]
 80049a4:	e004      	b.n	80049b0 <__ieee754_rem_pio2f+0xf0>
 80049a6:	2200      	movs	r2, #0
 80049a8:	ed85 0a00 	vstr	s0, [r5]
 80049ac:	6042      	str	r2, [r0, #4]
 80049ae:	2000      	movs	r0, #0
 80049b0:	b006      	add	sp, #24
 80049b2:	bd70      	pop	{r4, r5, r6, pc}
 80049b4:	ee70 7a40 	vsub.f32	s15, s0, s0
 80049b8:	2000      	movs	r0, #0
 80049ba:	edc5 7a01 	vstr	s15, [r5, #4]
 80049be:	edc5 7a00 	vstr	s15, [r5]
 80049c2:	e7f5      	b.n	80049b0 <__ieee754_rem_pio2f+0xf0>
 80049c4:	eddf 6a5c 	vldr	s13, [pc, #368]	; 8004b38 <__ieee754_rem_pio2f+0x278>
 80049c8:	ed9f 7a5c 	vldr	s14, [pc, #368]	; 8004b3c <__ieee754_rem_pio2f+0x27c>
 80049cc:	ee77 7ae6 	vsub.f32	s15, s15, s13
 80049d0:	2001      	movs	r0, #1
 80049d2:	ee77 6ac7 	vsub.f32	s13, s15, s14
 80049d6:	ee77 7ae6 	vsub.f32	s15, s15, s13
 80049da:	edc5 6a00 	vstr	s13, [r5]
 80049de:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80049e2:	edc5 7a01 	vstr	s15, [r5, #4]
 80049e6:	e7e3      	b.n	80049b0 <__ieee754_rem_pio2f+0xf0>
 80049e8:	f000 fc7a 	bl	80052e0 <fabsf>
 80049ec:	eddf 6a54 	vldr	s13, [pc, #336]	; 8004b40 <__ieee754_rem_pio2f+0x280>
 80049f0:	eddf 5a4b 	vldr	s11, [pc, #300]	; 8004b20 <__ieee754_rem_pio2f+0x260>
 80049f4:	ed9f 7a4c 	vldr	s14, [pc, #304]	; 8004b28 <__ieee754_rem_pio2f+0x268>
 80049f8:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 80049fc:	eee0 7a26 	vfma.f32	s15, s0, s13
 8004a00:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8004a04:	ee17 0a90 	vmov	r0, s15
 8004a08:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 8004a0c:	281f      	cmp	r0, #31
 8004a0e:	eeb1 6a66 	vneg.f32	s12, s13
 8004a12:	eea6 0a25 	vfma.f32	s0, s12, s11
 8004a16:	ee66 7a87 	vmul.f32	s15, s13, s14
 8004a1a:	dc1d      	bgt.n	8004a58 <__ieee754_rem_pio2f+0x198>
 8004a1c:	4a49      	ldr	r2, [pc, #292]	; (8004b44 <__ieee754_rem_pio2f+0x284>)
 8004a1e:	1e41      	subs	r1, r0, #1
 8004a20:	f024 03ff 	bic.w	r3, r4, #255	; 0xff
 8004a24:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8004a28:	4293      	cmp	r3, r2
 8004a2a:	d015      	beq.n	8004a58 <__ieee754_rem_pio2f+0x198>
 8004a2c:	ee30 7a67 	vsub.f32	s14, s0, s15
 8004a30:	ed85 7a00 	vstr	s14, [r5]
 8004a34:	ee30 0a47 	vsub.f32	s0, s0, s14
 8004a38:	2e00      	cmp	r6, #0
 8004a3a:	ee30 0a67 	vsub.f32	s0, s0, s15
 8004a3e:	ed85 0a01 	vstr	s0, [r5, #4]
 8004a42:	dab5      	bge.n	80049b0 <__ieee754_rem_pio2f+0xf0>
 8004a44:	eeb1 7a47 	vneg.f32	s14, s14
 8004a48:	eeb1 0a40 	vneg.f32	s0, s0
 8004a4c:	ed85 7a00 	vstr	s14, [r5]
 8004a50:	ed85 0a01 	vstr	s0, [r5, #4]
 8004a54:	4240      	negs	r0, r0
 8004a56:	e7ab      	b.n	80049b0 <__ieee754_rem_pio2f+0xf0>
 8004a58:	ee30 7a67 	vsub.f32	s14, s0, s15
 8004a5c:	15e4      	asrs	r4, r4, #23
 8004a5e:	ee17 3a10 	vmov	r3, s14
 8004a62:	f3c3 53c7 	ubfx	r3, r3, #23, #8
 8004a66:	1ae3      	subs	r3, r4, r3
 8004a68:	2b08      	cmp	r3, #8
 8004a6a:	dde1      	ble.n	8004a30 <__ieee754_rem_pio2f+0x170>
 8004a6c:	eddf 7a32 	vldr	s15, [pc, #200]	; 8004b38 <__ieee754_rem_pio2f+0x278>
 8004a70:	ed9f 7a32 	vldr	s14, [pc, #200]	; 8004b3c <__ieee754_rem_pio2f+0x27c>
 8004a74:	eef0 5a40 	vmov.f32	s11, s0
 8004a78:	eee6 5a27 	vfma.f32	s11, s12, s15
 8004a7c:	ee30 0a65 	vsub.f32	s0, s0, s11
 8004a80:	eea6 0a27 	vfma.f32	s0, s12, s15
 8004a84:	eef0 7a40 	vmov.f32	s15, s0
 8004a88:	eed6 7a87 	vfnms.f32	s15, s13, s14
 8004a8c:	ee35 7ae7 	vsub.f32	s14, s11, s15
 8004a90:	ee17 3a10 	vmov	r3, s14
 8004a94:	f3c3 53c7 	ubfx	r3, r3, #23, #8
 8004a98:	1ae4      	subs	r4, r4, r3
 8004a9a:	2c19      	cmp	r4, #25
 8004a9c:	dc2c      	bgt.n	8004af8 <__ieee754_rem_pio2f+0x238>
 8004a9e:	ed85 7a00 	vstr	s14, [r5]
 8004aa2:	eeb0 0a65 	vmov.f32	s0, s11
 8004aa6:	e7c5      	b.n	8004a34 <__ieee754_rem_pio2f+0x174>
 8004aa8:	4294      	cmp	r4, r2
 8004aaa:	ee70 7a27 	vadd.f32	s15, s0, s15
 8004aae:	d010      	beq.n	8004ad2 <__ieee754_rem_pio2f+0x212>
 8004ab0:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 8004b28 <__ieee754_rem_pio2f+0x268>
 8004ab4:	ee77 6a87 	vadd.f32	s13, s15, s14
 8004ab8:	f04f 30ff 	mov.w	r0, #4294967295
 8004abc:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8004ac0:	edc5 6a00 	vstr	s13, [r5]
 8004ac4:	ee77 7a87 	vadd.f32	s15, s15, s14
 8004ac8:	edc5 7a01 	vstr	s15, [r5, #4]
 8004acc:	e770      	b.n	80049b0 <__ieee754_rem_pio2f+0xf0>
 8004ace:	2303      	movs	r3, #3
 8004ad0:	e751      	b.n	8004976 <__ieee754_rem_pio2f+0xb6>
 8004ad2:	eddf 6a19 	vldr	s13, [pc, #100]	; 8004b38 <__ieee754_rem_pio2f+0x278>
 8004ad6:	ed9f 7a19 	vldr	s14, [pc, #100]	; 8004b3c <__ieee754_rem_pio2f+0x27c>
 8004ada:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8004ade:	f04f 30ff 	mov.w	r0, #4294967295
 8004ae2:	ee77 6a87 	vadd.f32	s13, s15, s14
 8004ae6:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8004aea:	edc5 6a00 	vstr	s13, [r5]
 8004aee:	ee77 7a87 	vadd.f32	s15, s15, s14
 8004af2:	edc5 7a01 	vstr	s15, [r5, #4]
 8004af6:	e75b      	b.n	80049b0 <__ieee754_rem_pio2f+0xf0>
 8004af8:	ed9f 7a13 	vldr	s14, [pc, #76]	; 8004b48 <__ieee754_rem_pio2f+0x288>
 8004afc:	ed9f 5a13 	vldr	s10, [pc, #76]	; 8004b4c <__ieee754_rem_pio2f+0x28c>
 8004b00:	eeb0 0a65 	vmov.f32	s0, s11
 8004b04:	eea6 0a07 	vfma.f32	s0, s12, s14
 8004b08:	ee75 7ac0 	vsub.f32	s15, s11, s0
 8004b0c:	eee6 7a07 	vfma.f32	s15, s12, s14
 8004b10:	eed6 7a85 	vfnms.f32	s15, s13, s10
 8004b14:	e78a      	b.n	8004a2c <__ieee754_rem_pio2f+0x16c>
 8004b16:	bf00      	nop
 8004b18:	3f490fd8 	.word	0x3f490fd8
 8004b1c:	4016cbe3 	.word	0x4016cbe3
 8004b20:	3fc90f80 	.word	0x3fc90f80
 8004b24:	3fc90fd0 	.word	0x3fc90fd0
 8004b28:	37354443 	.word	0x37354443
 8004b2c:	43490f80 	.word	0x43490f80
 8004b30:	43800000 	.word	0x43800000
 8004b34:	08006c50 	.word	0x08006c50
 8004b38:	37354400 	.word	0x37354400
 8004b3c:	2e85a308 	.word	0x2e85a308
 8004b40:	3f22f984 	.word	0x3f22f984
 8004b44:	08006bd0 	.word	0x08006bd0
 8004b48:	2e85a300 	.word	0x2e85a300
 8004b4c:	248d3132 	.word	0x248d3132

08004b50 <__kernel_cosf>:
 8004b50:	ee10 3a10 	vmov	r3, s0
 8004b54:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8004b58:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 8004b5c:	da2c      	bge.n	8004bb8 <__kernel_cosf+0x68>
 8004b5e:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8004b62:	ee17 3a90 	vmov	r3, s15
 8004b66:	2b00      	cmp	r3, #0
 8004b68:	d060      	beq.n	8004c2c <__kernel_cosf+0xdc>
 8004b6a:	ee20 7a00 	vmul.f32	s14, s0, s0
 8004b6e:	eddf 4a31 	vldr	s9, [pc, #196]	; 8004c34 <__kernel_cosf+0xe4>
 8004b72:	ed9f 5a31 	vldr	s10, [pc, #196]	; 8004c38 <__kernel_cosf+0xe8>
 8004b76:	eddf 5a31 	vldr	s11, [pc, #196]	; 8004c3c <__kernel_cosf+0xec>
 8004b7a:	ed9f 6a31 	vldr	s12, [pc, #196]	; 8004c40 <__kernel_cosf+0xf0>
 8004b7e:	eddf 7a31 	vldr	s15, [pc, #196]	; 8004c44 <__kernel_cosf+0xf4>
 8004b82:	eddf 6a31 	vldr	s13, [pc, #196]	; 8004c48 <__kernel_cosf+0xf8>
 8004b86:	eea7 5a24 	vfma.f32	s10, s14, s9
 8004b8a:	eee5 5a07 	vfma.f32	s11, s10, s14
 8004b8e:	eea5 6a87 	vfma.f32	s12, s11, s14
 8004b92:	eee6 7a07 	vfma.f32	s15, s12, s14
 8004b96:	eee7 6a87 	vfma.f32	s13, s15, s14
 8004b9a:	ee66 6a87 	vmul.f32	s13, s13, s14
 8004b9e:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 8004ba2:	eeb6 6a00 	vmov.f32	s12, #96	; 0x60
 8004ba6:	eee7 0a26 	vfma.f32	s1, s14, s13
 8004baa:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 8004bae:	eed7 0a06 	vfnms.f32	s1, s14, s12
 8004bb2:	ee37 0ae0 	vsub.f32	s0, s15, s1
 8004bb6:	4770      	bx	lr
 8004bb8:	ee20 7a00 	vmul.f32	s14, s0, s0
 8004bbc:	eddf 4a1d 	vldr	s9, [pc, #116]	; 8004c34 <__kernel_cosf+0xe4>
 8004bc0:	ed9f 5a1d 	vldr	s10, [pc, #116]	; 8004c38 <__kernel_cosf+0xe8>
 8004bc4:	eddf 5a1d 	vldr	s11, [pc, #116]	; 8004c3c <__kernel_cosf+0xec>
 8004bc8:	ed9f 6a1d 	vldr	s12, [pc, #116]	; 8004c40 <__kernel_cosf+0xf0>
 8004bcc:	eddf 7a1d 	vldr	s15, [pc, #116]	; 8004c44 <__kernel_cosf+0xf4>
 8004bd0:	eddf 6a1d 	vldr	s13, [pc, #116]	; 8004c48 <__kernel_cosf+0xf8>
 8004bd4:	4a1d      	ldr	r2, [pc, #116]	; (8004c4c <__kernel_cosf+0xfc>)
 8004bd6:	eea7 5a24 	vfma.f32	s10, s14, s9
 8004bda:	4293      	cmp	r3, r2
 8004bdc:	eee5 5a07 	vfma.f32	s11, s10, s14
 8004be0:	eea5 6a87 	vfma.f32	s12, s11, s14
 8004be4:	eee6 7a07 	vfma.f32	s15, s12, s14
 8004be8:	eee7 6a87 	vfma.f32	s13, s15, s14
 8004bec:	ee66 6a87 	vmul.f32	s13, s13, s14
 8004bf0:	ddd5      	ble.n	8004b9e <__kernel_cosf+0x4e>
 8004bf2:	4a17      	ldr	r2, [pc, #92]	; (8004c50 <__kernel_cosf+0x100>)
 8004bf4:	4293      	cmp	r3, r2
 8004bf6:	dc14      	bgt.n	8004c22 <__kernel_cosf+0xd2>
 8004bf8:	f103 437f 	add.w	r3, r3, #4278190080	; 0xff000000
 8004bfc:	ee07 3a90 	vmov	s15, r3
 8004c00:	eeb7 6a00 	vmov.f32	s12, #112	; 0x70
 8004c04:	ee36 6a67 	vsub.f32	s12, s12, s15
 8004c08:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 8004c0c:	eef6 5a00 	vmov.f32	s11, #96	; 0x60
 8004c10:	eee7 0a26 	vfma.f32	s1, s14, s13
 8004c14:	eed7 7a25 	vfnms.f32	s15, s14, s11
 8004c18:	ee77 7ae0 	vsub.f32	s15, s15, s1
 8004c1c:	ee36 0a67 	vsub.f32	s0, s12, s15
 8004c20:	4770      	bx	lr
 8004c22:	eeb6 6a07 	vmov.f32	s12, #103	; 0x67
 8004c26:	eef5 7a02 	vmov.f32	s15, #82	; 0x52
 8004c2a:	e7ed      	b.n	8004c08 <__kernel_cosf+0xb8>
 8004c2c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
 8004c30:	4770      	bx	lr
 8004c32:	bf00      	nop
 8004c34:	ad47d74e 	.word	0xad47d74e
 8004c38:	310f74f6 	.word	0x310f74f6
 8004c3c:	b493f27c 	.word	0xb493f27c
 8004c40:	37d00d01 	.word	0x37d00d01
 8004c44:	bab60b61 	.word	0xbab60b61
 8004c48:	3d2aaaab 	.word	0x3d2aaaab
 8004c4c:	3e999999 	.word	0x3e999999
 8004c50:	3f480000 	.word	0x3f480000
	...

08004c60 <__kernel_rem_pio2f>:
 8004c60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004c64:	ed2d 8b04 	vpush	{d8-d9}
 8004c68:	b0d7      	sub	sp, #348	; 0x15c
 8004c6a:	1e5f      	subs	r7, r3, #1
 8004c6c:	4cd7      	ldr	r4, [pc, #860]	; (8004fcc <__kernel_rem_pio2f+0x36c>)
 8004c6e:	9d64      	ldr	r5, [sp, #400]	; 0x190
 8004c70:	9302      	str	r3, [sp, #8]
 8004c72:	1ed3      	subs	r3, r2, #3
 8004c74:	bf48      	it	mi
 8004c76:	1d13      	addmi	r3, r2, #4
 8004c78:	f854 6025 	ldr.w	r6, [r4, r5, lsl #2]
 8004c7c:	9101      	str	r1, [sp, #4]
 8004c7e:	10db      	asrs	r3, r3, #3
 8004c80:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8004c84:	ea6f 0b03 	mvn.w	fp, r3
 8004c88:	19b9      	adds	r1, r7, r6
 8004c8a:	9303      	str	r3, [sp, #12]
 8004c8c:	4682      	mov	sl, r0
 8004c8e:	eb02 0bcb 	add.w	fp, r2, fp, lsl #3
 8004c92:	eba3 0307 	sub.w	r3, r3, r7
 8004c96:	d414      	bmi.n	8004cc2 <__kernel_rem_pio2f+0x62>
 8004c98:	4419      	add	r1, r3
 8004c9a:	9865      	ldr	r0, [sp, #404]	; 0x194
 8004c9c:	3101      	adds	r1, #1
 8004c9e:	aa1a      	add	r2, sp, #104	; 0x68
 8004ca0:	2b00      	cmp	r3, #0
 8004ca2:	bfaa      	itet	ge
 8004ca4:	f850 4023 	ldrge.w	r4, [r0, r3, lsl #2]
 8004ca8:	eddf 7acc 	vldrlt	s15, [pc, #816]	; 8004fdc <__kernel_rem_pio2f+0x37c>
 8004cac:	ee07 4a90 	vmovge	s15, r4
 8004cb0:	f103 0301 	add.w	r3, r3, #1
 8004cb4:	bfa8      	it	ge
 8004cb6:	eef8 7ae7 	vcvtge.f32.s32	s15, s15
 8004cba:	428b      	cmp	r3, r1
 8004cbc:	ece2 7a01 	vstmia	r2!, {s15}
 8004cc0:	d1ee      	bne.n	8004ca0 <__kernel_rem_pio2f+0x40>
 8004cc2:	2e00      	cmp	r6, #0
 8004cc4:	db1a      	blt.n	8004cfc <__kernel_rem_pio2f+0x9c>
 8004cc6:	9b02      	ldr	r3, [sp, #8]
 8004cc8:	a91a      	add	r1, sp, #104	; 0x68
 8004cca:	1c74      	adds	r4, r6, #1
 8004ccc:	eb01 0484 	add.w	r4, r1, r4, lsl #2
 8004cd0:	a842      	add	r0, sp, #264	; 0x108
 8004cd2:	009d      	lsls	r5, r3, #2
 8004cd4:	2f00      	cmp	r7, #0
 8004cd6:	f2c0 81ba 	blt.w	800504e <__kernel_rem_pio2f+0x3ee>
 8004cda:	eddf 7ac0 	vldr	s15, [pc, #768]	; 8004fdc <__kernel_rem_pio2f+0x37c>
 8004cde:	4652      	mov	r2, sl
 8004ce0:	194b      	adds	r3, r1, r5
 8004ce2:	ed33 7a01 	vldmdb	r3!, {s14}
 8004ce6:	ecf2 6a01 	vldmia	r2!, {s13}
 8004cea:	4299      	cmp	r1, r3
 8004cec:	eee6 7a87 	vfma.f32	s15, s13, s14
 8004cf0:	d1f7      	bne.n	8004ce2 <__kernel_rem_pio2f+0x82>
 8004cf2:	3104      	adds	r1, #4
 8004cf4:	42a1      	cmp	r1, r4
 8004cf6:	ece0 7a01 	vstmia	r0!, {s15}
 8004cfa:	d1eb      	bne.n	8004cd4 <__kernel_rem_pio2f+0x74>
 8004cfc:	9a02      	ldr	r2, [sp, #8]
 8004cfe:	eddf 8ab4 	vldr	s17, [pc, #720]	; 8004fd0 <__kernel_rem_pio2f+0x370>
 8004d02:	ed9f 8ab4 	vldr	s16, [pc, #720]	; 8004fd4 <__kernel_rem_pio2f+0x374>
 8004d06:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
 8004d0a:	3b01      	subs	r3, #1
 8004d0c:	009b      	lsls	r3, r3, #2
 8004d0e:	ebc2 7982 	rsb	r9, r2, r2, lsl #30
 8004d12:	aa06      	add	r2, sp, #24
 8004d14:	f103 0804 	add.w	r8, r3, #4
 8004d18:	4413      	add	r3, r2
 8004d1a:	4490      	add	r8, r2
 8004d1c:	9304      	str	r3, [sp, #16]
 8004d1e:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8004d22:	4634      	mov	r4, r6
 8004d24:	00a5      	lsls	r5, r4, #2
 8004d26:	ab56      	add	r3, sp, #344	; 0x158
 8004d28:	442b      	add	r3, r5
 8004d2a:	2c00      	cmp	r4, #0
 8004d2c:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
 8004d30:	dd18      	ble.n	8004d64 <__kernel_rem_pio2f+0x104>
 8004d32:	a942      	add	r1, sp, #264	; 0x108
 8004d34:	194b      	adds	r3, r1, r5
 8004d36:	aa05      	add	r2, sp, #20
 8004d38:	ee60 7a28 	vmul.f32	s15, s0, s17
 8004d3c:	eeb0 7a40 	vmov.f32	s14, s0
 8004d40:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8004d44:	ed73 6a01 	vldmdb	r3!, {s13}
 8004d48:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004d4c:	428b      	cmp	r3, r1
 8004d4e:	eea7 7ac8 	vfms.f32	s14, s15, s16
 8004d52:	ee37 0aa6 	vadd.f32	s0, s15, s13
 8004d56:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 8004d5a:	ee17 0a10 	vmov	r0, s14
 8004d5e:	f842 0f04 	str.w	r0, [r2, #4]!
 8004d62:	d1e9      	bne.n	8004d38 <__kernel_rem_pio2f+0xd8>
 8004d64:	4658      	mov	r0, fp
 8004d66:	f000 fb0b 	bl	8005380 <scalbnf>
 8004d6a:	eeb0 9a40 	vmov.f32	s18, s0
 8004d6e:	eeb4 0a00 	vmov.f32	s0, #64	; 0x40
 8004d72:	ee29 0a00 	vmul.f32	s0, s18, s0
 8004d76:	f000 fabb 	bl	80052f0 <floorf>
 8004d7a:	eef2 7a00 	vmov.f32	s15, #32
 8004d7e:	eea0 9a67 	vfms.f32	s18, s0, s15
 8004d82:	f1bb 0f00 	cmp.w	fp, #0
 8004d86:	eefd 9ac9 	vcvt.s32.f32	s19, s18
 8004d8a:	eef8 7ae9 	vcvt.f32.s32	s15, s19
 8004d8e:	ee39 9a67 	vsub.f32	s18, s18, s15
 8004d92:	f340 8141 	ble.w	8005018 <__kernel_rem_pio2f+0x3b8>
 8004d96:	1e60      	subs	r0, r4, #1
 8004d98:	aa06      	add	r2, sp, #24
 8004d9a:	f1cb 0308 	rsb	r3, fp, #8
 8004d9e:	f852 1020 	ldr.w	r1, [r2, r0, lsl #2]
 8004da2:	fa41 f203 	asr.w	r2, r1, r3
 8004da6:	fa02 f303 	lsl.w	r3, r2, r3
 8004daa:	f10d 0e18 	add.w	lr, sp, #24
 8004dae:	1ac9      	subs	r1, r1, r3
 8004db0:	f84e 1020 	str.w	r1, [lr, r0, lsl #2]
 8004db4:	ee19 0a90 	vmov	r0, s19
 8004db8:	4410      	add	r0, r2
 8004dba:	f1cb 0307 	rsb	r3, fp, #7
 8004dbe:	ee09 0a90 	vmov	s19, r0
 8004dc2:	4119      	asrs	r1, r3
 8004dc4:	2900      	cmp	r1, #0
 8004dc6:	dd39      	ble.n	8004e3c <__kernel_rem_pio2f+0x1dc>
 8004dc8:	ee19 3a90 	vmov	r3, s19
 8004dcc:	2c00      	cmp	r4, #0
 8004dce:	f103 0301 	add.w	r3, r3, #1
 8004dd2:	ee09 3a90 	vmov	s19, r3
 8004dd6:	f340 81cb 	ble.w	8005170 <__kernel_rem_pio2f+0x510>
 8004dda:	2200      	movs	r2, #0
 8004ddc:	4610      	mov	r0, r2
 8004dde:	f10d 0e14 	add.w	lr, sp, #20
 8004de2:	e008      	b.n	8004df6 <__kernel_rem_pio2f+0x196>
 8004de4:	f5c3 7c80 	rsb	ip, r3, #256	; 0x100
 8004de8:	b113      	cbz	r3, 8004df0 <__kernel_rem_pio2f+0x190>
 8004dea:	f8ce c000 	str.w	ip, [lr]
 8004dee:	2001      	movs	r0, #1
 8004df0:	3201      	adds	r2, #1
 8004df2:	4294      	cmp	r4, r2
 8004df4:	dd0c      	ble.n	8004e10 <__kernel_rem_pio2f+0x1b0>
 8004df6:	f85e 3f04 	ldr.w	r3, [lr, #4]!
 8004dfa:	2800      	cmp	r0, #0
 8004dfc:	d0f2      	beq.n	8004de4 <__kernel_rem_pio2f+0x184>
 8004dfe:	3201      	adds	r2, #1
 8004e00:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8004e04:	4294      	cmp	r4, r2
 8004e06:	f8ce 3000 	str.w	r3, [lr]
 8004e0a:	f04f 0001 	mov.w	r0, #1
 8004e0e:	dcf2      	bgt.n	8004df6 <__kernel_rem_pio2f+0x196>
 8004e10:	f1bb 0f00 	cmp.w	fp, #0
 8004e14:	dd10      	ble.n	8004e38 <__kernel_rem_pio2f+0x1d8>
 8004e16:	f1bb 0f01 	cmp.w	fp, #1
 8004e1a:	f000 8104 	beq.w	8005026 <__kernel_rem_pio2f+0x3c6>
 8004e1e:	f1bb 0f02 	cmp.w	fp, #2
 8004e22:	d109      	bne.n	8004e38 <__kernel_rem_pio2f+0x1d8>
 8004e24:	1e62      	subs	r2, r4, #1
 8004e26:	ab06      	add	r3, sp, #24
 8004e28:	f10d 0e18 	add.w	lr, sp, #24
 8004e2c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8004e30:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8004e34:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
 8004e38:	2902      	cmp	r1, #2
 8004e3a:	d059      	beq.n	8004ef0 <__kernel_rem_pio2f+0x290>
 8004e3c:	eeb5 9a40 	vcmp.f32	s18, #0.0
 8004e40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004e44:	d166      	bne.n	8004f14 <__kernel_rem_pio2f+0x2b4>
 8004e46:	1e63      	subs	r3, r4, #1
 8004e48:	429e      	cmp	r6, r3
 8004e4a:	dc0b      	bgt.n	8004e64 <__kernel_rem_pio2f+0x204>
 8004e4c:	aa06      	add	r2, sp, #24
 8004e4e:	4415      	add	r5, r2
 8004e50:	2200      	movs	r2, #0
 8004e52:	f855 0d04 	ldr.w	r0, [r5, #-4]!
 8004e56:	4545      	cmp	r5, r8
 8004e58:	ea42 0200 	orr.w	r2, r2, r0
 8004e5c:	d1f9      	bne.n	8004e52 <__kernel_rem_pio2f+0x1f2>
 8004e5e:	2a00      	cmp	r2, #0
 8004e60:	f040 8170 	bne.w	8005144 <__kernel_rem_pio2f+0x4e4>
 8004e64:	1e73      	subs	r3, r6, #1
 8004e66:	aa06      	add	r2, sp, #24
 8004e68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004e6c:	2b00      	cmp	r3, #0
 8004e6e:	f040 817c 	bne.w	800516a <__kernel_rem_pio2f+0x50a>
 8004e72:	9b04      	ldr	r3, [sp, #16]
 8004e74:	f04f 0e01 	mov.w	lr, #1
 8004e78:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 8004e7c:	f10e 0e01 	add.w	lr, lr, #1
 8004e80:	2a00      	cmp	r2, #0
 8004e82:	d0f9      	beq.n	8004e78 <__kernel_rem_pio2f+0x218>
 8004e84:	44a6      	add	lr, r4
 8004e86:	1c63      	adds	r3, r4, #1
 8004e88:	4573      	cmp	r3, lr
 8004e8a:	dc2f      	bgt.n	8004eec <__kernel_rem_pio2f+0x28c>
 8004e8c:	9a03      	ldr	r2, [sp, #12]
 8004e8e:	189d      	adds	r5, r3, r2
 8004e90:	9a02      	ldr	r2, [sp, #8]
 8004e92:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 8004e96:	18a0      	adds	r0, r4, r2
 8004e98:	eb0e 0c02 	add.w	ip, lr, r2
 8004e9c:	9a65      	ldr	r2, [sp, #404]	; 0x194
 8004e9e:	3d01      	subs	r5, #1
 8004ea0:	eb02 0585 	add.w	r5, r2, r5, lsl #2
 8004ea4:	aa1a      	add	r2, sp, #104	; 0x68
 8004ea6:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 8004eaa:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
 8004eae:	aa42      	add	r2, sp, #264	; 0x108
 8004eb0:	eb02 0483 	add.w	r4, r2, r3, lsl #2
 8004eb4:	f855 3f04 	ldr.w	r3, [r5, #4]!
 8004eb8:	ee07 3a90 	vmov	s15, r3
 8004ebc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004ec0:	2f00      	cmp	r7, #0
 8004ec2:	ece0 7a01 	vstmia	r0!, {s15}
 8004ec6:	eddf 7a45 	vldr	s15, [pc, #276]	; 8004fdc <__kernel_rem_pio2f+0x37c>
 8004eca:	db0b      	blt.n	8004ee4 <__kernel_rem_pio2f+0x284>
 8004ecc:	4652      	mov	r2, sl
 8004ece:	eb00 0109 	add.w	r1, r0, r9
 8004ed2:	4603      	mov	r3, r0
 8004ed4:	ed33 7a01 	vldmdb	r3!, {s14}
 8004ed8:	ecf2 6a01 	vldmia	r2!, {s13}
 8004edc:	428b      	cmp	r3, r1
 8004ede:	eee6 7a87 	vfma.f32	s15, s13, s14
 8004ee2:	d1f7      	bne.n	8004ed4 <__kernel_rem_pio2f+0x274>
 8004ee4:	4560      	cmp	r0, ip
 8004ee6:	ece4 7a01 	vstmia	r4!, {s15}
 8004eea:	d1e3      	bne.n	8004eb4 <__kernel_rem_pio2f+0x254>
 8004eec:	4674      	mov	r4, lr
 8004eee:	e719      	b.n	8004d24 <__kernel_rem_pio2f+0xc4>
 8004ef0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
 8004ef4:	ee30 9a49 	vsub.f32	s18, s0, s18
 8004ef8:	2800      	cmp	r0, #0
 8004efa:	d09f      	beq.n	8004e3c <__kernel_rem_pio2f+0x1dc>
 8004efc:	4658      	mov	r0, fp
 8004efe:	9105      	str	r1, [sp, #20]
 8004f00:	f000 fa3e 	bl	8005380 <scalbnf>
 8004f04:	ee39 9a40 	vsub.f32	s18, s18, s0
 8004f08:	9905      	ldr	r1, [sp, #20]
 8004f0a:	eeb5 9a40 	vcmp.f32	s18, #0.0
 8004f0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004f12:	d098      	beq.n	8004e46 <__kernel_rem_pio2f+0x1e6>
 8004f14:	eeb0 0a49 	vmov.f32	s0, s18
 8004f18:	f1cb 0000 	rsb	r0, fp, #0
 8004f1c:	9102      	str	r1, [sp, #8]
 8004f1e:	f000 fa2f 	bl	8005380 <scalbnf>
 8004f22:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 8004fd4 <__kernel_rem_pio2f+0x374>
 8004f26:	9902      	ldr	r1, [sp, #8]
 8004f28:	eeb4 0ac7 	vcmpe.f32	s0, s14
 8004f2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004f30:	f2c0 817e 	blt.w	8005230 <__kernel_rem_pio2f+0x5d0>
 8004f34:	eddf 7a26 	vldr	s15, [pc, #152]	; 8004fd0 <__kernel_rem_pio2f+0x370>
 8004f38:	ee60 7a27 	vmul.f32	s15, s0, s15
 8004f3c:	a806      	add	r0, sp, #24
 8004f3e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8004f42:	1c63      	adds	r3, r4, #1
 8004f44:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004f48:	f10b 0b08 	add.w	fp, fp, #8
 8004f4c:	eea7 0ac7 	vfms.f32	s0, s15, s14
 8004f50:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8004f54:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 8004f58:	ee10 2a10 	vmov	r2, s0
 8004f5c:	f840 2024 	str.w	r2, [r0, r4, lsl #2]
 8004f60:	ee17 2a90 	vmov	r2, s15
 8004f64:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8004f68:	4658      	mov	r0, fp
 8004f6a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
 8004f6e:	9303      	str	r3, [sp, #12]
 8004f70:	9102      	str	r1, [sp, #8]
 8004f72:	f000 fa05 	bl	8005380 <scalbnf>
 8004f76:	9b03      	ldr	r3, [sp, #12]
 8004f78:	9902      	ldr	r1, [sp, #8]
 8004f7a:	2b00      	cmp	r3, #0
 8004f7c:	f2c0 80c7 	blt.w	800510e <__kernel_rem_pio2f+0x4ae>
 8004f80:	f103 0e01 	add.w	lr, r3, #1
 8004f84:	ea4f 028e 	mov.w	r2, lr, lsl #2
 8004f88:	ac42      	add	r4, sp, #264	; 0x108
 8004f8a:	a806      	add	r0, sp, #24
 8004f8c:	ed9f 7a10 	vldr	s14, [pc, #64]	; 8004fd0 <__kernel_rem_pio2f+0x370>
 8004f90:	4410      	add	r0, r2
 8004f92:	18a7      	adds	r7, r4, r2
 8004f94:	ed70 7a01 	vldmdb	r0!, {s15}
 8004f98:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004f9c:	ee67 7a80 	vmul.f32	s15, s15, s0
 8004fa0:	ee20 0a07 	vmul.f32	s0, s0, s14
 8004fa4:	ed67 7a01 	vstmdb	r7!, {s15}
 8004fa8:	42a7      	cmp	r7, r4
 8004faa:	d1f3      	bne.n	8004f94 <__kernel_rem_pio2f+0x334>
 8004fac:	3a04      	subs	r2, #4
 8004fae:	4417      	add	r7, r2
 8004fb0:	2500      	movs	r5, #0
 8004fb2:	2e00      	cmp	r6, #0
 8004fb4:	f2c0 80a8 	blt.w	8005108 <__kernel_rem_pio2f+0x4a8>
 8004fb8:	2d00      	cmp	r5, #0
 8004fba:	f2c0 80a5 	blt.w	8005108 <__kernel_rem_pio2f+0x4a8>
 8004fbe:	4c06      	ldr	r4, [pc, #24]	; (8004fd8 <__kernel_rem_pio2f+0x378>)
 8004fc0:	eddf 7a06 	vldr	s15, [pc, #24]	; 8004fdc <__kernel_rem_pio2f+0x37c>
 8004fc4:	4638      	mov	r0, r7
 8004fc6:	2200      	movs	r2, #0
 8004fc8:	e00c      	b.n	8004fe4 <__kernel_rem_pio2f+0x384>
 8004fca:	bf00      	nop
 8004fcc:	08006f70 	.word	0x08006f70
 8004fd0:	3b800000 	.word	0x3b800000
 8004fd4:	43800000 	.word	0x43800000
 8004fd8:	08006f80 	.word	0x08006f80
 8004fdc:	00000000 	.word	0x00000000
 8004fe0:	42aa      	cmp	r2, r5
 8004fe2:	dc08      	bgt.n	8004ff6 <__kernel_rem_pio2f+0x396>
 8004fe4:	ecf4 6a01 	vldmia	r4!, {s13}
 8004fe8:	ecb0 7a01 	vldmia	r0!, {s14}
 8004fec:	3201      	adds	r2, #1
 8004fee:	4296      	cmp	r6, r2
 8004ff0:	eee6 7a87 	vfma.f32	s15, s13, s14
 8004ff4:	daf4      	bge.n	8004fe0 <__kernel_rem_pio2f+0x380>
 8004ff6:	aa56      	add	r2, sp, #344	; 0x158
 8004ff8:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 8004ffc:	3501      	adds	r5, #1
 8004ffe:	4575      	cmp	r5, lr
 8005000:	f1a7 0704 	sub.w	r7, r7, #4
 8005004:	ed42 7a28 	vstr	s15, [r2, #-160]	; 0xffffff60
 8005008:	d1d3      	bne.n	8004fb2 <__kernel_rem_pio2f+0x352>
 800500a:	9a64      	ldr	r2, [sp, #400]	; 0x190
 800500c:	2a03      	cmp	r2, #3
 800500e:	d85f      	bhi.n	80050d0 <__kernel_rem_pio2f+0x470>
 8005010:	e8df f002 	tbb	[pc, r2]
 8005014:	b0373767 	.word	0xb0373767
 8005018:	d110      	bne.n	800503c <__kernel_rem_pio2f+0x3dc>
 800501a:	1e63      	subs	r3, r4, #1
 800501c:	aa06      	add	r2, sp, #24
 800501e:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 8005022:	1209      	asrs	r1, r1, #8
 8005024:	e6ce      	b.n	8004dc4 <__kernel_rem_pio2f+0x164>
 8005026:	1e62      	subs	r2, r4, #1
 8005028:	ab06      	add	r3, sp, #24
 800502a:	f10d 0e18 	add.w	lr, sp, #24
 800502e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005032:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8005036:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
 800503a:	e6fd      	b.n	8004e38 <__kernel_rem_pio2f+0x1d8>
 800503c:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 8005040:	eeb4 9ae7 	vcmpe.f32	s18, s15
 8005044:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005048:	da0a      	bge.n	8005060 <__kernel_rem_pio2f+0x400>
 800504a:	2100      	movs	r1, #0
 800504c:	e6f6      	b.n	8004e3c <__kernel_rem_pio2f+0x1dc>
 800504e:	ed5f 7a1d 	vldr	s15, [pc, #-116]	; 8004fdc <__kernel_rem_pio2f+0x37c>
 8005052:	3104      	adds	r1, #4
 8005054:	42a1      	cmp	r1, r4
 8005056:	ece0 7a01 	vstmia	r0!, {s15}
 800505a:	f47f ae3b 	bne.w	8004cd4 <__kernel_rem_pio2f+0x74>
 800505e:	e64d      	b.n	8004cfc <__kernel_rem_pio2f+0x9c>
 8005060:	ee19 3a90 	vmov	r3, s19
 8005064:	2c00      	cmp	r4, #0
 8005066:	f103 0301 	add.w	r3, r3, #1
 800506a:	ee09 3a90 	vmov	s19, r3
 800506e:	bfc8      	it	gt
 8005070:	2102      	movgt	r1, #2
 8005072:	f73f aeb2 	bgt.w	8004dda <__kernel_rem_pio2f+0x17a>
 8005076:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 800507a:	ee37 9ac9 	vsub.f32	s18, s15, s18
 800507e:	2102      	movs	r1, #2
 8005080:	e6dc      	b.n	8004e3c <__kernel_rem_pio2f+0x1dc>
 8005082:	aa2e      	add	r2, sp, #184	; 0xb8
 8005084:	ed5f 7a2b 	vldr	s15, [pc, #-172]	; 8004fdc <__kernel_rem_pio2f+0x37c>
 8005088:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
 800508c:	ed3e 7a01 	vldmdb	lr!, {s14}
 8005090:	4596      	cmp	lr, r2
 8005092:	ee77 7a87 	vadd.f32	s15, s15, s14
 8005096:	d1f9      	bne.n	800508c <__kernel_rem_pio2f+0x42c>
 8005098:	2900      	cmp	r1, #0
 800509a:	d043      	beq.n	8005124 <__kernel_rem_pio2f+0x4c4>
 800509c:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
 80050a0:	9a01      	ldr	r2, [sp, #4]
 80050a2:	eeb1 7a67 	vneg.f32	s14, s15
 80050a6:	2b00      	cmp	r3, #0
 80050a8:	ee76 7ae7 	vsub.f32	s15, s13, s15
 80050ac:	ed82 7a00 	vstr	s14, [r2]
 80050b0:	dd09      	ble.n	80050c6 <__kernel_rem_pio2f+0x466>
 80050b2:	a82f      	add	r0, sp, #188	; 0xbc
 80050b4:	2201      	movs	r2, #1
 80050b6:	ecb0 7a01 	vldmia	r0!, {s14}
 80050ba:	3201      	adds	r2, #1
 80050bc:	4293      	cmp	r3, r2
 80050be:	ee77 7a87 	vadd.f32	s15, s15, s14
 80050c2:	daf8      	bge.n	80050b6 <__kernel_rem_pio2f+0x456>
 80050c4:	b109      	cbz	r1, 80050ca <__kernel_rem_pio2f+0x46a>
 80050c6:	eef1 7a67 	vneg.f32	s15, s15
 80050ca:	9b01      	ldr	r3, [sp, #4]
 80050cc:	edc3 7a01 	vstr	s15, [r3, #4]
 80050d0:	ee19 3a90 	vmov	r3, s19
 80050d4:	f003 0007 	and.w	r0, r3, #7
 80050d8:	b057      	add	sp, #348	; 0x15c
 80050da:	ecbd 8b04 	vpop	{d8-d9}
 80050de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80050e2:	aa2e      	add	r2, sp, #184	; 0xb8
 80050e4:	ed5f 7a43 	vldr	s15, [pc, #-268]	; 8004fdc <__kernel_rem_pio2f+0x37c>
 80050e8:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
 80050ec:	ed3e 7a01 	vldmdb	lr!, {s14}
 80050f0:	3b01      	subs	r3, #1
 80050f2:	1c5a      	adds	r2, r3, #1
 80050f4:	ee77 7a87 	vadd.f32	s15, s15, s14
 80050f8:	d1f8      	bne.n	80050ec <__kernel_rem_pio2f+0x48c>
 80050fa:	b109      	cbz	r1, 8005100 <__kernel_rem_pio2f+0x4a0>
 80050fc:	eef1 7a67 	vneg.f32	s15, s15
 8005100:	9b01      	ldr	r3, [sp, #4]
 8005102:	edc3 7a00 	vstr	s15, [r3]
 8005106:	e7e3      	b.n	80050d0 <__kernel_rem_pio2f+0x470>
 8005108:	ed5f 7a4c 	vldr	s15, [pc, #-304]	; 8004fdc <__kernel_rem_pio2f+0x37c>
 800510c:	e773      	b.n	8004ff6 <__kernel_rem_pio2f+0x396>
 800510e:	9a64      	ldr	r2, [sp, #400]	; 0x190
 8005110:	2a03      	cmp	r2, #3
 8005112:	d8dd      	bhi.n	80050d0 <__kernel_rem_pio2f+0x470>
 8005114:	e8df f002 	tbb	[pc, r2]
 8005118:	80020213 	.word	0x80020213
 800511c:	ed5f 7a51 	vldr	s15, [pc, #-324]	; 8004fdc <__kernel_rem_pio2f+0x37c>
 8005120:	2900      	cmp	r1, #0
 8005122:	d1bb      	bne.n	800509c <__kernel_rem_pio2f+0x43c>
 8005124:	ed9d 7a2e 	vldr	s14, [sp, #184]	; 0xb8
 8005128:	9a01      	ldr	r2, [sp, #4]
 800512a:	2b00      	cmp	r3, #0
 800512c:	edc2 7a00 	vstr	s15, [r2]
 8005130:	ee77 7a67 	vsub.f32	s15, s14, s15
 8005134:	dcbd      	bgt.n	80050b2 <__kernel_rem_pio2f+0x452>
 8005136:	9b01      	ldr	r3, [sp, #4]
 8005138:	edc3 7a01 	vstr	s15, [r3, #4]
 800513c:	e7c8      	b.n	80050d0 <__kernel_rem_pio2f+0x470>
 800513e:	ed5f 7a59 	vldr	s15, [pc, #-356]	; 8004fdc <__kernel_rem_pio2f+0x37c>
 8005142:	e7da      	b.n	80050fa <__kernel_rem_pio2f+0x49a>
 8005144:	aa06      	add	r2, sp, #24
 8005146:	f1ab 0b08 	sub.w	fp, fp, #8
 800514a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800514e:	2a00      	cmp	r2, #0
 8005150:	f47f af0a 	bne.w	8004f68 <__kernel_rem_pio2f+0x308>
 8005154:	aa06      	add	r2, sp, #24
 8005156:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 800515a:	f852 0d04 	ldr.w	r0, [r2, #-4]!
 800515e:	3b01      	subs	r3, #1
 8005160:	f1ab 0b08 	sub.w	fp, fp, #8
 8005164:	2800      	cmp	r0, #0
 8005166:	d0f8      	beq.n	800515a <__kernel_rem_pio2f+0x4fa>
 8005168:	e6fe      	b.n	8004f68 <__kernel_rem_pio2f+0x308>
 800516a:	f04f 0e01 	mov.w	lr, #1
 800516e:	e689      	b.n	8004e84 <__kernel_rem_pio2f+0x224>
 8005170:	2000      	movs	r0, #0
 8005172:	e64d      	b.n	8004e10 <__kernel_rem_pio2f+0x1b0>
 8005174:	2b00      	cmp	r3, #0
 8005176:	dd4f      	ble.n	8005218 <__kernel_rem_pio2f+0x5b8>
 8005178:	009a      	lsls	r2, r3, #2
 800517a:	a856      	add	r0, sp, #344	; 0x158
 800517c:	4410      	add	r0, r2
 800517e:	ad2e      	add	r5, sp, #184	; 0xb8
 8005180:	1d14      	adds	r4, r2, #4
 8005182:	ed10 7a28 	vldr	s14, [r0, #-160]	; 0xffffff60
 8005186:	442c      	add	r4, r5
 8005188:	18a8      	adds	r0, r5, r2
 800518a:	ed70 7a01 	vldmdb	r0!, {s15}
 800518e:	ee77 6a27 	vadd.f32	s13, s14, s15
 8005192:	42a8      	cmp	r0, r5
 8005194:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8005198:	ee77 7a27 	vadd.f32	s15, s14, s15
 800519c:	eeb0 7a66 	vmov.f32	s14, s13
 80051a0:	ed64 7a01 	vstmdb	r4!, {s15}
 80051a4:	edc0 6a00 	vstr	s13, [r0]
 80051a8:	d1ef      	bne.n	800518a <__kernel_rem_pio2f+0x52a>
 80051aa:	2b01      	cmp	r3, #1
 80051ac:	dd34      	ble.n	8005218 <__kernel_rem_pio2f+0x5b8>
 80051ae:	1d13      	adds	r3, r2, #4
 80051b0:	ac56      	add	r4, sp, #344	; 0x158
 80051b2:	4414      	add	r4, r2
 80051b4:	4403      	add	r3, r0
 80051b6:	ed14 7a28 	vldr	s14, [r4, #-160]	; 0xffffff60
 80051ba:	4402      	add	r2, r0
 80051bc:	ac2f      	add	r4, sp, #188	; 0xbc
 80051be:	4618      	mov	r0, r3
 80051c0:	ed72 7a01 	vldmdb	r2!, {s15}
 80051c4:	ee77 6a87 	vadd.f32	s13, s15, s14
 80051c8:	42a2      	cmp	r2, r4
 80051ca:	ee77 7ae6 	vsub.f32	s15, s15, s13
 80051ce:	ee77 7a87 	vadd.f32	s15, s15, s14
 80051d2:	eeb0 7a66 	vmov.f32	s14, s13
 80051d6:	ed60 7a01 	vstmdb	r0!, {s15}
 80051da:	edc2 6a00 	vstr	s13, [r2]
 80051de:	d1ef      	bne.n	80051c0 <__kernel_rem_pio2f+0x560>
 80051e0:	ed5f 7a82 	vldr	s15, [pc, #-520]	; 8004fdc <__kernel_rem_pio2f+0x37c>
 80051e4:	aa30      	add	r2, sp, #192	; 0xc0
 80051e6:	ed33 7a01 	vldmdb	r3!, {s14}
 80051ea:	4293      	cmp	r3, r2
 80051ec:	ee77 7a87 	vadd.f32	s15, s15, s14
 80051f0:	d1f9      	bne.n	80051e6 <__kernel_rem_pio2f+0x586>
 80051f2:	b1a9      	cbz	r1, 8005220 <__kernel_rem_pio2f+0x5c0>
 80051f4:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
 80051f8:	ed9d 7a2f 	vldr	s14, [sp, #188]	; 0xbc
 80051fc:	9a01      	ldr	r2, [sp, #4]
 80051fe:	eef1 7a67 	vneg.f32	s15, s15
 8005202:	eef1 6a66 	vneg.f32	s13, s13
 8005206:	eeb1 7a47 	vneg.f32	s14, s14
 800520a:	edc2 7a02 	vstr	s15, [r2, #8]
 800520e:	edc2 6a00 	vstr	s13, [r2]
 8005212:	ed82 7a01 	vstr	s14, [r2, #4]
 8005216:	e75b      	b.n	80050d0 <__kernel_rem_pio2f+0x470>
 8005218:	ed5f 7a90 	vldr	s15, [pc, #-576]	; 8004fdc <__kernel_rem_pio2f+0x37c>
 800521c:	2900      	cmp	r1, #0
 800521e:	d1e9      	bne.n	80051f4 <__kernel_rem_pio2f+0x594>
 8005220:	9801      	ldr	r0, [sp, #4]
 8005222:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8005224:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 8005226:	edc0 7a02 	vstr	s15, [r0, #8]
 800522a:	6002      	str	r2, [r0, #0]
 800522c:	6043      	str	r3, [r0, #4]
 800522e:	e74f      	b.n	80050d0 <__kernel_rem_pio2f+0x470>
 8005230:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 8005234:	a806      	add	r0, sp, #24
 8005236:	ee10 2a10 	vmov	r2, s0
 800523a:	4623      	mov	r3, r4
 800523c:	f840 2024 	str.w	r2, [r0, r4, lsl #2]
 8005240:	e692      	b.n	8004f68 <__kernel_rem_pio2f+0x308>
 8005242:	bf00      	nop
	...

08005250 <__kernel_sinf>:
 8005250:	ee10 3a10 	vmov	r3, s0
 8005254:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8005258:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 800525c:	da04      	bge.n	8005268 <__kernel_sinf+0x18>
 800525e:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8005262:	ee17 3a90 	vmov	r3, s15
 8005266:	b323      	cbz	r3, 80052b2 <__kernel_sinf+0x62>
 8005268:	ee60 7a00 	vmul.f32	s15, s0, s0
 800526c:	ed9f 5a15 	vldr	s10, [pc, #84]	; 80052c4 <__kernel_sinf+0x74>
 8005270:	eddf 5a15 	vldr	s11, [pc, #84]	; 80052c8 <__kernel_sinf+0x78>
 8005274:	ed9f 6a15 	vldr	s12, [pc, #84]	; 80052cc <__kernel_sinf+0x7c>
 8005278:	eddf 6a15 	vldr	s13, [pc, #84]	; 80052d0 <__kernel_sinf+0x80>
 800527c:	ed9f 7a15 	vldr	s14, [pc, #84]	; 80052d4 <__kernel_sinf+0x84>
 8005280:	eee7 5a85 	vfma.f32	s11, s15, s10
 8005284:	ee27 5a80 	vmul.f32	s10, s15, s0
 8005288:	eea5 6aa7 	vfma.f32	s12, s11, s15
 800528c:	eee6 6a27 	vfma.f32	s13, s12, s15
 8005290:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8005294:	b170      	cbz	r0, 80052b4 <__kernel_sinf+0x64>
 8005296:	ee27 7a45 	vnmul.f32	s14, s14, s10
 800529a:	eef6 6a00 	vmov.f32	s13, #96	; 0x60
 800529e:	eea0 7aa6 	vfma.f32	s14, s1, s13
 80052a2:	eddf 6a0d 	vldr	s13, [pc, #52]	; 80052d8 <__kernel_sinf+0x88>
 80052a6:	eed7 0a27 	vfnms.f32	s1, s14, s15
 80052aa:	eee5 0a26 	vfma.f32	s1, s10, s13
 80052ae:	ee30 0a60 	vsub.f32	s0, s0, s1
 80052b2:	4770      	bx	lr
 80052b4:	eddf 6a09 	vldr	s13, [pc, #36]	; 80052dc <__kernel_sinf+0x8c>
 80052b8:	eee7 6a87 	vfma.f32	s13, s15, s14
 80052bc:	eea6 0a85 	vfma.f32	s0, s13, s10
 80052c0:	4770      	bx	lr
 80052c2:	bf00      	nop
 80052c4:	2f2ec9d3 	.word	0x2f2ec9d3
 80052c8:	b2d72f34 	.word	0xb2d72f34
 80052cc:	3638ef1b 	.word	0x3638ef1b
 80052d0:	b9500d01 	.word	0xb9500d01
 80052d4:	3c088889 	.word	0x3c088889
 80052d8:	3e2aaaab 	.word	0x3e2aaaab
 80052dc:	be2aaaab 	.word	0xbe2aaaab

080052e0 <fabsf>:
 80052e0:	ee10 3a10 	vmov	r3, s0
 80052e4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80052e8:	ee00 3a10 	vmov	s0, r3
 80052ec:	4770      	bx	lr
 80052ee:	bf00      	nop

080052f0 <floorf>:
 80052f0:	ee10 2a10 	vmov	r2, s0
 80052f4:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
 80052f8:	0dcb      	lsrs	r3, r1, #23
 80052fa:	3b7f      	subs	r3, #127	; 0x7f
 80052fc:	2b16      	cmp	r3, #22
 80052fe:	dc17      	bgt.n	8005330 <floorf+0x40>
 8005300:	2b00      	cmp	r3, #0
 8005302:	ee10 0a10 	vmov	r0, s0
 8005306:	db19      	blt.n	800533c <floorf+0x4c>
 8005308:	491a      	ldr	r1, [pc, #104]	; (8005374 <floorf+0x84>)
 800530a:	4119      	asrs	r1, r3
 800530c:	4211      	tst	r1, r2
 800530e:	d022      	beq.n	8005356 <floorf+0x66>
 8005310:	eddf 7a19 	vldr	s15, [pc, #100]	; 8005378 <floorf+0x88>
 8005314:	ee70 7a27 	vadd.f32	s15, s0, s15
 8005318:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800531c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005320:	dd19      	ble.n	8005356 <floorf+0x66>
 8005322:	2a00      	cmp	r2, #0
 8005324:	db18      	blt.n	8005358 <floorf+0x68>
 8005326:	ea20 0301 	bic.w	r3, r0, r1
 800532a:	ee00 3a10 	vmov	s0, r3
 800532e:	4770      	bx	lr
 8005330:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8005334:	d30f      	bcc.n	8005356 <floorf+0x66>
 8005336:	ee30 0a00 	vadd.f32	s0, s0, s0
 800533a:	4770      	bx	lr
 800533c:	eddf 7a0e 	vldr	s15, [pc, #56]	; 8005378 <floorf+0x88>
 8005340:	ee70 7a27 	vadd.f32	s15, s0, s15
 8005344:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8005348:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800534c:	dd03      	ble.n	8005356 <floorf+0x66>
 800534e:	2a00      	cmp	r2, #0
 8005350:	db08      	blt.n	8005364 <floorf+0x74>
 8005352:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 800537c <floorf+0x8c>
 8005356:	4770      	bx	lr
 8005358:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 800535c:	fa42 f303 	asr.w	r3, r2, r3
 8005360:	4418      	add	r0, r3
 8005362:	e7e0      	b.n	8005326 <floorf+0x36>
 8005364:	2900      	cmp	r1, #0
 8005366:	eeff 7a00 	vmov.f32	s15, #240	; 0xf0
 800536a:	bf18      	it	ne
 800536c:	eeb0 0a67 	vmovne.f32	s0, s15
 8005370:	4770      	bx	lr
 8005372:	bf00      	nop
 8005374:	007fffff 	.word	0x007fffff
 8005378:	7149f2ca 	.word	0x7149f2ca
 800537c:	00000000 	.word	0x00000000

08005380 <scalbnf>:
 8005380:	b508      	push	{r3, lr}
 8005382:	ee10 3a10 	vmov	r3, s0
 8005386:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 800538a:	ed2d 8b02 	vpush	{d8}
 800538e:	d011      	beq.n	80053b4 <scalbnf+0x34>
 8005390:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8005394:	d211      	bcs.n	80053ba <scalbnf+0x3a>
 8005396:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 800539a:	d313      	bcc.n	80053c4 <scalbnf+0x44>
 800539c:	0dd2      	lsrs	r2, r2, #23
 800539e:	4402      	add	r2, r0
 80053a0:	2afe      	cmp	r2, #254	; 0xfe
 80053a2:	dc2e      	bgt.n	8005402 <scalbnf+0x82>
 80053a4:	2a00      	cmp	r2, #0
 80053a6:	dd1a      	ble.n	80053de <scalbnf+0x5e>
 80053a8:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 80053ac:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 80053b0:	ee00 3a10 	vmov	s0, r3
 80053b4:	ecbd 8b02 	vpop	{d8}
 80053b8:	bd08      	pop	{r3, pc}
 80053ba:	ecbd 8b02 	vpop	{d8}
 80053be:	ee30 0a00 	vadd.f32	s0, s0, s0
 80053c2:	bd08      	pop	{r3, pc}
 80053c4:	4b1d      	ldr	r3, [pc, #116]	; (800543c <scalbnf+0xbc>)
 80053c6:	eddf 7a1e 	vldr	s15, [pc, #120]	; 8005440 <scalbnf+0xc0>
 80053ca:	4298      	cmp	r0, r3
 80053cc:	ee20 0a27 	vmul.f32	s0, s0, s15
 80053d0:	db22      	blt.n	8005418 <scalbnf+0x98>
 80053d2:	ee10 3a10 	vmov	r3, s0
 80053d6:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 80053da:	3a19      	subs	r2, #25
 80053dc:	e7df      	b.n	800539e <scalbnf+0x1e>
 80053de:	f112 0f16 	cmn.w	r2, #22
 80053e2:	da1e      	bge.n	8005422 <scalbnf+0xa2>
 80053e4:	f24c 3350 	movw	r3, #50000	; 0xc350
 80053e8:	4298      	cmp	r0, r3
 80053ea:	dc0a      	bgt.n	8005402 <scalbnf+0x82>
 80053ec:	ed9f 8a15 	vldr	s16, [pc, #84]	; 8005444 <scalbnf+0xc4>
 80053f0:	eef0 0a40 	vmov.f32	s1, s0
 80053f4:	eeb0 0a48 	vmov.f32	s0, s16
 80053f8:	f000 f82a 	bl	8005450 <copysignf>
 80053fc:	ee20 0a08 	vmul.f32	s0, s0, s16
 8005400:	e7d8      	b.n	80053b4 <scalbnf+0x34>
 8005402:	ed9f 8a11 	vldr	s16, [pc, #68]	; 8005448 <scalbnf+0xc8>
 8005406:	eef0 0a40 	vmov.f32	s1, s0
 800540a:	eeb0 0a48 	vmov.f32	s0, s16
 800540e:	f000 f81f 	bl	8005450 <copysignf>
 8005412:	ee20 0a08 	vmul.f32	s0, s0, s16
 8005416:	e7cd      	b.n	80053b4 <scalbnf+0x34>
 8005418:	eddf 0a0a 	vldr	s1, [pc, #40]	; 8005444 <scalbnf+0xc4>
 800541c:	ee20 0a20 	vmul.f32	s0, s0, s1
 8005420:	e7c8      	b.n	80053b4 <scalbnf+0x34>
 8005422:	3219      	adds	r2, #25
 8005424:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 8005428:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 800542c:	eddf 7a07 	vldr	s15, [pc, #28]	; 800544c <scalbnf+0xcc>
 8005430:	ee00 3a10 	vmov	s0, r3
 8005434:	ee20 0a27 	vmul.f32	s0, s0, s15
 8005438:	e7bc      	b.n	80053b4 <scalbnf+0x34>
 800543a:	bf00      	nop
 800543c:	ffff3cb0 	.word	0xffff3cb0
 8005440:	4c000000 	.word	0x4c000000
 8005444:	0da24260 	.word	0x0da24260
 8005448:	7149f2ca 	.word	0x7149f2ca
 800544c:	33000000 	.word	0x33000000

08005450 <copysignf>:
 8005450:	ee10 3a10 	vmov	r3, s0
 8005454:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8005458:	ee10 3a90 	vmov	r3, s1
 800545c:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8005460:	4313      	orrs	r3, r2
 8005462:	ee00 3a10 	vmov	s0, r3
 8005466:	4770      	bx	lr
	...
 8005470:	20414d44 	.word	0x20414d44
 8005474:	6c696166 	.word	0x6c696166
 8005478:	00657275 	.word	0x00657275
 800547c:	67617355 	.word	0x67617355
 8005480:	25203a65 	.word	0x25203a65
 8005484:	000a0d73 	.word	0x000a0d73
 8005488:	6f666e69 	.word	0x6f666e69
 800548c:	00000000 	.word	0x00000000
 8005490:	6e72654b 	.word	0x6e72654b
 8005494:	203a6c65 	.word	0x203a6c65
 8005498:	20202020 	.word	0x20202020
 800549c:	73252020 	.word	0x73252020
 80054a0:	00000a0d 	.word	0x00000a0d
 80054a4:	2e312e33 	.word	0x2e312e33
 80054a8:	00000035 	.word	0x00000035
 80054ac:	706d6f43 	.word	0x706d6f43
 80054b0:	72656c69 	.word	0x72656c69
 80054b4:	2020203a 	.word	0x2020203a
 80054b8:	73252020 	.word	0x73252020
 80054bc:	00000a0d 	.word	0x00000a0d
 80054c0:	20434347 	.word	0x20434347
 80054c4:	2e392e34 	.word	0x2e392e34
 80054c8:	30322033 	.word	0x30322033
 80054cc:	35303531 	.word	0x35303531
 80054d0:	28203932 	.word	0x28203932
 80054d4:	656c6572 	.word	0x656c6572
 80054d8:	29657361 	.word	0x29657361
 80054dc:	52415b20 	.word	0x52415b20
 80054e0:	6d652f4d 	.word	0x6d652f4d
 80054e4:	64646562 	.word	0x64646562
 80054e8:	342d6465 	.word	0x342d6465
 80054ec:	622d395f 	.word	0x622d395f
 80054f0:	636e6172 	.word	0x636e6172
 80054f4:	65722068 	.word	0x65722068
 80054f8:	69736976 	.word	0x69736976
 80054fc:	32206e6f 	.word	0x32206e6f
 8005500:	37393732 	.word	0x37393732
 8005504:	00005d37 	.word	0x00005d37
 8005508:	68637241 	.word	0x68637241
 800550c:	63657469 	.word	0x63657469
 8005510:	65727574 	.word	0x65727574
 8005514:	7325203a 	.word	0x7325203a
 8005518:	00000a0d 	.word	0x00000a0d
 800551c:	764d5241 	.word	0x764d5241
 8005520:	4d2d4537 	.word	0x4d2d4537
 8005524:	00000000 	.word	0x00000000
 8005528:	65726f43 	.word	0x65726f43
 800552c:	72615620 	.word	0x72615620
 8005530:	746e6169 	.word	0x746e6169
 8005534:	7325203a 	.word	0x7325203a
 8005538:	00000a0d 	.word	0x00000a0d
 800553c:	74726f43 	.word	0x74726f43
 8005540:	4d2d7865 	.word	0x4d2d7865
 8005544:	00004634 	.word	0x00004634
 8005548:	74726f50 	.word	0x74726f50
 800554c:	666e4920 	.word	0x666e4920
 8005550:	20203a6f 	.word	0x20203a6f
 8005554:	73252020 	.word	0x73252020
 8005558:	00000a0d 	.word	0x00000a0d
 800555c:	61766441 	.word	0x61766441
 8005560:	6465636e 	.word	0x6465636e
 8005564:	72656b20 	.word	0x72656b20
 8005568:	206c656e 	.word	0x206c656e
 800556c:	65646f6d 	.word	0x65646f6d
 8005570:	00000000 	.word	0x00000000
 8005574:	74616c50 	.word	0x74616c50
 8005578:	6d726f66 	.word	0x6d726f66
 800557c:	2020203a 	.word	0x2020203a
 8005580:	73252020 	.word	0x73252020
 8005584:	00000a0d 	.word	0x00000a0d
 8005588:	334d5453 	.word	0x334d5453
 800558c:	30344632 	.word	0x30344632
 8005590:	69482035 	.word	0x69482035
 8005594:	50206867 	.word	0x50206867
 8005598:	6f667265 	.word	0x6f667265
 800559c:	6e616d72 	.word	0x6e616d72
 80055a0:	77206563 	.word	0x77206563
 80055a4:	20687469 	.word	0x20687469
 80055a8:	20505344 	.word	0x20505344
 80055ac:	20646e61 	.word	0x20646e61
 80055b0:	00555046 	.word	0x00555046
 80055b4:	72616f42 	.word	0x72616f42
 80055b8:	20203a64 	.word	0x20203a64
 80055bc:	20202020 	.word	0x20202020
 80055c0:	73252020 	.word	0x73252020
 80055c4:	00000a0d 	.word	0x00000a0d
 80055c8:	30324d52 	.word	0x30324d52
 80055cc:	4d203731 	.word	0x4d203731
 80055d0:	426e6961 	.word	0x426e6961
 80055d4:	6472616f 	.word	0x6472616f
 80055d8:	4d545320 	.word	0x4d545320
 80055dc:	34463233 	.word	0x34463233
 80055e0:	00003530 	.word	0x00003530
 80055e4:	6c697542 	.word	0x6c697542
 80055e8:	69742064 	.word	0x69742064
 80055ec:	203a656d 	.word	0x203a656d
 80055f0:	73252020 	.word	0x73252020
 80055f4:	73257325 	.word	0x73257325
 80055f8:	00000a0d 	.word	0x00000a0d
 80055fc:	20706553 	.word	0x20706553
 8005600:	32203920 	.word	0x32203920
 8005604:	00373130 	.word	0x00373130
 8005608:	00202d20 	.word	0x00202d20
 800560c:	353a3830 	.word	0x353a3830
 8005610:	30353a39 	.word	0x30353a39
 8005614:	00000000 	.word	0x00000000
 8005618:	6c656873 	.word	0x6c656873
 800561c:	0000006c 	.word	0x0000006c
 8005620:	68430a0d 	.word	0x68430a0d
 8005624:	4f696269 	.word	0x4f696269
 8005628:	54522f53 	.word	0x54522f53
 800562c:	65685320 	.word	0x65685320
 8005630:	0a0d6c6c 	.word	0x0a0d6c6c
 8005634:	00000000 	.word	0x00000000
 8005638:	203e6863 	.word	0x203e6863
 800563c:	00000000 	.word	0x00000000
 8005640:	0000445e 	.word	0x0000445e
 8005644:	206f6f74 	.word	0x206f6f74
 8005648:	796e616d 	.word	0x796e616d
 800564c:	67726120 	.word	0x67726120
 8005650:	6e656d75 	.word	0x6e656d75
 8005654:	0a0d7374 	.word	0x0a0d7374
 8005658:	00000000 	.word	0x00000000
 800565c:	74697865 	.word	0x74697865
 8005660:	00000000 	.word	0x00000000
 8005664:	706c6568 	.word	0x706c6568
 8005668:	00000000 	.word	0x00000000
 800566c:	6d6d6f43 	.word	0x6d6d6f43
 8005670:	73646e61 	.word	0x73646e61
 8005674:	6568203a 	.word	0x6568203a
 8005678:	6520706c 	.word	0x6520706c
 800567c:	20746978 	.word	0x20746978
 8005680:	00000000 	.word	0x00000000
 8005684:	00207325 	.word	0x00207325
 8005688:	00007325 	.word	0x00007325
 800568c:	0a0d3f20 	.word	0x0a0d3f20
 8005690:	00000000 	.word	0x00000000
 8005694:	6f6c0a0d 	.word	0x6f6c0a0d
 8005698:	74756f67 	.word	0x74756f67
 800569c:	00000000 	.word	0x00000000
 80056a0:	74737973 	.word	0x74737973
 80056a4:	00656d69 	.word	0x00656d69
 80056a8:	0d756c25 	.word	0x0d756c25
 80056ac:	0000000a 	.word	0x0000000a

080056b0 <__func__.6198>:
 80056b0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080056c0 <local_commands>:
 80056c0:	08005488 08000771 080056a0 080012b1     .T..q....V......
	...

080056e0 <__func__.6610>:
 80056e0:	51496863 64616552 656d6954 0074756f     chIQReadTimeout.

080056f0 <__func__.6607>:
 80056f0:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
 8005700:	49736761 00000000 00000000 00000000     agsI............

08005710 <__func__.6624>:
 8005710:	76456863 67695374 496c616e 00000000     chEvtSignalI....

08005720 <__func__.5973>:
 8005720:	54566863 69546f44 00496b63 00000000     chVTDoTickI.....

08005730 <__func__.7531>:
 8005730:	65537473 616c4174 00006d72 00000000     stSetAlarm......

08005740 <__func__.5884.lto_priv.75>:
 8005740:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08005750 <__func__.5884.lto_priv.76>:
 8005750:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08005760 <__func__.6646>:
 8005760:	514f6863 74697257 6d695465 74756f65     chOQWriteTimeout
	...

08005780 <__func__.7542>:
 8005780:	5f697073 5f646c6c 72617473 00000074     spi_lld_start...

08005790 <__func__.5884>:
 8005790:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080057a0 <TFTSPI_cfg>:
 80057a0:	00000000 40020800 000f0004 00000000     .......@........

080057b0 <ascii_8x16>:
	...
 80057c0:	817e0000 bd8181a5 7e818199 00000000     ..~........~....
 80057d0:	ff7e0000 c3ffffdb 7effffe7 00000000     ..~........~....
 80057e0:	00000000 fefefe6c 10387cfe 00000000     ....l....|8.....
 80057f0:	00000000 fe7c3810 0010387c 00000000     .....8|.|8......
 8005800:	18000000 e7e73c3c 3c1818e7 00000000     ....<<.....<....
 8005810:	18000000 ffff7e3c 3c18187e 00000000     ....<~..~..<....
 8005820:	00000000 3c180000 0000183c 00000000     .......<<.......
 8005830:	ffffffff c3e7ffff ffffe7c3 ffffffff     ................
 8005840:	00000000 42663c00 003c6642 00000000     .....<fBBf<.....
 8005850:	ffffffff bd99c3ff ffc399bd ffffffff     ................
 8005860:	0e1e0000 cc78321a 78cccccc 00000000     .....2x....x....
 8005870:	663c0000 3c666666 18187e18 00000000     ..<ffff<.~......
 8005880:	333f0000 3030303f e0f07030 00000000     ..?3?0000p......
 8005890:	637f0000 6363637f e6e76763 000000c0     ...c.ccccg......
 80058a0:	18000000 e73cdb18 1818db3c 00000000     ......<.<.......
 80058b0:	e0c08000 f8fef8f0 80c0e0f0 00000000     ................
 80058c0:	0e060200 3efe3e1e 02060e1e 00000000     .....>.>........
 80058d0:	3c180000 1818187e 00183c7e 00000000     ...<~...~<......
 80058e0:	66660000 66666666 66660066 00000000     ..fffffff.ff....
 80058f0:	db7f0000 1b7bdbdb 1b1b1b1b 00000000     ......{.........
 8005900:	60c67c00 c6c66c38 c60c386c 0000007c     .|.`8l..l8..|...
	...
 8005918:	fefefefe 00000000 3c180000 1818187e     ...........<~...
 8005928:	7e183c7e 00000000 3c180000 1818187e     ~<.~.......<~...
 8005938:	18181818 00000000 18180000 18181818     ................
 8005948:	183c7e18 00000000 00000000 fe0c1800     .~<.............
 8005958:	0000180c 00000000 00000000 fe603000     .............0`.
 8005968:	00003060 00000000 00000000 c0c00000     `0..............
 8005978:	0000fec0 00000000 00000000 fe6c2800     .............(l.
 8005988:	0000286c 00000000 00000000 7c383810     l(...........88|
 8005998:	00fefe7c 00000000 00000000 7c7cfefe     |.............||
 80059a8:	00103838 00000000 00000000 00000000     88..............
	...
 80059c0:	3c180000 18183c3c 18180018 00000000     ...<<<..........
 80059d0:	66666600 00000024 00000000 00000000     .fff$...........
 80059e0:	6c000000 6c6cfe6c 6c6cfe6c 00000000     ...ll.lll.ll....
 80059f0:	c67c1818 067cc0c2 7cc68606 00001818     ..|...|....|....
 8005a00:	00000000 180cc6c2 86c66030 00000000     ........0`......
 8005a10:	6c380000 dc76386c 76cccccc 00000000     ..8ll8v....v....
 8005a20:	30303000 00000060 00000000 00000000     .000`...........
 8005a30:	180c0000 30303030 0c183030 00000000     ....000000......
 8005a40:	18300000 0c0c0c0c 30180c0c 00000000     ..0........0....
 8005a50:	00000000 ff3c6600 0000663c 00000000     .....f<.<f......
 8005a60:	00000000 7e181800 00001818 00000000     .......~........
	...
 8005a78:	18181800 00000030 00000000 fe000000     ....0...........
	...
 8005a98:	18180000 00000000 00000000 180c0602     ................
 8005aa8:	80c06030 00000000 6c380000 d6d6c6c6     0`........8l....
 8005ab8:	386cc6c6 00000000 38180000 18181878     ..l8.......8x...
 8005ac8:	7e181818 00000000 c67c0000 30180c06     ...~......|....0
 8005ad8:	fec6c060 00000000 c67c0000 063c0606     `.........|...<.
 8005ae8:	7cc60606 00000000 1c0c0000 fecc6c3c     ...|........<l..
 8005af8:	1e0c0c0c 00000000 c0fe0000 06fcc0c0     ................
 8005b08:	7cc60606 00000000 60380000 c6fcc0c0     ...|......8`....
 8005b18:	7cc6c6c6 00000000 c6fe0000 180c0606     ...|............
 8005b28:	30303030 00000000 c67c0000 c67cc6c6     0000......|...|.
 8005b38:	7cc6c6c6 00000000 c67c0000 067ec6c6     ...|......|...~.
 8005b48:	780c0606 00000000 00000000 00001818     ...x............
 8005b58:	00181800 00000000 00000000 00001818     ................
 8005b68:	30181800 00000000 06000000 6030180c     ...0..........0`
 8005b78:	060c1830 00000000 00000000 00007e00     0............~..
 8005b88:	0000007e 00000000 60000000 060c1830     ~..........`0...
 8005b98:	6030180c 00000000 c67c0000 18180cc6     ..0`......|.....
 8005ba8:	18180018 00000000 7c000000 dedec6c6     ...........|....
 8005bb8:	7cc0dcde 00000000 38100000 fec6c66c     ...|.......8l...
 8005bc8:	c6c6c6c6 00000000 66fc0000 667c6666     ...........fff|f
 8005bd8:	fc666666 00000000 663c0000 c0c0c0c2     fff.......<f....
 8005be8:	3c66c2c0 00000000 6cf80000 66666666     ..f<.......lffff
 8005bf8:	f86c6666 00000000 66fe0000 68786862     ffl........fbhxh
 8005c08:	fe666260 00000000 66fe0000 68786862     `bf........fbhxh
 8005c18:	f0606060 00000000 663c0000 dec0c0c2     ```.......<f....
 8005c28:	3a66c6c6 00000000 c6c60000 c6fec6c6     ..f:............
 8005c38:	c6c6c6c6 00000000 183c0000 18181818     ..........<.....
 8005c48:	3c181818 00000000 0c1e0000 0c0c0c0c     ...<............
 8005c58:	78cccccc 00000000 66e60000 78786c66     ...x.......fflxx
 8005c68:	e666666c 00000000 60f00000 60606060     lff........`````
 8005c78:	fe666260 00000000 eec60000 c6d6fefe     `bf.............
 8005c88:	c6c6c6c6 00000000 e6c60000 cedefef6     ................
 8005c98:	c6c6c6c6 00000000 c67c0000 c6c6c6c6     ..........|.....
 8005ca8:	7cc6c6c6 00000000 66fc0000 607c6666     ...|.......fff|`
 8005cb8:	f0606060 00000000 c67c0000 c6c6c6c6     ```.......|.....
 8005cc8:	7cded6c6 00000e0c 66fc0000 6c7c6666     ...|.......fff|l
 8005cd8:	e6666666 00000000 c67c0000 0c3860c6     fff.......|..`8.
 8005ce8:	7cc6c606 00000000 7e7e0000 1818185a     ...|......~~Z...
 8005cf8:	3c181818 00000000 c6c60000 c6c6c6c6     ...<............
 8005d08:	7cc6c6c6 00000000 c6c60000 c6c6c6c6     ...|............
 8005d18:	10386cc6 00000000 c6c60000 d6d6c6c6     .l8.............
 8005d28:	6ceefed6 00000000 c6c60000 38387c6c     ...l........l|88
 8005d38:	c6c66c7c 00000000 66660000 183c6666     |l........ffff<.
 8005d48:	3c181818 00000000 c6fe0000 30180c86     ...<...........0
 8005d58:	fec6c260 00000000 303c0000 30303030     `.........<00000
 8005d68:	3c303030 00000000 80000000 3870e0c0     000<..........p8
 8005d78:	02060e1c 00000000 0c3c0000 0c0c0c0c     ..........<.....
 8005d88:	3c0c0c0c 00000000 c66c3810 00000000     ...<.....8l.....
	...
 8005dac:	0000ff00 0c183000 00000000 00000000     .....0..........
	...
 8005dc4:	7c0c7800 76cccccc 00000000 60e00000     .x.|...v.......`
 8005dd4:	666c7860 7c666666 00000000 00000000     `xlffff|........
 8005de4:	c0c67c00 7cc6c0c0 00000000 0c1c0000     .|.....|........
 8005df4:	cc6c3c0c 76cccccc 00000000 00000000     .<l....v........
 8005e04:	fec67c00 7cc6c0c0 00000000 361c0000     .|.....|.......6
 8005e14:	30783032 78303030 00000000 00000000     20x0000x........
 8005e24:	cccc7600 7ccccccc 0078cc0c 60e00000     .v.....|..x....`
 8005e34:	66766c60 e6666666 00000000 18180000     `lvffff.........
 8005e44:	18183800 3c181818 00000000 06060000     .8.....<........
 8005e54:	06060e00 06060606 003c6666 60e00000     ........ff<....`
 8005e64:	786c6660 e6666c78 00000000 18380000     `flxxlf.......8.
 8005e74:	18181818 3c181818 00000000 00000000     .......<........
 8005e84:	d6feec00 c6d6d6d6 00000000 00000000     ................
 8005e94:	6666dc00 66666666 00000000 00000000     ..ffffff........
 8005ea4:	c6c67c00 7cc6c6c6 00000000 00000000     .|.....|........
 8005eb4:	6666dc00 7c666666 00f06060 00000000     ..fffff|``......
 8005ec4:	cccc7600 7ccccccc 001e0c0c 00000000     .v.....|........
 8005ed4:	6676dc00 f0606060 00000000 00000000     ..vf```.........
 8005ee4:	60c67c00 7cc60c38 00000000 30100000     .|.`8..|.......0
 8005ef4:	3030fc30 1c363030 00000000 00000000     0.00006.........
 8005f04:	cccccc00 76cccccc 00000000 00000000     .......v........
 8005f14:	c6c6c600 386cc6c6 00000000 00000000     ......l8........
 8005f24:	d6c6c600 6cfed6d6 00000000 00000000     .......l........
 8005f34:	386cc600 c66c3838 00000000 00000000     ..l888l.........
 8005f44:	c6c6c600 7ec6c6c6 00f80c06 00000000     .......~........
 8005f54:	18ccfe00 fec66030 00000000 180e0000     ....0`..........
 8005f64:	18701818 0e181818 00000000 18180000     ..p.............
 8005f74:	18181818 18181818 00000000 18700000     ..............p.
 8005f84:	180e1818 70181818 00000000 00dc7600     .......p.....v..
	...
 8005fa4:	c66c3810 00fec6c6 00000000 fe000000     .8l.............
 8005fb4:	82828282 00fe8282 00000000 fe000000     ................
 8005fc4:	aad6aad6 00feaad6 00000000 fe000000     ................
 8005fd4:	da8a8a86 00feb2f2 00000000 fe000000     ................
 8005fe4:	fadeaad6 00febaf6 00000000 00cc0000     ................
 8005ff4:	7c0c7800 76cccccc 00000000 18306000     .x.|...v.....`0.
 8006004:	7c0c7800 76cccccc 00000000 386c3800     .x.|...v.....8l8
 8006014:	7c0c7800 76cccccc 00000000 00000000     .x.|...v........
 8006024:	c0c67c00 7cc6c0c0 00007018 6c381000     .|.....|.p....8l
 8006034:	fec67c00 7cc6c0c0 00000000 00c60000     .|.....|........
 8006044:	fec67c00 7cc6c0c0 00000000 18306000     .|.....|.....`0.
 8006054:	fec67c00 7cc6c0c0 00000000 00660000     .|.....|......f.
 8006064:	18183800 3c181818 00000000 663c1800     .8.....<......<f
 8006074:	18183800 3c181818 00000000 18306000     .8.....<.....`0.
 8006084:	18183800 3c181818 00000000 1000c600     .8.....<........
 8006094:	c6c66c38 c6c6c6fe 00000000 10386c38     8l..........8l8.
 80060a4:	fec66c38 c6c6c6c6 00000000 fe00180c     8l..............
 80060b4:	78686266 fe666268 00000000 00000000     fbhxhbf.........
 80060c4:	3636ec00 6ed8d87e 00000000 6c3e0000     ..66~..n......>l
 80060d4:	ccfecccc cecccccc 00000000 6c381000     ..............8l
 80060e4:	c6c67c00 7cc6c6c6 00000000 00c60000     .|.....|........
 80060f4:	c6c67c00 7cc6c6c6 00000000 18306000     .|.....|.....`0.
 8006104:	c6c67c00 7cc6c6c6 00000000 cc783000     .|.....|.....0x.
 8006114:	cccccc00 76cccccc 00000000 18306000     .......v.....`0.
 8006124:	cccccc00 76cccccc 00000000 00c60000     .......v........
 8006134:	c6c6c600 7ec6c6c6 00780c06 7c00c600     .......~..x....|
 8006144:	c6c6c6c6 7cc6c6c6 00000000 c600c600     .......|........
 8006154:	c6c6c6c6 7cc6c6c6 00000000 7c181800     .......|.......|
 8006164:	c0c0c0c6 18187cc6 00000000 646c3800     .....|.......8ld
 8006174:	6060f060 fce66060 00000000 66660000     `.````........ff
 8006184:	187e183c 1818187e 00000000 ccccf800     <.~.~...........
 8006194:	deccc4f8 c6cccccc 00000000 181b0e00     ................
 80061a4:	187e1818 70d81818 00000000 60301800     ..~....p......0`
 80061b4:	7c0c7800 76cccccc 00000000 30180c00     .x.|...v.......0
 80061c4:	18183800 3c181818 00000000 60301800     .8.....<......0`
 80061d4:	c6c67c00 7cc6c6c6 00000000 60301800     .|.....|......0`
 80061e4:	cccccc00 76cccccc 00000000 dc760000     .......v......v.
 80061f4:	6666dc00 66666666 00000000 c600dc76     ..ffffff....v...
 8006204:	defef6e6 c6c6c6ce 00000000 6c3c0000     ..............<l
 8006214:	7e003e6c 00000000 00000000 6c380000     l>.~..........8l
 8006224:	7c00386c 00000000 00000000 30300000     l8.|..........00
 8006234:	60303000 7cc6c6c0 00000000 00000000     .00`...|........
 8006244:	c0fe0000 00c0c0c0 00000000 00000000     ................
 8006254:	06fe0000 00060606 00000000 62e06000     .............`.b
 8006264:	30186c66 0c86dc60 00003e18 62e06000     fl.0`....>...`.b
 8006274:	30186c66 3f9ace66 00000606 18180000     fl.0f..?........
 8006284:	18181800 183c3c3c 00000000 00000000     ....<<<.........
 8006294:	d86c3600 0000366c 00000000 00000000     .6l.l6..........
 80062a4:	366cd800 0000d86c 00000000 44114411     ..l6l........D.D
 80062b4:	44114411 44114411 44114411 aa55aa55     .D.D.D.D.D.DU.U.
 80062c4:	aa55aa55 aa55aa55 aa55aa55 77dd77dd     U.U.U.U.U.U..w.w
 80062d4:	77dd77dd 77dd77dd 77dd77dd 18181818     .w.w.w.w.w.w....
 80062e4:	18181818 18181818 18181818 18181818     ................
 80062f4:	f8181818 18181818 18181818 18181818     ................
 8006304:	f818f818 18181818 18181818 36363636     ............6666
 8006314:	f6363636 36363636 36363636 00000000     666.66666666....
 8006324:	fe000000 36363636 36363636 00000000     ....66666666....
 8006334:	f818f800 18181818 18181818 36363636     ............6666
 8006344:	f606f636 36363636 36363636 36363636     6...666666666666
 8006354:	36363636 36363636 36363636 00000000     666666666666....
 8006364:	f606fe00 36363636 36363636 36363636     ....666666666666
 8006374:	fe06f636 00000000 00000000 36363636     6...........6666
 8006384:	fe363636 00000000 00000000 18181818     666.............
 8006394:	f818f818 00000000 00000000 00000000     ................
 80063a4:	f8000000 18181818 18181818 18181818     ................
 80063b4:	1f181818 00000000 00000000 18181818     ................
 80063c4:	ff181818 00000000 00000000 00000000     ................
 80063d4:	ff000000 18181818 18181818 18181818     ................
 80063e4:	1f181818 18181818 18181818 00000000     ................
 80063f4:	ff000000 00000000 00000000 18181818     ................
 8006404:	ff181818 18181818 18181818 18181818     ................
 8006414:	1f181f18 18181818 18181818 36363636     ............6666
 8006424:	37363636 36363636 36363636 36363636     6667666666666666
 8006434:	3f303736 00000000 00000000 00000000     670?............
 8006444:	37303f00 36363636 36363636 36363636     .?07666666666666
 8006454:	ff00f736 00000000 00000000 00000000     6...............
 8006464:	f700ff00 36363636 36363636 36363636     ....666666666666
 8006474:	37303736 36363636 36363636 00000000     670766666666....
 8006484:	ff00ff00 00000000 00000000 36363636     ............6666
 8006494:	f700f736 36363636 36363636 18181818     6...66666666....
 80064a4:	ff00ff18 00000000 00000000 36363636     ............6666
 80064b4:	ff363636 00000000 00000000 00000000     666.............
 80064c4:	ff00ff00 18181818 18181818 00000000     ................
 80064d4:	ff000000 36363636 36363636 36363636     ....666666666666
 80064e4:	3f363636 00000000 00000000 18181818     666?............
 80064f4:	1f181f18 00000000 00000000 00000000     ................
 8006504:	1f181f00 18181818 18181818 00000000     ................
 8006514:	3f000000 36363636 36363636 36363636     ...?666666666666
 8006524:	ff363636 36363636 36363636 18181818     666.66666666....
 8006534:	ff18ff18 18181818 18181818 18181818     ................
 8006544:	f8181818 00000000 00000000 00000000     ................
 8006554:	1f000000 18181818 18181818 ffffffff     ................
 8006564:	ffffffff ffffffff ffffffff 00000000     ................
 8006574:	ff000000 ffffffff ffffffff f0f0f0f0     ................
 8006584:	f0f0f0f0 f0f0f0f0 f0f0f0f0 0f0f0f0f     ................
 8006594:	0f0f0f0f 0f0f0f0f 0f0f0f0f ffffffff     ................
 80065a4:	00ffffff 00000000 00000000 00000000     ................
 80065b4:	d8dc7600 76dcd8d8 00000000 cc780000     .v.....v......x.
 80065c4:	ccd8cccc ccc6c6c6 00000000 c6fe0000     ................
 80065d4:	c0c0c0c6 c0c0c0c0 00000000 00000000     ................
 80065e4:	6c6cfe00 6c6c6c6c 00000000 c6fe0000     ..llllll........
 80065f4:	18183060 fec66030 00000000 00000000     `0..0`..........
 8006604:	d8d87e00 70d8d8d8 00000000 00000000     .~.....p........
 8006614:	66666600 7c666666 00c06060 00000000     .ffffff|``......
 8006624:	1818dc76 18181818 00000000 187e0000     v.............~.
 8006634:	6666663c 7e183c66 00000000 6c380000     <ffff<.~......8l
 8006644:	c6fec6c6 386cc6c6 00000000 6c380000     ......l8......8l
 8006654:	6cc6c6c6 ee6c6c6c 00000000 301e0000     ...llll........0
 8006664:	663e0c18 3c666666 00000000 00000000     ..>ffff<........
 8006674:	dbdb7e00 00007edb 00000000 03000000     .~...~..........
 8006684:	dbdb7e06 c0607ef3 00000000 301c0000     .~...~`........0
 8006694:	607c6060 1c306060 00000000 7c000000     ``|```0........|
 80066a4:	c6c6c6c6 c6c6c6c6 00000000 00000000     ................
 80066b4:	fe0000fe 00fe0000 00000000 00000000     ................
 80066c4:	187e1818 7e000018 00000000 30000000     ..~....~.......0
 80066d4:	0c060c18 7e003018 00000000 0c000000     .....0.~........
 80066e4:	30603018 7e000c18 00000000 1b0e0000     .0`0...~........
 80066f4:	1818181b 18181818 18181818 18181818     ................
 8006704:	18181818 d8d8d818 00000070 00000000     ........p.......
 8006714:	7e001800 00001800 00000000 00000000     ...~............
 8006724:	00dc7600 0000dc76 00000000 6c6c3800     .v..v........8ll
 8006734:	00000038 00000000 00000000 00000000     8...............
 8006744:	18000000 00000018 00000000 00000000     ................
 8006754:	18000000 00000000 00000000 0c0c0f00     ................
 8006764:	ec0c0c0c 1c3c6c6c 00000000 36366c00     ....ll<......l66
 8006774:	00363636 00000000 00000000 0c663c00     666..........<f.
 8006784:	007e3218 00000000 00000000 00000000     .2~.............
 8006794:	7e7e7e7e 007e7e7e 00000000 00000000     ~~~~~~~.........
	...
 80067b0:	6c756e28 0000296c 20544654 70736944     (null)..TFT Disp
 80067c0:	0079616c 6f626f52 7473616d 32207265     lay.Robomaster 2
 80067d0:	00383130 4c544654 00004443 00000000     018.TFTLCD......

080067e0 <__func__.6590>:
 80067e0:	744d6863 636f4c78 0000536b 00000000     chMtxLockS......

080067f0 <__func__.7528>:
 80067f0:	53697073 74726174 00000000 00000000     spiStart........

08006800 <__func__.6599>:
 8006800:	68546863 65724364 49657461 00000000     chThdCreateI....

08006810 <__func__.6665>:
 8006810:	68546863 73655264 49656d75 00000000     chThdResumeI....

08006820 <__func__.6615>:
 8006820:	63536863 6b615768 53707565 00000000     chSchWakeupS....
 8006830:	63617473 766f206b 6c667265 0000776f     stack overflow..
 8006840:	31235653 00000031 31235653 00000030     SV#11...SV#10...
 8006850:	39235653 00000000 38235653 00000000     SV#9....SV#8....
 8006860:	37235653 00000000 36235653 00000000     SV#7....SV#6....
 8006870:	35235653 00000000 34235653 00000000     SV#5....SV#4....

08006880 <ram_areas>:
 8006880:	08006fb0 200032e0 200032e0 200032e0     .o...2. .2. .2. 
 8006890:	08006fb0 20000000 20000000 20000000     .o..... ... ... 
 80068a0:	08006fb0 2001c000 2001c000 2001c000     .o..... ... ... 
 80068b0:	08006fb0 00000000 00000000 00000000     .o..............
 80068c0:	08006fb0 10000000 10000000 10000000     .o..............
 80068d0:	08006fb0 40024000 40024000 40024000     .o...@.@.@.@.@.@
 80068e0:	08006fb0 00000000 00000000 00000000     .o..............
 80068f0:	08006fb0 00000000 00000000 00000000     .o..............

08006900 <__func__.6590>:
 8006900:	54566863 65536f44 00004974 00000000     chVTDoSetI......

08006910 <__func__.7524>:
 8006910:	74537473 41747261 6d72616c 00000000     stStartAlarm....

08006920 <__func__.6587>:
 8006920:	63536863 61655268 00497964 00000000     chSchReadyI.....

08006930 <__func__.6643>:
 8006930:	68546863 69784564 00005374 00000000     chThdExitS......

08006940 <__func__.6058.lto_priv.80>:
 8006940:	68546863 656c5364 00537065 00000000     chThdSleepS.....

08006950 <commands>:
 8006950:	080069b8 08004111 080069c0 08004091     .i...A...i...@..

08006960 <ch_debug>:
 8006960:	6e69616d 18451600 08600404 1814100c     main..E...`.....
 8006970:	2221201c 00000000 00000000 00000000     . !"............
 8006980:	33235653 00000000 656c6469 00000000     SV#3....idle....
 8006990:	74736554 00000000 74736f48 72687420     Test....Host thr
 80069a0:	20646165 656d6974 2074756f 7563636f     ead timeout occu
 80069b0:	21646572 00000000 74736574 00000000     red!....test....
 80069c0:	61746164 00000000 00000000 00000000     data............

080069d0 <shell_cfg1>:
 80069d0:	200021c4 08006950 00000000 00000000     .!. Pi..........

080069e0 <vmt>:
 80069e0:	08001cb1 08001eb1 08001d81 08001f81     ................
 80069f0:	08001d71 08001f71 08001ca1 08001ea1     q...q...........

08006a00 <__func__.5884.lto_priv.79>:
 8006a00:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08006a10 <_stm32_dma_streams>:
 8006a10:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
 8006a20:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
 8006a30:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
 8006a40:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
 8006a50:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
 8006a60:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
 8006a70:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
 8006a80:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
 8006a90:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
 8006aa0:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
 8006ab0:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
 8006ac0:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

08006ad0 <__func__.7536>:
 8006ad0:	53697073 63656c65 00000074 00000000     spiSelect.......

08006ae0 <__func__.6653>:
 8006ae0:	68546863 73755364 646e6570 00000053     chThdSuspendS...

08006af0 <__func__.7602>:
 8006af0:	53616d64 61657274 6c6c416d 7461636f     dmaStreamAllocat
 8006b00:	00000065 00000000 00000000 00000000     e...............

08006b10 <vmt>:
 8006b10:	08002001 08001fd1 08001fb1 08001f91     . ..............

08006b20 <__func__.7569>:
 8006b20:	74536473 00747261 00000000 00000000     sdStart.........

08006b30 <__func__.7540>:
 8006b30:	55697073 6c65736e 00746365 00000000     spiUnselect.....
 8006b40:	61746144 61727420 696d736e 6f697373     Data transmissio
 8006b50:	7473206e 20747261 25206e69 65732064     n start in %d se
 8006b60:	646e6f63 2e2e2e73 00000000 6c656853     conds.......Shel
 8006b70:	6f57206c 6e696b72 00000067 00000920     l Working... ...

08006b80 <__func__.6070.lto_priv.69>:
 8006b80:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
 8006b90:	00497478 00000000 00000000 00000000     xtI.............

08006ba0 <__func__.7582>:
 8006ba0:	53697073 00646e65 00000000 00000000     spiSend.........

08006bb0 <__func__.5884.lto_priv.46>:
 8006bb0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08006bc0 <__func__.5884.lto_priv.47>:
 8006bc0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08006bd0 <npio2_hw>:
 8006bd0:	3fc90f00 40490f00 4096cb00 40c90f00     ...?..I@...@...@
 8006be0:	40fb5300 4116cb00 412fed00 41490f00     .S.@...A../A..IA
 8006bf0:	41623100 417b5300 418a3a00 4196cb00     .1bA.S{A.:.A...A
 8006c00:	41a35c00 41afed00 41bc7e00 41c90f00     .\.A...A.~.A...A
 8006c10:	41d5a000 41e23100 41eec200 41fb5300     ...A.1.A...A.S.A
 8006c20:	4203f200 420a3a00 42108300 4216cb00     ...B.:.B...B...B
 8006c30:	421d1400 42235c00 4229a500 422fed00     ...B.\#B..)B../B
 8006c40:	42363600 423c7e00 4242c700 42490f00     .66B.~<B..BB..IB

08006c50 <two_over_pi>:
 8006c50:	000000a2 000000f9 00000083 0000006e     ............n...
 8006c60:	0000004e 00000044 00000015 00000029     N...D.......)...
 8006c70:	000000fc 00000027 00000057 000000d1     ....'...W.......
 8006c80:	000000f5 00000034 000000dd 000000c0     ....4...........
 8006c90:	000000db 00000062 00000095 00000099     ....b...........
 8006ca0:	0000003c 00000043 00000090 00000041     <...C.......A...
 8006cb0:	000000fe 00000051 00000063 000000ab     ....Q...c.......
 8006cc0:	000000de 000000bb 000000c5 00000061     ............a...
 8006cd0:	000000b7 00000024 0000006e 0000003a     ....$...n...:...
 8006ce0:	00000042 0000004d 000000d2 000000e0     B...M...........
 8006cf0:	00000006 00000049 0000002e 000000ea     ....I...........
 8006d00:	00000009 000000d1 00000092 0000001c     ................
 8006d10:	000000fe 0000001d 000000eb 0000001c     ................
 8006d20:	000000b1 00000029 000000a7 0000003e     ....).......>...
 8006d30:	000000e8 00000082 00000035 000000f5     ........5.......
 8006d40:	0000002e 000000bb 00000044 00000084     ........D.......
 8006d50:	000000e9 0000009c 00000070 00000026     ........p...&...
 8006d60:	000000b4 0000005f 0000007e 00000041     ...._...~...A...
 8006d70:	00000039 00000091 000000d6 00000039     9...........9...
 8006d80:	00000083 00000053 00000039 000000f4     ....S...9.......
 8006d90:	0000009c 00000084 0000005f 0000008b     ........_.......
 8006da0:	000000bd 000000f9 00000028 0000003b     ........(...;...
 8006db0:	0000001f 000000f8 00000097 000000ff     ................
 8006dc0:	000000de 00000005 00000098 0000000f     ................
 8006dd0:	000000ef 0000002f 00000011 0000008b     ..../...........
 8006de0:	0000005a 0000000a 0000006d 0000001f     Z.......m.......
 8006df0:	0000006d 00000036 0000007e 000000cf     m...6...~.......
 8006e00:	00000027 000000cb 00000009 000000b7     '...............
 8006e10:	0000004f 00000046 0000003f 00000066     O...F...?...f...
 8006e20:	0000009e 0000005f 000000ea 0000002d     ...._.......-...
 8006e30:	00000075 00000027 000000ba 000000c7     u...'...........
 8006e40:	000000eb 000000e5 000000f1 0000007b     ............{...
 8006e50:	0000003d 00000007 00000039 000000f7     =.......9.......
 8006e60:	0000008a 00000052 00000092 000000ea     ....R...........
 8006e70:	0000006b 000000fb 0000005f 000000b1     k......._.......
 8006e80:	0000001f 0000008d 0000005d 00000008     ........].......
 8006e90:	00000056 00000003 00000030 00000046     V.......0...F...
 8006ea0:	000000fc 0000007b 0000006b 000000ab     ....{...k.......
 8006eb0:	000000f0 000000cf 000000bc 00000020     ............ ...
 8006ec0:	0000009a 000000f4 00000036 0000001d     ........6.......
 8006ed0:	000000a9 000000e3 00000091 00000061     ............a...
 8006ee0:	0000005e 000000e6 0000001b 00000008     ^...............
 8006ef0:	00000065 00000099 00000085 0000005f     e..........._...
 8006f00:	00000014 000000a0 00000068 00000040     ........h...@...
 8006f10:	0000008d 000000ff 000000d8 00000080     ................
 8006f20:	0000004d 00000073 00000027 00000031     M...s...'...1...
 8006f30:	00000006 00000006 00000015 00000056     ............V...
 8006f40:	000000ca 00000073 000000a8 000000c9     ....s...........
 8006f50:	00000060 000000e2 0000007b 000000c0     `.......{.......
 8006f60:	0000008c 0000006b 00000000 00000000     ....k...........

08006f70 <init_jk>:
 8006f70:	00000004 00000007 00000009 00000000     ................

08006f80 <PIo2>:
 8006f80:	3fc90000 39f00000 37da0000 33a20000     ...?...9...7...3
 8006f90:	2e840000 2b500000 27c20000 22d00000     ......P+...'..."
 8006fa0:	1fc40000 1bc60000 17440000              ..........D.
